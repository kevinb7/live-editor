<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title></title>
  <link rel="stylesheet" href="style.css"/>
</head>
<body>

<div id="wrapper">
  <div id="container">
    <h1>live-editor: possible features</h1>
    <p>
      by Kevin Barabash<br>
      github: <a href="http://github.com/kevinb7">kevinb7</a>
    </p>
    
    <h2>Improving Page Load Speed and App Responsiveness</h2>
    <p>
      Let's start with some numbers first.  I've discarded the first load because
      the browser is busy doing other intialization stuff.  I've also stopped 
      reloading the page and opened a new browser after the next 3 reloads because
      garbage accumulates and then measurements are thrown off by garbage collections.
      The measurements below are for when the first run of the user's code completes.
      This measurement is taken using performance.now() and works in Chrome and
      Firefox.
      <ul>
        <li>
          <b>Uncached</b><br>
          vanilla - 1500~2500ms<br>
          optimized - 1000ms~1300ms
        </li>
        <li>
          <b>Cached</b><br>
          vanilla - 1200~1500ms<br>
          optimized - 900ms~1100ms
        </li>
      </ul>
      <p>
        The optimized version performs significantly better in than the vanilla
        implementation in the uncached situation.  In the cached situation it's
        still a little bit better but not by a huge margin.
      </p>
      <p>
        To improve page load speed the following change were made:
      </p>
      <ul>
        <li>
          <b>Packaged all web workers and their dependencies in a single JSON file:</b>
          <br><br>
          This reduces the number of network requests and avoids downloading 
          shared dependencies more than once.  It also allows web workers to 
          initialize faster because they avoid calls to importScripts which 
          block until the script has been downloaded from the network.
        </li>
        <li>
          <b>Reduced the amount of JavaScript being used:</b>
          <br><br>
          core_deps and output_pjs_deps were reduced in size by approximately
          50%.  Individual jquery-ui modules were included instead of the whole
          thing.  dialog-polyfill replaced jquery.ui.modal.  On the output side
          of things p5.js replaced processing-js.
        </li>
        <li>
          <b>Embed user code from server in output.html and run without linting or testing:</b>
          <br><br>
          The assumption being made is that there is a copy of the code that 
          has been linted and tested sitting on the server.  For now, the user
          code in the demo has been hard coded into output.html.  Because the
          user's program is being run sooner the app looks like it's loading faster.
        </li>
      </ul>
    </p>
    <p>
      Reduction in the amount of code that was being sent to the browser also 
      resulted in a reduction of memory use in the main heap:
      <ul>
        <li>Vanilla: 24.9 MB (main heap) – 37.3 MB (total)</li>
        <li>Optimized: 20.7 MB (main heap) – 34.4 MB (total)</li>
      </ul>
      It should be noted that the optimized version ends up allocating more workers
      when scrubbing because the other workers are needed more often.
    </p>
    <p>
      To improve app responsiveness linting was skipped when the user is using the
      number scrubber or color picker.  It's safe to make do this because the 
      structure of the code is not changing, just the values.
    </p>
    <p>
      Profiling on my
      machine (2012 MacBook Air: Core i5 @ 1.7 GHz) I saw an improvement from
      ~15 fps to ~35 fps (on average).  Scrubbing feels much more fluid.
      There is still an initial lint that's done to get a list of globals.
      This can be avoided by store the list of globals on the server and 
      embedding it in the page when serving output.html.
    </p>
    <p>
      Optimized: <a href="optimized/index.html">demo</a> <a href="optimized/index.html?noLint=false">demo (always lint)</a>
    </p>
    <p>
      Unoptimized: <a href="vanilla/index.html">demo</a>
    </p>

    <h2>3D API</h2>
    <p>
      Modifies the processing-js API by replacing 2D drawing primitives with a very
      simple 3D scene graph.  The scene graph contains only a single object called
      "mesh" which users can add vertices, edges, and faces to.  While the user is
      building the mesh they can rotate it as well as toggle different overlays that
      show each vertex's index (label) and/or face normals.  This makes it easier
      for users to create geometry as well as debug common problems in 3D programming
      such as faces pointing the wrong way.
    </p>
    <p>
      The 3D rendering is done by a very simple Canvas based library I wrote called
      platonic-solids.  It uses the fact that platonic solids are all convex to take
      some short cuts to avoid implementing a depth buffer.  I would like to replace 
      this library with something more robust like THREE.js and/or voxel.js.
    </p>
    <p>
      <a href="3d_api/index.html">demo</a>
    </p>
    <p>
      <iframe width="640" height="480" src="//www.youtube.com/embed/c2cPbbDGx7A?rel=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe>
    </p>
    <h2>Remote Output</h2>
    <p>
      Breaks "output.html" out of its iframe and puts it in its own tab, window,
      browser, or device.  The main "index.html" communicates with "output.html"
      by sending messages to a public server.
    </p>
    <p>
      The server is implemented in Python and uses Google App Engine to serve
      files and the Channel API to ferry messages between the two pages.  For
      more details see <a href="https://github.com/kevinb7/live-editor-server">live-editor-server</a>.
    </p>
    <p>
      <a href="http://elite-clover-821.appspot.com/editor">demo editor</a>
    </p>
    <p>
      <a href="http://elite-clover-821.appspot.com/output">demo output</a>
    </p>
    <p>
      <iframe width="640" height="480" src="//www.youtube.com/embed/SsBHcmZrOuA?rel=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe>
    </p>
    <h2>Tidy</h2>
    <p>
      The "Tidy" button automatically format all of the code in the editor.  It
      uses the "preserveBlankLines" option that I added to escodegen to preserve
      spaces between lines.  It also keeps track of not only the cursor position
      in the code but also the relative distance of the cursor from the top of 
      the editor's viewport so that user's position is maintained after 
      formatting occurs.
    </p>
    <p>
      <a href="tidy/index.html">demo</a>
    </p>
    <p>
      <span style="font-style:italic;color:#999;">Hover over to see more screenshots.</span>
    </p>
    <div id="tidy_container">
      <img id="tidy_0" src="images/tidy_0.png" style="display:block;">
      <img id="tidy_1" src="images/tidy_1.png" style="display:none;">
    </div>

    <h2>Debugger</h2>
    <p>
      Integrates <a href="https://github.com/kevinb7/debugger">kevinb7/debugger</a>
      into the live-editor.  It implements two interfaces: basic and advanced.
    </p>
    <p>
      The basic interface does not require the user to set a breakpoint.  The
      user begins debugging by clicking on the "Begin" button.  This will restart
      the programming and automatically break on the first line.  The user can
      advance the program by clicking "Step" which will step into each function
      call.  The "End" will run to the end of the program if no breakpoints have
      been set.  This mode does not prevent the setting of breakpoints.  Whether
      "End" should ignore all breakpoints or setting breakpoints should be disabled
      in this mode is an open question.
    </p>
    <p>
      The advanced mode behaves more like a traditional debugger where the user
      must set breakpoints.  It supports stepping in, out, and over method calls.
    </p>
    <p>
      <a href="debugger/index.html?debugger=true">demo</a>
    </p>
    <p>
      <span style="font-style:italic;color:#999;">Hover over to see more screenshots.</span>
    </p>
    <div id="debugger_container">
      <img id="debugger_0" src="images/debugger_0.png" style="display:block;">
      <img id="debugger_1" src="images/debugger_1.png" style="display:none;">
      <img id="debugger_2" src="images/debugger_2.png" style="display:none;">
    </div>
  </div>

</div>





</body>
</html>
<script src="index.js"></script>
