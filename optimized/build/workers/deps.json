{
  "es5-shim.js": "/*!\n * https://github.com/es-shims/es5-shim\n * @license es5-shim Copyright 2009-2014 by contributors, MIT License\n * see https://github.com/es-shims/es5-shim/blob/master/LICENSE\n */\n\n// vim: ts=4 sts=4 sw=4 expandtab\n\n//Add semicolon to prevent IIFE from being passed as argument to concated code.\n;\n\n// UMD (Universal Module Definition)\n// see https://github.com/umdjs/umd/blob/master/returnExports.js\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like enviroments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory();\n    }\n}(this, function () {\n\n/**\n * Brings an environment as close to ECMAScript 5 compliance\n * as is possible with the facilities of erstwhile engines.\n *\n * Annotated ES5: http://es5.github.com/ (specific links below)\n * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\n * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/\n */\n\n// Shortcut to an often accessed properties, in order to avoid multiple\n// dereference that costs universally.\nvar call = Function.prototype.call;\nvar prototypeOfArray = Array.prototype;\nvar prototypeOfObject = Object.prototype;\nvar _Array_slice_ = prototypeOfArray.slice;\nvar array_splice = Array.prototype.splice;\nvar array_push = Array.prototype.push;\nvar array_unshift = Array.prototype.unshift;\n\n// Having a toString local variable name breaks in Opera so use _toString.\nvar _toString = prototypeOfObject.toString;\n\nvar isFunction = function (val) {\n    return prototypeOfObject.toString.call(val) === '[object Function]';\n};\nvar isRegex = function (val) {\n    return prototypeOfObject.toString.call(val) === '[object RegExp]';\n};\nvar isArray = function isArray(obj) {\n    return _toString.call(obj) === \"[object Array]\";\n};\nvar isArguments = function isArguments(value) {\n    var str = _toString.call(value);\n    var isArgs = str === '[object Arguments]';\n    if (!isArgs) {\n        isArgs = !isArray(str)\n            && value !== null\n            && typeof value === 'object'\n            && typeof value.length === 'number'\n            && value.length >= 0\n            && isFunction(value.callee);\n    }\n    return isArgs;\n};\n\n//\n// Function\n// ========\n//\n\n// ES-5 15.3.4.5\n// http://es5.github.com/#x15.3.4.5\n\nfunction Empty() {}\n\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function bind(that) { // .length is 1\n        // 1. Let Target be the this value.\n        var target = this;\n        // 2. If IsCallable(Target) is false, throw a TypeError exception.\n        if (!isFunction(target)) {\n            throw new TypeError(\"Function.prototype.bind called on incompatible \" + target);\n        }\n        // 3. Let A be a new (possibly empty) internal list of all of the\n        //   argument values provided after thisArg (arg1, arg2 etc), in order.\n        // XXX slicedArgs will stand in for \"A\" if used\n        var args = _Array_slice_.call(arguments, 1); // for normal call\n        // 4. Let F be a new native ECMAScript object.\n        // 11. Set the [[Prototype]] internal property of F to the standard\n        //   built-in Function prototype object as specified in 15.3.3.1.\n        // 12. Set the [[Call]] internal property of F as described in\n        //   15.3.4.5.1.\n        // 13. Set the [[Construct]] internal property of F as described in\n        //   15.3.4.5.2.\n        // 14. Set the [[HasInstance]] internal property of F as described in\n        //   15.3.4.5.3.\n        var binder = function () {\n\n            if (this instanceof bound) {\n                // 15.3.4.5.2 [[Construct]]\n                // When the [[Construct]] internal method of a function object,\n                // F that was created using the bind function is called with a\n                // list of arguments ExtraArgs, the following steps are taken:\n                // 1. Let target be the value of F's [[TargetFunction]]\n                //   internal property.\n                // 2. If target has no [[Construct]] internal method, a\n                //   TypeError exception is thrown.\n                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\n                //   property.\n                // 4. Let args be a new list containing the same values as the\n                //   list boundArgs in the same order followed by the same\n                //   values as the list ExtraArgs in the same order.\n                // 5. Return the result of calling the [[Construct]] internal\n                //   method of target providing args as the arguments.\n\n                var result = target.apply(\n                    this,\n                    args.concat(_Array_slice_.call(arguments))\n                );\n                if (Object(result) === result) {\n                    return result;\n                }\n                return this;\n\n            } else {\n                // 15.3.4.5.1 [[Call]]\n                // When the [[Call]] internal method of a function object, F,\n                // which was created using the bind function is called with a\n                // this value and a list of arguments ExtraArgs, the following\n                // steps are taken:\n                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\n                //   property.\n                // 2. Let boundThis be the value of F's [[BoundThis]] internal\n                //   property.\n                // 3. Let target be the value of F's [[TargetFunction]] internal\n                //   property.\n                // 4. Let args be a new list containing the same values as the\n                //   list boundArgs in the same order followed by the same\n                //   values as the list ExtraArgs in the same order.\n                // 5. Return the result of calling the [[Call]] internal method\n                //   of target providing boundThis as the this value and\n                //   providing args as the arguments.\n\n                // equiv: target.call(this, ...boundArgs, ...args)\n                return target.apply(\n                    that,\n                    args.concat(_Array_slice_.call(arguments))\n                );\n\n            }\n\n        };\n\n        // 15. If the [[Class]] internal property of Target is \"Function\", then\n        //     a. Let L be the length property of Target minus the length of A.\n        //     b. Set the length own property of F to either 0 or L, whichever is\n        //       larger.\n        // 16. Else set the length own property of F to 0.\n\n        var boundLength = Math.max(0, target.length - args.length);\n\n        // 17. Set the attributes of the length own property of F to the values\n        //   specified in 15.3.5.1.\n        var boundArgs = [];\n        for (var i = 0; i < boundLength; i++) {\n            boundArgs.push(\"$\" + i);\n        }\n\n        // XXX Build a dynamic function with desired amount of arguments is the only\n        // way to set the length property of a function.\n        // In environments where Content Security Policies enabled (Chrome extensions,\n        // for ex.) all use of eval or Function costructor throws an exception.\n        // However in all of these environments Function.prototype.bind exists\n        // and so this code will never be executed.\n        var bound = Function(\"binder\", \"return function (\" + boundArgs.join(\",\") + \"){return binder.apply(this,arguments)}\")(binder);\n\n        if (target.prototype) {\n            Empty.prototype = target.prototype;\n            bound.prototype = new Empty();\n            // Clean up dangling references.\n            Empty.prototype = null;\n        }\n\n        // TODO\n        // 18. Set the [[Extensible]] internal property of F to true.\n\n        // TODO\n        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\n        // 20. Call the [[DefineOwnProperty]] internal method of F with\n        //   arguments \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\n        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\n        //   false.\n        // 21. Call the [[DefineOwnProperty]] internal method of F with\n        //   arguments \"arguments\", PropertyDescriptor {[[Get]]: thrower,\n        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\n        //   and false.\n\n        // TODO\n        // NOTE Function objects created using Function.prototype.bind do not\n        // have a prototype property or the [[Code]], [[FormalParameters]], and\n        // [[Scope]] internal properties.\n        // XXX can't delete prototype in pure-js.\n\n        // 22. Return F.\n        return bound;\n    };\n}\n\n// _Please note: Shortcuts are defined after `Function.prototype.bind` as we\n// us it in defining shortcuts.\nvar owns = call.bind(prototypeOfObject.hasOwnProperty);\n\n// If JS engine supports accessors creating shortcuts.\nvar defineGetter;\nvar defineSetter;\nvar lookupGetter;\nvar lookupSetter;\nvar supportsAccessors;\nif ((supportsAccessors = owns(prototypeOfObject, \"__defineGetter__\"))) {\n    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\n    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\n    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\n    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\n}\n\n//\n// Array\n// =====\n//\n\n// ES5 15.4.4.12\n// http://es5.github.com/#x15.4.4.12\nvar spliceWorksWithEmptyObject = (function () {\n    var obj = {};\n    Array.prototype.splice.call(obj, 0, 0, 1);\n    return obj.length === 1;\n}());\nvar omittingSecondSpliceArgIsNoop = [1].splice(0).length === 0;\nvar spliceNoopReturnsEmptyArray = (function () {\n    var a = [1, 2];\n    var result = a.splice();\n    return a.length === 2 && isArray(result) && result.length === 0;\n}());\nif (spliceNoopReturnsEmptyArray) {\n    // Safari 5.0 bug where .split() returns undefined\n    Array.prototype.splice = function splice(start, deleteCount) {\n        if (arguments.length === 0) { return []; }\n        else { return array_splice.apply(this, arguments); }\n    };\n}\nif (!omittingSecondSpliceArgIsNoop || !spliceWorksWithEmptyObject) {\n    Array.prototype.splice = function splice(start, deleteCount) {\n        if (arguments.length === 0) { return []; }\n        var args = arguments;\n        this.length = Math.max(toInteger(this.length), 0);\n        if (arguments.length > 0 && typeof deleteCount !== 'number') {\n            args = _Array_slice_.call(arguments);\n            if (args.length < 2) { args.push(toInteger(deleteCount)); }\n            else { args[1] = toInteger(deleteCount); }\n        }\n        return array_splice.apply(this, args);\n    };\n}\n\n// ES5 15.4.4.12\n// http://es5.github.com/#x15.4.4.13\n// Return len+argCount.\n// [bugfix, ielt8]\n// IE < 8 bug: [].unshift(0) === undefined but should be \"1\"\nif ([].unshift(0) !== 1) {\n    Array.prototype.unshift = function () {\n        array_unshift.apply(this, arguments);\n        return this.length;\n    };\n}\n\n// ES5 15.4.3.2\n// http://es5.github.com/#x15.4.3.2\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\nif (!Array.isArray) {\n    Array.isArray = isArray;\n}\n\n// The IsCallable() check in the Array functions\n// has been replaced with a strict check on the\n// internal class of the object to trap cases where\n// the provided function was actually a regular\n// expression literal, which in V8 and\n// JavaScriptCore is a typeof \"function\".  Only in\n// V8 are regular expression literals permitted as\n// reduce parameters, so it is desirable in the\n// general case for the shim to match the more\n// strict and common behavior of rejecting regular\n// expressions.\n\n// ES5 15.4.4.18\n// http://es5.github.com/#x15.4.4.18\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach\n\n// Check failure of by-index access of string characters (IE < 9)\n// and failure of `0 in boxedString` (Rhino)\nvar boxedString = Object(\"a\");\nvar splitString = boxedString[0] !== \"a\" || !(0 in boxedString);\n\nvar properlyBoxesContext = function properlyBoxed(method) {\n    // Check node 0.6.21 bug where third parameter is not boxed\n    var properlyBoxesNonStrict = true;\n    var properlyBoxesStrict = true;\n    if (method) {\n        method.call('foo', function (_, __, context) {\n            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }\n        });\n\n        method.call([1], function () {\n            'use strict';\n            properlyBoxesStrict = typeof this === 'string';\n        }, 'x');\n    }\n    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\n};\n\nif (!Array.prototype.forEach || !properlyBoxesContext(Array.prototype.forEach)) {\n    Array.prototype.forEach = function forEach(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            thisp = arguments[1],\n            i = -1,\n            length = self.length >>> 0;\n\n        // If no callback function or if callback is not a callable function\n        if (!isFunction(fun)) {\n            throw new TypeError(); // TODO message\n        }\n\n        while (++i < length) {\n            if (i in self) {\n                // Invoke the callback function with call, passing arguments:\n                // context, property value, property key, thisArg object\n                // context\n                fun.call(thisp, self[i], i, object);\n            }\n        }\n    };\n}\n\n// ES5 15.4.4.19\n// http://es5.github.com/#x15.4.4.19\n// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\nif (!Array.prototype.map || !properlyBoxesContext(Array.prototype.map)) {\n    Array.prototype.map = function map(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            result = Array(length),\n            thisp = arguments[1];\n\n        // If no callback function or if callback is not a callable function\n        if (!isFunction(fun)) {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self) {\n                result[i] = fun.call(thisp, self[i], i, object);\n            }\n        }\n        return result;\n    };\n}\n\n// ES5 15.4.4.20\n// http://es5.github.com/#x15.4.4.20\n// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\nif (!Array.prototype.filter || !properlyBoxesContext(Array.prototype.filter)) {\n    Array.prototype.filter = function filter(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                    object,\n            length = self.length >>> 0,\n            result = [],\n            value,\n            thisp = arguments[1];\n\n        // If no callback function or if callback is not a callable function\n        if (!isFunction(fun)) {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self) {\n                value = self[i];\n                if (fun.call(thisp, value, i, object)) {\n                    result.push(value);\n                }\n            }\n        }\n        return result;\n    };\n}\n\n// ES5 15.4.4.16\n// http://es5.github.com/#x15.4.4.16\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every\nif (!Array.prototype.every || !properlyBoxesContext(Array.prototype.every)) {\n    Array.prototype.every = function every(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n\n        // If no callback function or if callback is not a callable function\n        if (!isFunction(fun)) {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && !fun.call(thisp, self[i], i, object)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n\n// ES5 15.4.4.17\n// http://es5.github.com/#x15.4.4.17\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some\nif (!Array.prototype.some || !properlyBoxesContext(Array.prototype.some)) {\n    Array.prototype.some = function some(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n\n        // If no callback function or if callback is not a callable function\n        if (!isFunction(fun)) {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && fun.call(thisp, self[i], i, object)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\n// ES5 15.4.4.21\n// http://es5.github.com/#x15.4.4.21\n// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce\nvar reduceCoercesToObject = false;\nif (Array.prototype.reduce) {\n    reduceCoercesToObject = typeof Array.prototype.reduce.call('es5', function (_, __, ___, list) { return list; }) === 'object';\n}\nif (!Array.prototype.reduce || !reduceCoercesToObject) {\n    Array.prototype.reduce = function reduce(fun /*, initial*/) {\n        var object = toObject(this),\n            self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0;\n\n        // If no callback function or if callback is not a callable function\n        if (!isFunction(fun)) {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        // no value to return if no initial value and an empty array\n        if (!length && arguments.length === 1) {\n            throw new TypeError(\"reduce of empty array with no initial value\");\n        }\n\n        var i = 0;\n        var result;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i++];\n                    break;\n                }\n\n                // if array contains no values, no initial value to return\n                if (++i >= length) {\n                    throw new TypeError(\"reduce of empty array with no initial value\");\n                }\n            } while (true);\n        }\n\n        for (; i < length; i++) {\n            if (i in self) {\n                result = fun.call(void 0, result, self[i], i, object);\n            }\n        }\n\n        return result;\n    };\n}\n\n// ES5 15.4.4.22\n// http://es5.github.com/#x15.4.4.22\n// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight\nvar reduceRightCoercesToObject = false;\nif (Array.prototype.reduceRight) {\n    reduceRightCoercesToObject = typeof Array.prototype.reduceRight.call('es5', function (_, __, ___, list) { return list; }) === 'object';\n}\nif (!Array.prototype.reduceRight || !reduceRightCoercesToObject) {\n    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {\n        var object = toObject(this),\n            self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0;\n\n        // If no callback function or if callback is not a callable function\n        if (!isFunction(fun)) {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        // no value to return if no initial value, empty array\n        if (!length && arguments.length === 1) {\n            throw new TypeError(\"reduceRight of empty array with no initial value\");\n        }\n\n        var result, i = length - 1;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i--];\n                    break;\n                }\n\n                // if array contains no values, no initial value to return\n                if (--i < 0) {\n                    throw new TypeError(\"reduceRight of empty array with no initial value\");\n                }\n            } while (true);\n        }\n\n        if (i < 0) {\n            return result;\n        }\n\n        do {\n            if (i in self) {\n                result = fun.call(void 0, result, self[i], i, object);\n            }\n        } while (i--);\n\n        return result;\n    };\n}\n\n// ES5 15.4.4.14\n// http://es5.github.com/#x15.4.4.14\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\nif (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) !== -1)) {\n    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {\n        var self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n\n        var i = 0;\n        if (arguments.length > 1) {\n            i = toInteger(arguments[1]);\n        }\n\n        // handle negative indices\n        i = i >= 0 ? i : Math.max(0, length + i);\n        for (; i < length; i++) {\n            if (i in self && self[i] === sought) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\n\n// ES5 15.4.4.15\n// http://es5.github.com/#x15.4.4.15\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf\nif (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) !== -1)) {\n    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {\n        var self = splitString && _toString.call(this) === \"[object String]\" ?\n                this.split(\"\") :\n                toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n        var i = length - 1;\n        if (arguments.length > 1) {\n            i = Math.min(i, toInteger(arguments[1]));\n        }\n        // handle negative indices\n        i = i >= 0 ? i : length - Math.abs(i);\n        for (; i >= 0; i--) {\n            if (i in self && sought === self[i]) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\n\n//\n// Object\n// ======\n//\n\n// ES5 15.2.3.14\n// http://es5.github.com/#x15.2.3.14\nvar keysWorksWithArguments = Object.keys && (function () {\n    return Object.keys(arguments).length === 2;\n}(1, 2));\nif (!Object.keys) {\n    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\n    var hasDontEnumBug = !({'toString': null}).propertyIsEnumerable('toString'),\n        hasProtoEnumBug = (function () {}).propertyIsEnumerable('prototype'),\n        dontEnums = [\n            \"toString\",\n            \"toLocaleString\",\n            \"valueOf\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"constructor\"\n        ],\n        dontEnumsLength = dontEnums.length;\n\n    Object.keys = function keys(object) {\n        var isFn = isFunction(object),\n            isArgs = isArguments(object),\n            isObject = object !== null && typeof object === 'object',\n            isString = isObject && _toString.call(object) === '[object String]';\n\n        if (!isObject && !isFn && !isArgs) {\n            throw new TypeError(\"Object.keys called on a non-object\");\n        }\n\n        var theKeys = [];\n        var skipProto = hasProtoEnumBug && isFn;\n        if (isString || isArgs) {\n            for (var i = 0; i < object.length; ++i) {\n                theKeys.push(String(i));\n            }\n        } else {\n            for (var name in object) {\n                if (!(skipProto && name === 'prototype') && owns(object, name)) {\n                    theKeys.push(String(name));\n                }\n            }\n        }\n\n        if (hasDontEnumBug) {\n            var ctor = object.constructor,\n                skipConstructor = ctor && ctor.prototype === object;\n            for (var j = 0; j < dontEnumsLength; j++) {\n                var dontEnum = dontEnums[j];\n                if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {\n                    theKeys.push(dontEnum);\n                }\n            }\n        }\n        return theKeys;\n    };\n} else if (!keysWorksWithArguments) {\n    // Safari 5.0 bug\n    var originalKeys = Object.keys;\n    Object.keys = function keys(object) {\n        if (isArguments(object)) {\n            return originalKeys(Array.prototype.slice.call(object));\n        } else {\n            return originalKeys(object);\n        }\n    };\n}\n\n//\n// Date\n// ====\n//\n\n// ES5 15.9.5.43\n// http://es5.github.com/#x15.9.5.43\n// This function returns a String value represent the instance in time\n// represented by this Date object. The format of the String is the Date Time\n// string format defined in 15.9.1.15. All fields are present in the String.\n// The time zone is always UTC, denoted by the suffix Z. If the time value of\n// this object is not a finite Number a RangeError exception is thrown.\nvar negativeDate = -62198755200000,\n    negativeYearString = \"-000001\";\nif (\n    !Date.prototype.toISOString ||\n    (new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1)\n) {\n    Date.prototype.toISOString = function toISOString() {\n        var result, length, value, year, month;\n        if (!isFinite(this)) {\n            throw new RangeError(\"Date.prototype.toISOString called on non-finite value.\");\n        }\n\n        year = this.getUTCFullYear();\n\n        month = this.getUTCMonth();\n        // see https://github.com/es-shims/es5-shim/issues/111\n        year += Math.floor(month / 12);\n        month = (month % 12 + 12) % 12;\n\n        // the date time string format is specified in 15.9.1.15.\n        result = [month + 1, this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];\n        year = (\n            (year < 0 ? \"-\" : (year > 9999 ? \"+\" : \"\")) +\n            (\"00000\" + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6)\n        );\n\n        length = result.length;\n        while (length--) {\n            value = result[length];\n            // pad months, days, hours, minutes, and seconds to have two\n            // digits.\n            if (value < 10) {\n                result[length] = \"0\" + value;\n            }\n        }\n        // pad milliseconds to have three digits.\n        return (\n            year + \"-\" + result.slice(0, 2).join(\"-\") +\n            \"T\" + result.slice(2).join(\":\") + \".\" +\n            (\"000\" + this.getUTCMilliseconds()).slice(-3) + \"Z\"\n        );\n    };\n}\n\n\n// ES5 15.9.5.44\n// http://es5.github.com/#x15.9.5.44\n// This function provides a String representation of a Date object for use by\n// JSON.stringify (15.12.3).\nvar dateToJSONIsSupported = false;\ntry {\n    dateToJSONIsSupported = (\n        Date.prototype.toJSON &&\n        new Date(NaN).toJSON() === null &&\n        new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&\n        Date.prototype.toJSON.call({ // generic\n            toISOString: function () {\n                return true;\n            }\n        })\n    );\n} catch (e) {\n}\nif (!dateToJSONIsSupported) {\n    Date.prototype.toJSON = function toJSON(key) {\n        // When the toJSON method is called with argument key, the following\n        // steps are taken:\n\n        // 1.  Let O be the result of calling ToObject, giving it the this\n        // value as its argument.\n        // 2. Let tv be toPrimitive(O, hint Number).\n        var o = Object(this),\n            tv = toPrimitive(o),\n            toISO;\n        // 3. If tv is a Number and is not finite, return null.\n        if (typeof tv === \"number\" && !isFinite(tv)) {\n            return null;\n        }\n        // 4. Let toISO be the result of calling the [[Get]] internal method of\n        // O with argument \"toISOString\".\n        toISO = o.toISOString;\n        // 5. If IsCallable(toISO) is false, throw a TypeError exception.\n        if (typeof toISO !== \"function\") {\n            throw new TypeError(\"toISOString property is not callable\");\n        }\n        // 6. Return the result of calling the [[Call]] internal method of\n        //  toISO with O as the this value and an empty argument list.\n        return toISO.call(o);\n\n        // NOTE 1 The argument is ignored.\n\n        // NOTE 2 The toJSON function is intentionally generic; it does not\n        // require that its this value be a Date object. Therefore, it can be\n        // transferred to other kinds of objects for use as a method. However,\n        // it does require that any such object have a toISOString method. An\n        // object is free to use the argument key to filter its\n        // stringification.\n    };\n}\n\n// ES5 15.9.4.2\n// http://es5.github.com/#x15.9.4.2\n// based on work shared by Daniel Friesen (dantman)\n// http://gist.github.com/303249\nvar supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;\nvar acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z'));\nvar doesNotParseY2KNewYear = isNaN(Date.parse(\"2000-01-01T00:00:00.000Z\"));\nif (!Date.parse || doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {\n    // XXX global assignment won't work in embeddings that use\n    // an alternate object for the context.\n    Date = (function (NativeDate) {\n\n        // Date.length === 7\n        function Date(Y, M, D, h, m, s, ms) {\n            var length = arguments.length;\n            if (this instanceof NativeDate) {\n                var date = length === 1 && String(Y) === Y ? // isString(Y)\n                    // We explicitly pass it through parse:\n                    new NativeDate(Date.parse(Y)) :\n                    // We have to manually make calls depending on argument\n                    // length here\n                    length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) :\n                    length >= 6 ? new NativeDate(Y, M, D, h, m, s) :\n                    length >= 5 ? new NativeDate(Y, M, D, h, m) :\n                    length >= 4 ? new NativeDate(Y, M, D, h) :\n                    length >= 3 ? new NativeDate(Y, M, D) :\n                    length >= 2 ? new NativeDate(Y, M) :\n                    length >= 1 ? new NativeDate(Y) :\n                                  new NativeDate();\n                // Prevent mixups with unfixed Date object\n                date.constructor = Date;\n                return date;\n            }\n            return NativeDate.apply(this, arguments);\n        }\n\n        // 15.9.1.15 Date Time String Format.\n        var isoDateExpression = new RegExp(\"^\" +\n            \"(\\\\d{4}|[\\+\\-]\\\\d{6})\" + // four-digit year capture or sign +\n                                      // 6-digit extended year\n            \"(?:-(\\\\d{2})\" + // optional month capture\n            \"(?:-(\\\\d{2})\" + // optional day capture\n            \"(?:\" + // capture hours:minutes:seconds.milliseconds\n                \"T(\\\\d{2})\" + // hours capture\n                \":(\\\\d{2})\" + // minutes capture\n                \"(?:\" + // optional :seconds.milliseconds\n                    \":(\\\\d{2})\" + // seconds capture\n                    \"(?:(\\\\.\\\\d{1,}))?\" + // milliseconds capture\n                \")?\" +\n            \"(\" + // capture UTC offset component\n                \"Z|\" + // UTC capture\n                \"(?:\" + // offset specifier +/-hours:minutes\n                    \"([-+])\" + // sign capture\n                    \"(\\\\d{2})\" + // hours offset capture\n                    \":(\\\\d{2})\" + // minutes offset capture\n                \")\" +\n            \")?)?)?)?\" +\n        \"$\");\n\n        var months = [\n            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365\n        ];\n\n        function dayFromMonth(year, month) {\n            var t = month > 1 ? 1 : 0;\n            return (\n                months[month] +\n                Math.floor((year - 1969 + t) / 4) -\n                Math.floor((year - 1901 + t) / 100) +\n                Math.floor((year - 1601 + t) / 400) +\n                365 * (year - 1970)\n            );\n        }\n\n        function toUTC(t) {\n            return Number(new NativeDate(1970, 0, 1, 0, 0, 0, t));\n        }\n\n        // Copy any custom methods a 3rd party library may have added\n        for (var key in NativeDate) {\n            Date[key] = NativeDate[key];\n        }\n\n        // Copy \"native\" methods explicitly; they may be non-enumerable\n        Date.now = NativeDate.now;\n        Date.UTC = NativeDate.UTC;\n        Date.prototype = NativeDate.prototype;\n        Date.prototype.constructor = Date;\n\n        // Upgrade Date.parse to handle simplified ISO 8601 strings\n        Date.parse = function parse(string) {\n            var match = isoDateExpression.exec(string);\n            if (match) {\n                // parse months, days, hours, minutes, seconds, and milliseconds\n                // provide default values if necessary\n                // parse the UTC offset component\n                var year = Number(match[1]),\n                    month = Number(match[2] || 1) - 1,\n                    day = Number(match[3] || 1) - 1,\n                    hour = Number(match[4] || 0),\n                    minute = Number(match[5] || 0),\n                    second = Number(match[6] || 0),\n                    millisecond = Math.floor(Number(match[7] || 0) * 1000),\n                    // When time zone is missed, local offset should be used\n                    // (ES 5.1 bug)\n                    // see https://bugs.ecmascript.org/show_bug.cgi?id=112\n                    isLocalTime = Boolean(match[4] && !match[8]),\n                    signOffset = match[9] === \"-\" ? 1 : -1,\n                    hourOffset = Number(match[10] || 0),\n                    minuteOffset = Number(match[11] || 0),\n                    result;\n                if (\n                    hour < (\n                        minute > 0 || second > 0 || millisecond > 0 ?\n                        24 : 25\n                    ) &&\n                    minute < 60 && second < 60 && millisecond < 1000 &&\n                    month > -1 && month < 12 && hourOffset < 24 &&\n                    minuteOffset < 60 && // detect invalid offsets\n                    day > -1 &&\n                    day < (\n                        dayFromMonth(year, month + 1) -\n                        dayFromMonth(year, month)\n                    )\n                ) {\n                    result = (\n                        (dayFromMonth(year, month) + day) * 24 +\n                        hour +\n                        hourOffset * signOffset\n                    ) * 60;\n                    result = (\n                        (result + minute + minuteOffset * signOffset) * 60 +\n                        second\n                    ) * 1000 + millisecond;\n                    if (isLocalTime) {\n                        result = toUTC(result);\n                    }\n                    if (-8.64e15 <= result && result <= 8.64e15) {\n                        return result;\n                    }\n                }\n                return NaN;\n            }\n            return NativeDate.parse.apply(this, arguments);\n        };\n\n        return Date;\n    })(Date);\n}\n\n// ES5 15.9.4.4\n// http://es5.github.com/#x15.9.4.4\nif (!Date.now) {\n    Date.now = function now() {\n        return new Date().getTime();\n    };\n}\n\n\n//\n// Number\n// ======\n//\n\n// ES5.1 15.7.4.5\n// http://es5.github.com/#x15.7.4.5\nif (!Number.prototype.toFixed || (0.00008).toFixed(3) !== '0.000' || (0.9).toFixed(0) === '0' || (1.255).toFixed(2) !== '1.25' || (1000000000000000128).toFixed(0) !== \"1000000000000000128\") {\n    // Hide these variables and functions\n    (function () {\n        var base, size, data, i;\n\n        base = 1e7;\n        size = 6;\n        data = [0, 0, 0, 0, 0, 0];\n\n        function multiply(n, c) {\n            var i = -1;\n            while (++i < size) {\n                c += n * data[i];\n                data[i] = c % base;\n                c = Math.floor(c / base);\n            }\n        }\n\n        function divide(n) {\n            var i = size, c = 0;\n            while (--i >= 0) {\n                c += data[i];\n                data[i] = Math.floor(c / n);\n                c = (c % n) * base;\n            }\n        }\n\n        function numToString() {\n            var i = size;\n            var s = '';\n            while (--i >= 0) {\n                if (s !== '' || i === 0 || data[i] !== 0) {\n                    var t = String(data[i]);\n                    if (s === '') {\n                        s = t;\n                    } else {\n                        s += '0000000'.slice(0, 7 - t.length) + t;\n                    }\n                }\n            }\n            return s;\n        }\n\n        function pow(x, n, acc) {\n            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));\n        }\n\n        function log(x) {\n            var n = 0;\n            while (x >= 4096) {\n                n += 12;\n                x /= 4096;\n            }\n            while (x >= 2) {\n                n += 1;\n                x /= 2;\n            }\n            return n;\n        }\n\n        Number.prototype.toFixed = function toFixed(fractionDigits) {\n            var f, x, s, m, e, z, j, k;\n\n            // Test for NaN and round fractionDigits down\n            f = Number(fractionDigits);\n            f = f !== f ? 0 : Math.floor(f);\n\n            if (f < 0 || f > 20) {\n                throw new RangeError(\"Number.toFixed called with invalid number of decimals\");\n            }\n\n            x = Number(this);\n\n            // Test for NaN\n            if (x !== x) {\n                return \"NaN\";\n            }\n\n            // If it is too big or small, return the string value of the number\n            if (x <= -1e21 || x >= 1e21) {\n                return String(x);\n            }\n\n            s = \"\";\n\n            if (x < 0) {\n                s = \"-\";\n                x = -x;\n            }\n\n            m = \"0\";\n\n            if (x > 1e-21) {\n                // 1e-21 < x < 1e21\n                // -70 < log2(x) < 70\n                e = log(x * pow(2, 69, 1)) - 69;\n                z = (e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1));\n                z *= 0x10000000000000; // Math.pow(2, 52);\n                e = 52 - e;\n\n                // -18 < e < 122\n                // x = z / 2 ^ e\n                if (e > 0) {\n                    multiply(0, z);\n                    j = f;\n\n                    while (j >= 7) {\n                        multiply(1e7, 0);\n                        j -= 7;\n                    }\n\n                    multiply(pow(10, j, 1), 0);\n                    j = e - 1;\n\n                    while (j >= 23) {\n                        divide(1 << 23);\n                        j -= 23;\n                    }\n\n                    divide(1 << j);\n                    multiply(1, 1);\n                    divide(2);\n                    m = numToString();\n                } else {\n                    multiply(0, z);\n                    multiply(1 << (-e), 0);\n                    m = numToString() + '0.00000000000000000000'.slice(2, 2 + f);\n                }\n            }\n\n            if (f > 0) {\n                k = m.length;\n\n                if (k <= f) {\n                    m = s + '0.0000000000000000000'.slice(0, f - k + 2) + m;\n                } else {\n                    m = s + m.slice(0, k - f) + '.' + m.slice(k - f);\n                }\n            } else {\n                m = s + m;\n            }\n\n            return m;\n        };\n    }());\n}\n\n\n//\n// String\n// ======\n//\n\n// ES5 15.5.4.14\n// http://es5.github.com/#x15.5.4.14\n\n// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\n// Many browsers do not split properly with regular expressions or they\n// do not perform the split correctly under obscure conditions.\n// See http://blog.stevenlevithan.com/archives/cross-browser-split\n// I've tested in many browsers and this seems to cover the deviant ones:\n//    'ab'.split(/(?:ab)*/) should be [\"\", \"\"], not [\"\"]\n//    '.'.split(/(.?)(.?)/) should be [\"\", \".\", \"\", \"\"], not [\"\", \"\"]\n//    'tesst'.split(/(s)*/) should be [\"t\", undefined, \"e\", \"s\", \"t\"], not\n//       [undefined, \"t\", undefined, \"e\", ...]\n//    ''.split(/.?/) should be [], not [\"\"]\n//    '.'.split(/()()/) should be [\".\"], not [\"\", \"\", \".\"]\n\nvar string_split = String.prototype.split;\nif (\n    'ab'.split(/(?:ab)*/).length !== 2 ||\n    '.'.split(/(.?)(.?)/).length !== 4 ||\n    'tesst'.split(/(s)*/)[1] === \"t\" ||\n    'test'.split(/(?:)/, -1).length !== 4 ||\n    ''.split(/.?/).length ||\n    '.'.split(/()()/).length > 1\n) {\n    (function () {\n        var compliantExecNpcg = /()??/.exec(\"\")[1] === void 0; // NPCG: nonparticipating capturing group\n\n        String.prototype.split = function (separator, limit) {\n            var string = this;\n            if (separator === void 0 && limit === 0) {\n                return [];\n            }\n\n            // If `separator` is not a regex, use native split\n            if (_toString.call(separator) !== \"[object RegExp]\") {\n                return string_split.call(this, separator, limit);\n            }\n\n            var output = [],\n                flags = (separator.ignoreCase ? \"i\" : \"\") +\n                        (separator.multiline  ? \"m\" : \"\") +\n                        (separator.extended   ? \"x\" : \"\") + // Proposed for ES6\n                        (separator.sticky     ? \"y\" : \"\"), // Firefox 3+\n                lastLastIndex = 0,\n                // Make `global` and avoid `lastIndex` issues by working with a copy\n                separator2, match, lastIndex, lastLength;\n            separator = new RegExp(separator.source, flags + \"g\");\n            string += \"\"; // Type-convert\n            if (!compliantExecNpcg) {\n                // Doesn't need flags gy, but they don't hurt\n                separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n            }\n            /* Values for `limit`, per the spec:\n             * If undefined: 4294967295 // Math.pow(2, 32) - 1\n             * If 0, Infinity, or NaN: 0\n             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n             * If other: Type-convert, then use the above rules\n             */\n            limit = limit === void 0 ?\n                -1 >>> 0 : // Math.pow(2, 32) - 1\n                ToUint32(limit);\n            while (match = separator.exec(string)) {\n                // `separator.lastIndex` is not reliable cross-browser\n                lastIndex = match.index + match[0].length;\n                if (lastIndex > lastLastIndex) {\n                    output.push(string.slice(lastLastIndex, match.index));\n                    // Fix browsers whose `exec` methods don't consistently return `undefined` for\n                    // nonparticipating capturing groups\n                    if (!compliantExecNpcg && match.length > 1) {\n                        match[0].replace(separator2, function () {\n                            for (var i = 1; i < arguments.length - 2; i++) {\n                                if (arguments[i] === void 0) {\n                                    match[i] = void 0;\n                                }\n                            }\n                        });\n                    }\n                    if (match.length > 1 && match.index < string.length) {\n                        Array.prototype.push.apply(output, match.slice(1));\n                    }\n                    lastLength = match[0].length;\n                    lastLastIndex = lastIndex;\n                    if (output.length >= limit) {\n                        break;\n                    }\n                }\n                if (separator.lastIndex === match.index) {\n                    separator.lastIndex++; // Avoid an infinite loop\n                }\n            }\n            if (lastLastIndex === string.length) {\n                if (lastLength || !separator.test(\"\")) {\n                    output.push(\"\");\n                }\n            } else {\n                output.push(string.slice(lastLastIndex));\n            }\n            return output.length > limit ? output.slice(0, limit) : output;\n        };\n    }());\n\n// [bugfix, chrome]\n// If separator is undefined, then the result array contains just one String,\n// which is the this value (converted to a String). If limit is not undefined,\n// then the output array is truncated so that it contains no more than limit\n// elements.\n// \"0\".split(undefined, 0) -> []\n} else if (\"0\".split(void 0, 0).length) {\n    String.prototype.split = function split(separator, limit) {\n        if (separator === void 0 && limit === 0) { return []; }\n        return string_split.call(this, separator, limit);\n    };\n}\n\nvar str_replace = String.prototype.replace;\nvar replaceReportsGroupsCorrectly = (function () {\n    var groups = [];\n    'x'.replace(/x(.)?/g, function (match, group) {\n        groups.push(group);\n    });\n    return groups.length === 1 && typeof groups[0] === 'undefined';\n}());\n\nif (!replaceReportsGroupsCorrectly) {\n    String.prototype.replace = function replace(searchValue, replaceValue) {\n        var isFn = isFunction(replaceValue);\n        var hasCapturingGroups = isRegex(searchValue) && (/\\)[*?]/).test(searchValue.source);\n        if (!isFn || !hasCapturingGroups) {\n            return str_replace.call(this, searchValue, replaceValue);\n        } else {\n            var wrappedReplaceValue = function (match) {\n                var length = arguments.length;\n                var originalLastIndex = searchValue.lastIndex;\n                searchValue.lastIndex = 0;\n                var args = searchValue.exec(match);\n                searchValue.lastIndex = originalLastIndex;\n                args.push(arguments[length - 2], arguments[length - 1]);\n                return replaceValue.apply(this, args);\n            };\n            return str_replace.call(this, searchValue, wrappedReplaceValue);\n        }\n    };\n}\n\n// ECMA-262, 3rd B.2.3\n// Not an ECMAScript standard, although ECMAScript 3rd Edition has a\n// non-normative section suggesting uniform semantics and it should be\n// normalized across all browsers\n// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\nif (\"\".substr && \"0b\".substr(-1) !== \"b\") {\n    var string_substr = String.prototype.substr;\n    /**\n     *  Get the substring of a string\n     *  @param  {integer}  start   where to start the substring\n     *  @param  {integer}  length  how many characters to return\n     *  @return {string}\n     */\n    String.prototype.substr = function substr(start, length) {\n        return string_substr.call(\n            this,\n            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,\n            length\n        );\n    };\n}\n\n// ES5 15.5.4.20\n// whitespace from: http://es5.github.io/#x15.5.4.20\nvar ws = \"\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\" +\n    \"\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\" +\n    \"\\u2029\\uFEFF\";\nvar zeroWidth = '\\u200b';\nif (!String.prototype.trim || ws.trim() || !zeroWidth.trim()) {\n    // http://blog.stevenlevithan.com/archives/faster-trim-javascript\n    // http://perfectionkills.com/whitespace-deviations/\n    ws = \"[\" + ws + \"]\";\n    var trimBeginRegexp = new RegExp(\"^\" + ws + ws + \"*\"),\n        trimEndRegexp = new RegExp(ws + ws + \"*$\");\n    String.prototype.trim = function trim() {\n        if (this === void 0 || this === null) {\n            throw new TypeError(\"can't convert \" + this + \" to object\");\n        }\n        return String(this)\n            .replace(trimBeginRegexp, \"\")\n            .replace(trimEndRegexp, \"\");\n    };\n}\n\n// ES-5 15.1.2.2\nif (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {\n    parseInt = (function (origParseInt) {\n        var hexRegex = /^0[xX]/;\n        return function parseIntES5(str, radix) {\n            str = String(str).trim();\n            if (!Number(radix)) {\n                radix = hexRegex.test(str) ? 16 : 10;\n            }\n            return origParseInt(str, radix);\n        };\n    }(parseInt));\n}\n\n//\n// Util\n// ======\n//\n\n// ES5 9.4\n// http://es5.github.com/#x9.4\n// http://jsperf.com/to-integer\n\nfunction toInteger(n) {\n    n = +n;\n    if (n !== n) { // isNaN\n        n = 0;\n    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n    }\n    return n;\n}\n\nfunction isPrimitive(input) {\n    var type = typeof input;\n    return (\n        input === null ||\n        type === \"undefined\" ||\n        type === \"boolean\" ||\n        type === \"number\" ||\n        type === \"string\"\n    );\n}\n\nfunction toPrimitive(input) {\n    var val, valueOf, toStr;\n    if (isPrimitive(input)) {\n        return input;\n    }\n    valueOf = input.valueOf;\n    if (isFunction(valueOf)) {\n        val = valueOf.call(input);\n        if (isPrimitive(val)) {\n            return val;\n        }\n    }\n    toStr = input.toString;\n    if (isFunction(toStr)) {\n        val = toStr.call(input);\n        if (isPrimitive(val)) {\n            return val;\n        }\n    }\n    throw new TypeError();\n}\n\n// ES5 9.9\n// http://es5.github.com/#x9.9\nvar toObject = function (o) {\n    if (o == null) { // this matches both null and undefined\n        throw new TypeError(\"can't convert \" + o + \" to object\");\n    }\n    return Object(o);\n};\n\nvar ToUint32 = function ToUint32(x) {\n    return x >>> 0;\n};\n\n}));\n",
  "esprima.js": "/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\ncreateLocationMarker: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseUnaryExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 32) ||  // space\n            (ch === 9) ||      // tab\n            (ch === 0xB) ||\n            (ch === 0xC) ||\n            (ch === 0xA0) ||\n            (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n    }\n\n    function skipSingleLineComment() {\n        var start, loc, ch, comment;\n\n        start = index - 2;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - 2\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + 2, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + 2, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else if (ch === 42) {\n                // Block comment ends with '*/' (char #42, char #47).\n                if (source.charCodeAt(index + 1) === 47) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function skipComment() {\n        var ch;\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else if (ch === 47) { // 47 is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 47) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment();\n                } else if (ch === 42) {  // 42 is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (char #92, char #117) denotes an escaped character.\n        if (ch === 92) {\n            if (source.charCodeAt(index) !== 117) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (char #92, char #117) denotes an escaped character.\n            if (ch === 92) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 117) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 92) {\n                // Blackslash (char #92) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (char #92) starts an escaped character.\n        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n\n        // Check for most common single-character punctuators.\n        case 46:   // . dot\n        case 40:   // ( open bracket\n        case 41:   // ) close bracket\n        case 59:   // ; semicolon\n        case 44:   // , comma\n        case 123:  // { open curly brace\n        case 125:  // } close curly brace\n        case 91:   // [\n        case 93:   // ]\n        case 58:   // :\n        case 63:   // ?\n        case 126:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 40) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 123) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (char #61) marks an assignment or comparison operator.\n            if (code2 === 61) {\n                switch (code) {\n                case 37:  // %\n                case 38:  // &\n                case 42:  // *:\n                case 43:  // +\n                case 45:  // -\n                case 47:  // /\n                case 60:  // <\n                case 62:  // >\n                case 94:  // ^\n                case 124: // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n\n                case 33: // !\n                case 61: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 61) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n\n        // Peek more characters.\n\n        ch2 = source[index + 1];\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanOctalLiteral(start) {\n        var number = '0' + source[index++];\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: true,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (isOctalDigit(ch)) {\n                    return scanOctalLiteral(start);\n                }\n\n                // decimal number starts with '0' such as '09' is illegal.\n                if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n\n        lookahead = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '\\\\') {\n                    ch = source[index++];\n                    // ECMA-262 7.8.5\n                    if (isLineTerminator(ch.charCodeAt(0))) {\n                        throwError({}, Messages.UnterminatedRegExp);\n                    }\n                    str += ch;\n                } else if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        peek();\n\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n        return {\n            literal: str,\n            value: value,\n            range: [start, index]\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        // Very common: ( and ) and ;\n        if (ch === 40 || ch === 41 || ch === 58) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (#39) or double quote (#34).\n        if (ch === 39 || ch === 34) {\n            return scanStringLiteral();\n        }\n\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Dot (.) char #46 can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 46) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) char #47 can also start a regex.\n        if (extra.tokenize && ch === 47) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value;\n\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = source.slice(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        markStart: function () {\n            if (extra.loc) {\n                state.markerStack.push(index - lineStart);\n                state.markerStack.push(lineNumber);\n            }\n            if (extra.range) {\n                state.markerStack.push(index);\n            }\n        },\n\n        markEnd: function (node) {\n            if (extra.range) {\n                node.range = [state.markerStack.pop(), index];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: state.markerStack.pop(),\n                        column: state.markerStack.pop()\n                    },\n                    end: {\n                        line: lineNumber,\n                        column: index - lineStart\n                    }\n                };\n                this.postProcess(node);\n            }\n            return node;\n        },\n\n        markEndIf: function (node) {\n            if (node.range || node.loc) {\n                if (extra.loc) {\n                    state.markerStack.pop();\n                    state.markerStack.pop();\n                }\n                if (extra.range) {\n                    state.markerStack.pop();\n                }\n            } else {\n                this.markEnd(node);\n            }\n            return node;\n        },\n\n        postProcess: function (node) {\n            if (extra.source) {\n                node.loc.source = extra.source;\n            }\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n\n        createDebuggerStatement: function () {\n            return {\n                type: Syntax.DebuggerStatement\n            };\n        },\n\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n\n        createEmptyStatement: function () {\n            return {\n                type: Syntax.EmptyStatement\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n\n        createFunctionDeclaration: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createFunctionExpression: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name\n            };\n        },\n\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n\n        createLiteral: function (token) {\n            return {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n\n        createProperty: function (kind, key, value) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind\n            };\n        },\n\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        },\n\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        }\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    assert(index < args.length, 'Message reference must be in range');\n                    return args[index];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var line;\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [];\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        expect(']');\n\n        return delegate.createArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body;\n\n        previousStrict = strict;\n        skipComment();\n        delegate.markStart();\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body));\n    }\n\n    function parseObjectPropertyKey() {\n        var token;\n\n        skipComment();\n        delegate.markStart();\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return delegate.markEnd(delegate.createLiteral(token));\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value));\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param;\n\n        token = lookahead;\n        skipComment();\n        delegate.markStart();\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction([]);\n                return delegate.markEnd(delegate.createProperty('get', key, value));\n            }\n            if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    value = parsePropertyFunction([]);\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    value = parsePropertyFunction(param, token);\n                }\n                return delegate.markEnd(delegate.createProperty('set', key, value));\n            }\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', id, value));\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', key, value));\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return delegate.createObjectExpression(properties);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr;\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        type = lookahead.type;\n        delegate.markStart();\n\n        if (type === Token.Identifier) {\n            expr =  delegate.createIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = delegate.createLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                expr = delegate.createThisExpression();\n            } else if (matchKeyword('function')) {\n                expr = parseFunctionExpression();\n            }\n        } else if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = delegate.createLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            expr = delegate.createLiteral(token);\n        } else if (match('[')) {\n            expr = parseArrayInitialiser();\n        } else if (match('{')) {\n            expr = parseObjectInitialiser();\n        } else if (match('/') || match('/=')) {\n            if (typeof extra.tokens !== 'undefined') {\n                expr = delegate.createLiteral(collectRegex());\n            } else {\n                expr = delegate.createLiteral(scanRegExp());\n            }\n        }\n\n        if (expr) {\n            return delegate.markEnd(expr);\n        }\n\n        throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token;\n\n        delegate.markStart();\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value));\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args;\n\n        delegate.markStart();\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return delegate.markEnd(delegate.createNewExpression(callee, args));\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var marker, expr, args, property;\n\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = delegate.createCallExpression(expr, args);\n            } else if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            }\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var marker, expr, property;\n\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            }\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token;\n\n        delegate.markStart();\n        expr = parseLeftHandSideExpressionAllowCall();\n\n        if (lookahead.type === Token.Punctuator) {\n            if ((match('++') || match('--')) && !peekLineTerminator()) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    throwErrorTolerant({}, Messages.StrictLHSPostfix);\n                }\n\n                if (!isLeftHandSide(expr)) {\n                    throwError({}, Messages.InvalidLHSInAssignment);\n                }\n\n                token = lex();\n                expr = delegate.createPostfixExpression(token.value, expr);\n            }\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        delegate.markStart();\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = delegate.createUnaryExpression(token.value, expr);\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, previousAllowIn, stack, right, operator, left, i;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        marker = createLocationMarker();\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, previousAllowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, createLocationMarker()];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers.pop();\n                if (marker) {\n                    marker.end();\n                    marker.apply(expr);\n                }\n                stack.push(expr);\n                markers.push(marker);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(createLocationMarker());\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        state.allowIn = previousAllowIn;\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate;\n\n        delegate.markStart();\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = delegate.markEnd(delegate.createConditionalExpression(expr, consequent, alternate));\n        } else {\n            delegate.markEnd({});\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, left, right, node;\n\n        token = lookahead;\n        delegate.markStart();\n        node = left = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(left)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            token = lex();\n            right = parseAssignmentExpression();\n            node = delegate.createAssignmentExpression(token.value, left, right);\n        }\n\n        return delegate.markEndIf(node);\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr;\n\n        delegate.markStart();\n        expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = delegate.createSequenceExpression([ expr ]);\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block;\n\n        skipComment();\n        delegate.markStart();\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return delegate.markEnd(delegate.createBlockStatement(block));\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token;\n\n        skipComment();\n        delegate.markStart();\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value));\n    }\n\n    function parseVariableDeclaration(kind) {\n        var init = null, id;\n\n        skipComment();\n        delegate.markStart();\n        id = parseVariableIdentifier();\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            throwErrorTolerant({}, Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return delegate.markEnd(delegate.createVariableDeclarator(id, init));\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return delegate.createVariableDeclaration(declarations, 'var');\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations;\n\n        skipComment();\n        delegate.markStart();\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind));\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n        return delegate.createEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return delegate.createExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return delegate.createIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return delegate.createDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return delegate.createWhileStatement(test, body);\n    }\n\n    function parseForVariableDeclaration() {\n        var token, declarations;\n\n        delegate.markStart();\n        token = lex();\n        declarations = parseVariableDeclarationList();\n\n        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value));\n    }\n\n    function parseForStatement() {\n        var init, test, update, left, right, body, oldInIteration;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        throwError({}, Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                delegate.createForStatement(init, test, update, body) :\n                delegate.createForInStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return delegate.createContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return delegate.createBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 32) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return delegate.createReturnStatement(argument);\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return delegate.createReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return delegate.createReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return delegate.createWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            statement;\n\n        skipComment();\n        delegate.markStart();\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            consequent.push(statement);\n        }\n\n        return delegate.markEnd(delegate.createSwitchCase(test, consequent));\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        if (match('}')) {\n            lex();\n            return delegate.createSwitchStatement(discriminant);\n        }\n\n        cases = [];\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return delegate.createSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return delegate.createThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body;\n\n        skipComment();\n        delegate.markStart();\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return delegate.markEnd(delegate.createCatchClause(param, body));\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return delegate.createTryStatement(block, [], handlers, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return delegate.createDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key;\n\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n\n        skipComment();\n        delegate.markStart();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return delegate.markEnd(parseEmptyStatement());\n            case '{':\n                return delegate.markEnd(parseBlock());\n            case '(':\n                return delegate.markEnd(parseExpressionStatement());\n            default:\n                break;\n            }\n        }\n\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return delegate.markEnd(parseBreakStatement());\n            case 'continue':\n                return delegate.markEnd(parseContinueStatement());\n            case 'debugger':\n                return delegate.markEnd(parseDebuggerStatement());\n            case 'do':\n                return delegate.markEnd(parseDoWhileStatement());\n            case 'for':\n                return delegate.markEnd(parseForStatement());\n            case 'function':\n                return delegate.markEnd(parseFunctionDeclaration());\n            case 'if':\n                return delegate.markEnd(parseIfStatement());\n            case 'return':\n                return delegate.markEnd(parseReturnStatement());\n            case 'switch':\n                return delegate.markEnd(parseSwitchStatement());\n            case 'throw':\n                return delegate.markEnd(parseThrowStatement());\n            case 'try':\n                return delegate.markEnd(parseTryStatement());\n            case 'var':\n                return delegate.markEnd(parseVariableStatement());\n            case 'while':\n                return delegate.markEnd(parseWhileStatement());\n            case 'with':\n                return delegate.markEnd(parseWithStatement());\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody));\n        }\n\n        consumeSemicolon();\n\n        return delegate.markEnd(delegate.createExpressionStatement(expr));\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;\n\n        skipComment();\n        delegate.markStart();\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return delegate.markEnd(delegate.createBlockStatement(sourceElements));\n    }\n\n    function parseParams(firstRestricted) {\n        var param, params = [], token, stricted, paramSet, key, message;\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead;\n                param = parseVariableIdentifier();\n                key = '$' + token.value;\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[key] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return {\n            params: params,\n            stricted: stricted,\n            firstRestricted: firstRestricted,\n            message: message\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;\n\n        skipComment();\n        delegate.markStart();\n\n        expectKeyword('function');\n        token = lookahead;\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body));\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict;\n\n        delegate.markStart();\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body));\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body;\n\n        skipComment();\n        delegate.markStart();\n        strict = false;\n        peek();\n        body = parseSourceElements();\n        return delegate.markEnd(delegate.createProgram(body));\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function LocationMarker() {\n        this.marker = [index, lineNumber, index - lineStart, 0, 0, 0];\n    }\n\n    LocationMarker.prototype = {\n        constructor: LocationMarker,\n\n        end: function () {\n            this.marker[3] = index;\n            this.marker[4] = lineNumber;\n            this.marker[5] = index - lineStart;\n        },\n\n        apply: function (node) {\n            if (extra.range) {\n                node.range = [this.marker[0], this.marker[3]];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: this.marker[1],\n                        column: this.marker[2]\n                    },\n                    end: {\n                        line: this.marker[4],\n                        column: this.marker[5]\n                    }\n                };\n            }\n            node = delegate.postProcess(node);\n        }\n    };\n\n    function createLocationMarker() {\n        if (!extra.loc && !extra.range) {\n            return null;\n        }\n\n        skipComment();\n\n        return new LocationMarker();\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            markerStack: []\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with package.json and component.json.\n    exports.version = '1.1.0-dev';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */",
  "jshint-worker.js": "var init = false;\nvar jshint;\n\nself.onmessage = function(event) {\n    var data = JSON.parse(event.data);\n    \n    // We don't import JSHint on load as we need to know which language\n    // the user is visiting the site in. If there is no language then\n    // we just use the normal file.\n    if (!init) {\n        init = true;\n\n        if (data.deps) {\n            var deps = data.deps;\n\n            eval(deps[\"es5-shim.js\"]);\n            eval(deps[\"jshint.js\"]);\n            eval(deps[\"underscore.js\"]);\n\n            self.JSHINT = JSHINT;    // store it in a global so we can use it next time\n        }\n    }\n\n    // Evaluate the code using JSHint\n    JSHINT(data.code);\n    \n    var hintData = JSHINT.data();\n    var globals = hintData.globals || [];\n\n    // Return the JSHint results to the main code\n    self.postMessage({\n         type: \"jshint\",\n         message: {\n             hintData: { globals: globals },\n             hintErrors: JSHINT.errors\n        }\n    });\n};\n\n",
  "jshint.js": "// 2.1.11\nvar JSHINT;\nif (typeof window === 'undefined') window = {};\n(function () {\nvar require;\nrequire=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require==\"function\"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error(\"Cannot find module '\"+n+\"'\")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require==\"function\"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n},{}],2:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})(require(\"__browserify_process\"))\n},{\"__browserify_process\":1}],3:[function(require,module,exports){\n(function(){// jshint -W001\n\n\"use strict\";\n\n// Identifiers provided by the ECMAScript standard.\n\nexports.reservedVars = {\n  arguments : false,\n  NaN       : false\n};\n\nexports.ecmaIdentifiers = {\n  Array              : false,\n  Boolean            : false,\n  Date               : false,\n  decodeURI          : false,\n  decodeURIComponent : false,\n  encodeURI          : false,\n  encodeURIComponent : false,\n  Error              : false,\n  \"eval\"             : false,\n  EvalError          : false,\n  Function           : false,\n  hasOwnProperty     : false,\n  isFinite           : false,\n  isNaN              : false,\n  JSON               : false,\n  Math               : false,\n  Map                : false,\n  Number             : false,\n  Object             : false,\n  parseInt           : false,\n  parseFloat         : false,\n  RangeError         : false,\n  ReferenceError     : false,\n  RegExp             : false,\n  Set                : false,\n  String             : false,\n  SyntaxError        : false,\n  TypeError          : false,\n  URIError           : false,\n  WeakMap            : false\n};\n\n// Global variables commonly provided by a web browser environment.\n\nexports.browser = {\n  Audio                : false,\n  Blob                 : false,\n  addEventListener     : false,\n  applicationCache     : false,\n  atob                 : false,\n  blur                 : false,\n  btoa                 : false,\n  clearInterval        : false,\n  clearTimeout         : false,\n  close                : false,\n  closed               : false,\n  CustomEvent          : false,\n  DOMParser            : false,\n  defaultStatus        : false,\n  document             : false,\n  Element              : false,\n  ElementTimeControl   : false,\n  event                : false,\n  FileReader           : false,\n  FormData             : false,\n  focus                : false,\n  frames               : false,\n  getComputedStyle     : false,\n  HTMLElement          : false,\n  HTMLAnchorElement    : false,\n  HTMLBaseElement      : false,\n  HTMLBlockquoteElement: false,\n  HTMLBodyElement      : false,\n  HTMLBRElement        : false,\n  HTMLButtonElement    : false,\n  HTMLCanvasElement    : false,\n  HTMLDirectoryElement : false,\n  HTMLDivElement       : false,\n  HTMLDListElement     : false,\n  HTMLFieldSetElement  : false,\n  HTMLFontElement      : false,\n  HTMLFormElement      : false,\n  HTMLFrameElement     : false,\n  HTMLFrameSetElement  : false,\n  HTMLHeadElement      : false,\n  HTMLHeadingElement   : false,\n  HTMLHRElement        : false,\n  HTMLHtmlElement      : false,\n  HTMLIFrameElement    : false,\n  HTMLImageElement     : false,\n  HTMLInputElement     : false,\n  HTMLIsIndexElement   : false,\n  HTMLLabelElement     : false,\n  HTMLLayerElement     : false,\n  HTMLLegendElement    : false,\n  HTMLLIElement        : false,\n  HTMLLinkElement      : false,\n  HTMLMapElement       : false,\n  HTMLMenuElement      : false,\n  HTMLMetaElement      : false,\n  HTMLModElement       : false,\n  HTMLObjectElement    : false,\n  HTMLOListElement     : false,\n  HTMLOptGroupElement  : false,\n  HTMLOptionElement    : false,\n  HTMLParagraphElement : false,\n  HTMLParamElement     : false,\n  HTMLPreElement       : false,\n  HTMLQuoteElement     : false,\n  HTMLScriptElement    : false,\n  HTMLSelectElement    : false,\n  HTMLStyleElement     : false,\n  HTMLTableCaptionElement: false,\n  HTMLTableCellElement : false,\n  HTMLTableColElement  : false,\n  HTMLTableElement     : false,\n  HTMLTableRowElement  : false,\n  HTMLTableSectionElement: false,\n  HTMLTextAreaElement  : false,\n  HTMLTitleElement     : false,\n  HTMLUListElement     : false,\n  HTMLVideoElement     : false,\n  history              : false,\n  Image                : false,\n  length               : false,\n  localStorage         : false,\n  location             : false,\n  MessageChannel       : false,\n  MessageEvent         : false,\n  MessagePort          : false,\n  MouseEvent           : false,\n  moveBy               : false,\n  moveTo               : false,\n  MutationObserver     : false,\n  name                 : false,\n  Node                 : false,\n  NodeFilter           : false,\n  navigator            : false,\n  onbeforeunload       : true,\n  onblur               : true,\n  onerror              : true,\n  onfocus              : true,\n  onload               : true,\n  onresize             : true,\n  onunload             : true,\n  open                 : false,\n  openDatabase         : false,\n  opener               : false,\n  Option               : false,\n  parent               : false,\n  print                : false,\n  removeEventListener  : false,\n  resizeBy             : false,\n  resizeTo             : false,\n  screen               : false,\n  scroll               : false,\n  scrollBy             : false,\n  scrollTo             : false,\n  sessionStorage       : false,\n  setInterval          : false,\n  setTimeout           : false,\n  SharedWorker         : false,\n  status               : false,\n  SVGAElement          : false,\n  SVGAltGlyphDefElement: false,\n  SVGAltGlyphElement   : false,\n  SVGAltGlyphItemElement: false,\n  SVGAngle             : false,\n  SVGAnimateColorElement: false,\n  SVGAnimateElement    : false,\n  SVGAnimateMotionElement: false,\n  SVGAnimateTransformElement: false,\n  SVGAnimatedAngle     : false,\n  SVGAnimatedBoolean   : false,\n  SVGAnimatedEnumeration: false,\n  SVGAnimatedInteger   : false,\n  SVGAnimatedLength    : false,\n  SVGAnimatedLengthList: false,\n  SVGAnimatedNumber    : false,\n  SVGAnimatedNumberList: false,\n  SVGAnimatedPathData  : false,\n  SVGAnimatedPoints    : false,\n  SVGAnimatedPreserveAspectRatio: false,\n  SVGAnimatedRect      : false,\n  SVGAnimatedString    : false,\n  SVGAnimatedTransformList: false,\n  SVGAnimationElement  : false,\n  SVGCSSRule           : false,\n  SVGCircleElement     : false,\n  SVGClipPathElement   : false,\n  SVGColor             : false,\n  SVGColorProfileElement: false,\n  SVGColorProfileRule  : false,\n  SVGComponentTransferFunctionElement: false,\n  SVGCursorElement     : false,\n  SVGDefsElement       : false,\n  SVGDescElement       : false,\n  SVGDocument          : false,\n  SVGElement           : false,\n  SVGElementInstance   : false,\n  SVGElementInstanceList: false,\n  SVGEllipseElement    : false,\n  SVGExternalResourcesRequired: false,\n  SVGFEBlendElement    : false,\n  SVGFEColorMatrixElement: false,\n  SVGFEComponentTransferElement: false,\n  SVGFECompositeElement: false,\n  SVGFEConvolveMatrixElement: false,\n  SVGFEDiffuseLightingElement: false,\n  SVGFEDisplacementMapElement: false,\n  SVGFEDistantLightElement: false,\n  SVGFEFloodElement    : false,\n  SVGFEFuncAElement    : false,\n  SVGFEFuncBElement    : false,\n  SVGFEFuncGElement    : false,\n  SVGFEFuncRElement    : false,\n  SVGFEGaussianBlurElement: false,\n  SVGFEImageElement    : false,\n  SVGFEMergeElement    : false,\n  SVGFEMergeNodeElement: false,\n  SVGFEMorphologyElement: false,\n  SVGFEOffsetElement   : false,\n  SVGFEPointLightElement: false,\n  SVGFESpecularLightingElement: false,\n  SVGFESpotLightElement: false,\n  SVGFETileElement     : false,\n  SVGFETurbulenceElement: false,\n  SVGFilterElement     : false,\n  SVGFilterPrimitiveStandardAttributes: false,\n  SVGFitToViewBox      : false,\n  SVGFontElement       : false,\n  SVGFontFaceElement   : false,\n  SVGFontFaceFormatElement: false,\n  SVGFontFaceNameElement: false,\n  SVGFontFaceSrcElement: false,\n  SVGFontFaceUriElement: false,\n  SVGForeignObjectElement: false,\n  SVGGElement          : false,\n  SVGGlyphElement      : false,\n  SVGGlyphRefElement   : false,\n  SVGGradientElement   : false,\n  SVGHKernElement      : false,\n  SVGICCColor          : false,\n  SVGImageElement      : false,\n  SVGLangSpace         : false,\n  SVGLength            : false,\n  SVGLengthList        : false,\n  SVGLineElement       : false,\n  SVGLinearGradientElement: false,\n  SVGLocatable         : false,\n  SVGMPathElement      : false,\n  SVGMarkerElement     : false,\n  SVGMaskElement       : false,\n  SVGMatrix            : false,\n  SVGMetadataElement   : false,\n  SVGMissingGlyphElement: false,\n  SVGNumber            : false,\n  SVGNumberList        : false,\n  SVGPaint             : false,\n  SVGPathElement       : false,\n  SVGPathSeg           : false,\n  SVGPathSegArcAbs     : false,\n  SVGPathSegArcRel     : false,\n  SVGPathSegClosePath  : false,\n  SVGPathSegCurvetoCubicAbs: false,\n  SVGPathSegCurvetoCubicRel: false,\n  SVGPathSegCurvetoCubicSmoothAbs: false,\n  SVGPathSegCurvetoCubicSmoothRel: false,\n  SVGPathSegCurvetoQuadraticAbs: false,\n  SVGPathSegCurvetoQuadraticRel: false,\n  SVGPathSegCurvetoQuadraticSmoothAbs: false,\n  SVGPathSegCurvetoQuadraticSmoothRel: false,\n  SVGPathSegLinetoAbs  : false,\n  SVGPathSegLinetoHorizontalAbs: false,\n  SVGPathSegLinetoHorizontalRel: false,\n  SVGPathSegLinetoRel  : false,\n  SVGPathSegLinetoVerticalAbs: false,\n  SVGPathSegLinetoVerticalRel: false,\n  SVGPathSegList       : false,\n  SVGPathSegMovetoAbs  : false,\n  SVGPathSegMovetoRel  : false,\n  SVGPatternElement    : false,\n  SVGPoint             : false,\n  SVGPointList         : false,\n  SVGPolygonElement    : false,\n  SVGPolylineElement   : false,\n  SVGPreserveAspectRatio: false,\n  SVGRadialGradientElement: false,\n  SVGRect              : false,\n  SVGRectElement       : false,\n  SVGRenderingIntent   : false,\n  SVGSVGElement        : false,\n  SVGScriptElement     : false,\n  SVGSetElement        : false,\n  SVGStopElement       : false,\n  SVGStringList        : false,\n  SVGStylable          : false,\n  SVGStyleElement      : false,\n  SVGSwitchElement     : false,\n  SVGSymbolElement     : false,\n  SVGTRefElement       : false,\n  SVGTSpanElement      : false,\n  SVGTests             : false,\n  SVGTextContentElement: false,\n  SVGTextElement       : false,\n  SVGTextPathElement   : false,\n  SVGTextPositioningElement: false,\n  SVGTitleElement      : false,\n  SVGTransform         : false,\n  SVGTransformList     : false,\n  SVGTransformable     : false,\n  SVGURIReference      : false,\n  SVGUnitTypes         : false,\n  SVGUseElement        : false,\n  SVGVKernElement      : false,\n  SVGViewElement       : false,\n  SVGViewSpec          : false,\n  SVGZoomAndPan        : false,\n  TimeEvent            : false,\n  top                  : false,\n  WebSocket            : false,\n  window               : false,\n  Worker               : false,\n  XMLHttpRequest       : false,\n  XMLSerializer        : false,\n  XPathEvaluator       : false,\n  XPathException       : false,\n  XPathExpression      : false,\n  XPathNamespace       : false,\n  XPathNSResolver      : false,\n  XPathResult          : false\n};\n\nexports.devel = {\n  alert  : false,\n  confirm: false,\n  console: false,\n  Debug  : false,\n  opera  : false,\n  prompt : false\n};\n\nexports.worker = {\n  importScripts: true,\n  postMessage  : true,\n  self         : true\n};\n\n// Widely adopted global names that are not part of ECMAScript standard\nexports.nonstandard = {\n  escape  : false,\n  unescape: false\n};\n\n// Globals provided by popular JavaScript environments.\n\nexports.couch = {\n  \"require\" : false,\n  respond   : false,\n  getRow    : false,\n  emit      : false,\n  send      : false,\n  start     : false,\n  sum       : false,\n  log       : false,\n  exports   : false,\n  module    : false,\n  provides  : false\n};\n\nexports.node = {\n  __filename    : false,\n  __dirname     : false,\n  Buffer        : false,\n  console       : false,\n  exports       : true,  // In Node it is ok to exports = module.exports = foo();\n  GLOBAL        : false,\n  global        : false,\n  module        : false,\n  process       : false,\n  require       : false,\n  setTimeout    : false,\n  clearTimeout  : false,\n  setInterval   : false,\n  clearInterval : false,\n  setImmediate  : false, // v0.9.1+\n  clearImmediate: false  // v0.9.1+\n};\n\nexports.phantom = {\n  phantom      : true,\n  require      : true,\n  WebPage      : true,\n  console      : true, // in examples, but undocumented\n  exports      : true  // v1.7+\n};\n\nexports.rhino = {\n  defineClass  : false,\n  deserialize  : false,\n  gc           : false,\n  help         : false,\n  importPackage: false,\n  \"java\"       : false,\n  load         : false,\n  loadClass    : false,\n  print        : false,\n  quit         : false,\n  readFile     : false,\n  readUrl      : false,\n  runCommand   : false,\n  seal         : false,\n  serialize    : false,\n  spawn        : false,\n  sync         : false,\n  toint32      : false,\n  version      : false\n};\n\nexports.shelljs = {\n  target       : false,\n  echo         : false,\n  exit         : false,\n  cd           : false,\n  pwd          : false,\n  ls           : false,\n  find         : false,\n  cp           : false,\n  rm           : false,\n  mv           : false,\n  mkdir        : false,\n  test         : false,\n  cat          : false,\n  sed          : false,\n  grep         : false,\n  which        : false,\n  dirs         : false,\n  pushd        : false,\n  popd         : false,\n  env          : false,\n  exec         : false,\n  chmod        : false,\n  config       : false,\n  error        : false,\n  tempdir      : false\n};\n\nexports.typed = {\n  ArrayBuffer         : false,\n  ArrayBufferView     : false,\n  DataView            : false,\n  Float32Array        : false,\n  Float64Array        : false,\n  Int16Array          : false,\n  Int32Array          : false,\n  Int8Array           : false,\n  Uint16Array         : false,\n  Uint32Array         : false,\n  Uint8Array          : false,\n  Uint8ClampedArray   : false\n};\n\nexports.wsh = {\n  ActiveXObject            : true,\n  Enumerator               : true,\n  GetObject                : true,\n  ScriptEngine             : true,\n  ScriptEngineBuildVersion : true,\n  ScriptEngineMajorVersion : true,\n  ScriptEngineMinorVersion : true,\n  VBArray                  : true,\n  WSH                      : true,\n  WScript                  : true,\n  XDomainRequest           : true\n};\n\n// Globals provided by popular JavaScript libraries.\n\nexports.dojo = {\n  dojo     : false,\n  dijit    : false,\n  dojox    : false,\n  define   : false,\n  \"require\": false\n};\n\nexports.jquery = {\n  \"$\"    : false,\n  jQuery : false\n};\n\nexports.mootools = {\n  \"$\"           : false,\n  \"$$\"          : false,\n  Asset         : false,\n  Browser       : false,\n  Chain         : false,\n  Class         : false,\n  Color         : false,\n  Cookie        : false,\n  Core          : false,\n  Document      : false,\n  DomReady      : false,\n  DOMEvent      : false,\n  DOMReady      : false,\n  Drag          : false,\n  Element       : false,\n  Elements      : false,\n  Event         : false,\n  Events        : false,\n  Fx            : false,\n  Group         : false,\n  Hash          : false,\n  HtmlTable     : false,\n  Iframe        : false,\n  IframeShim    : false,\n  InputValidator: false,\n  instanceOf    : false,\n  Keyboard      : false,\n  Locale        : false,\n  Mask          : false,\n  MooTools      : false,\n  Native        : false,\n  Options       : false,\n  OverText      : false,\n  Request       : false,\n  Scroller      : false,\n  Slick         : false,\n  Slider        : false,\n  Sortables     : false,\n  Spinner       : false,\n  Swiff         : false,\n  Tips          : false,\n  Type          : false,\n  typeOf        : false,\n  URI           : false,\n  Window        : false\n};\n\nexports.prototypejs = {\n  \"$\"               : false,\n  \"$$\"              : false,\n  \"$A\"              : false,\n  \"$F\"              : false,\n  \"$H\"              : false,\n  \"$R\"              : false,\n  \"$break\"          : false,\n  \"$continue\"       : false,\n  \"$w\"              : false,\n  Abstract          : false,\n  Ajax              : false,\n  Class             : false,\n  Enumerable        : false,\n  Element           : false,\n  Event             : false,\n  Field             : false,\n  Form              : false,\n  Hash              : false,\n  Insertion         : false,\n  ObjectRange       : false,\n  PeriodicalExecuter: false,\n  Position          : false,\n  Prototype         : false,\n  Selector          : false,\n  Template          : false,\n  Toggle            : false,\n  Try               : false,\n  Autocompleter     : false,\n  Builder           : false,\n  Control           : false,\n  Draggable         : false,\n  Draggables        : false,\n  Droppables        : false,\n  Effect            : false,\n  Sortable          : false,\n  SortableObserver  : false,\n  Sound             : false,\n  Scriptaculous     : false\n};\n\nexports.yui = {\n  YUI       : false,\n  Y         : false,\n  YUI_config: false\n};\n\n\n})()\n},{}],4:[function(require,module,exports){\n(function(){\"use strict\";\n\n// XXX(jeresig): Used for i18n string extraction\nvar $ = { _: function (msg) { return msg; } };\n\nvar errors = {\n  // JSHint options\n  E001: $._(\"Bad option: '{a}'.\"),\n  E002: $._(\"Bad option value.\"),\n\n  // JSHint input\n  E003: $._(\"Expected a JSON value.\"),\n  E004: $._(\"Input is neither a string nor an array of strings.\"),\n  E005: $._(\"Input is empty.\"),\n  E006: $._(\"Unexpected early end of program.\"),\n\n  // Strict mode\n  E007: $._(\"Missing \\\"use strict\\\" statement.\"),\n  E008: $._(\"Strict violation.\"),\n  E009: $._(\"Option 'validthis' can't be used in a global scope.\"),\n  E010: $._(\"'with' is not allowed in strict mode.\"),\n\n  // Constants\n  E011: $._(\"const '{a}' has already been declared.\"),\n  E012: $._(\"const '{a}' is initialized to 'undefined'.\"),\n  E013: $._(\"Attempting to override '{a}' which is a constant.\"),\n\n  // Regular expressions\n  E014: $._(\"A regular expression literal can be confused with '/='.\"),\n  E015: $._(\"Unclosed regular expression.\"),\n  E016: $._(\"Invalid regular expression.\"),\n\n  // Tokens\n  E017: $._(\"It looks like your comment isn't closed. Use \\\"*/\\\" to end a multi-line comment.\"),\n  E018: $._(\"It looks like you never started your comment. Use \\\"/*\\\" to start a multi-line comment.\"),\n  E019: $._(\"Unmatched \\\"{a}\\\".\"),\n  E020: $._(\"I thought you were going to type \\\"{a}\\\" to match \\\"{b}\\\" from line {c} but you typed \\\"{d}\\\"\"),\n  E021: $._(\"I thought you were going to type \\\"{a}\\\" but you typed \\\"{b}\\\"!\"),\n  E022: $._(\"Line breaking error '{a}'.\"),\n  E023: $._(\"I think you're missing a \\\"{a}\\\"!\"),\n  E024: $._(\"Unexpected \\\"{a}\\\".\"),\n  E025: $._(\"I think you're missing ':' on a case clause.\"),\n  E026: $._(\"I think you're missing a '}' to match '{' from line {a}.\"),\n  E027: $._(\"I think you're missing a ']' to match '[' from line {a}.\"),\n  E028: $._(\"Illegal comma.\"),\n  E029: $._(\"Unclosed string! Make sure you end your string with a quote.\"),\n\n  // Everything else\n  E030: $._(\"I thought you were going to type an identifier but you typed '{a}'.\"),\n  E031: $._(\"The left side of an assignment must be a single variable name, not an expression.\"), // FIXME: Rephrase\n  E032: $._(\"I thought you were going to type a number or 'false' but you typed '{a}'.\"),\n  E033: $._(\"I thought you were going to type an operator but you typed '{a}'.\"),\n  E034: $._(\"get/set are ES5 features.\"),\n  E035: $._(\"I think you're missing a property name.\"),\n  E036: $._(\"I thought you were going to type a statement but you typed a block instead.\"),\n  E037: null, // Vacant\n  E038: null, // Vacant\n  E039: $._(\"Function declarations are not invocable. Wrap the whole function invocation in parens.\"),\n  E040: $._(\"Each value should have its own case label.\"),\n  E041: $._(\"Unrecoverable syntax error.\"),\n  E042: $._(\"Stopping.\"),\n  E043: $._(\"Too many errors.\"),\n  E044: $._(\"'{a}' is already defined and can't be redefined.\"),\n  E045: $._(\"Invalid for each loop.\"),\n  E046: $._(\"A yield statement shall be within a generator function (with syntax: `function*`)\"),\n  E047: $._(\"A generator function shall contain a yield statement.\"),\n  E048: $._(\"Let declaration not directly within block.\"),\n  E049: $._(\"A {a} cannot be named '{b}'.\"),\n  E050: $._(\"Mozilla requires the yield expression to be parenthesized here.\"),\n  E051: $._(\"Regular parameters cannot come after default parameters.\"),\n  E052: $._(\"I think you meant to type a value or variable name before that comma?\"),\n  E053: $._(\"I think you either have an extra comma or a missing argument?\")\n};\n\nvar warnings = {\n  W001: $._(\"'hasOwnProperty' is a really bad name.\"),\n  W002: $._(\"Value of '{a}' may be overwritten in IE 8 and earlier.\"),\n  W003: $._(\"'{a}' was used before it was defined.\"),\n  W004: $._(\"'{a}' is already defined.\"),\n  W005: $._(\"A dot following a number can be confused with a decimal point.\"),\n  W006: $._(\"Confusing minuses.\"),\n  W007: $._(\"Confusing pluses.\"),\n  W008: $._(\"Please put a 0 in front of the decimal point: \\\"{a}\\\"!\"),\n  W009: $._(\"The array literal notation [] is preferrable.\"),\n  W010: $._(\"The object literal notation {} is preferrable.\"),\n  W011: $._(\"Unexpected space after '{a}'.\"),\n  W012: $._(\"Unexpected space before '{a}'.\"),\n  W013: $._(\"I think you're missing a space after \\\"{a}\\\".\"),\n  W014: $._(\"Bad line breaking before '{a}'.\"),\n  W015: $._(\"Expected '{a}' to have an indentation at {b} instead at {c}.\"),\n  W016: $._(\"Unexpected use of '{a}'.\"),\n  W017: $._(\"Bad operand.\"),\n  W018: $._(\"Confusing use of '{a}'.\"),\n  W019: $._(\"Use the isNaN function to compare with NaN.\"),\n  W020: $._(\"Read only.\"),\n  W021: $._(\"'{a}' is a function.\"),\n  W022: $._(\"Do not assign to the exception parameter.\"),\n  W023: $._(\"I thought you were going to type an identifier in an assignment but you typed a function invocation instead.\"),\n  W024: $._(\"I thought you were going to type an identifier but you typed '{a}' (a reserved word).\"),\n  W025: $._(\"I think you're missing the name in your function declaration.\"),\n  W026: $._(\"Inner functions should be listed at the top of the outer function.\"),\n  W027: $._(\"Unreachable '{a}' after '{b}'.\"),\n  W028: $._(\"Label '{a}' on {b} statement.\"),\n  W030: $._(\"I thought you were going to type an assignment or function call but you typed an expression instead.\"),\n  W031: $._(\"Do not use 'new' for side effects.\"),\n  W032: $._(\"It looks like you have an unnecessary semicolon.\"),\n  W033: $._(\"It looks like you're missing a semicolon.\"),\n  W034: $._(\"Unnecessary directive \\\"{a}\\\".\"),\n  W035: $._(\"Empty block.\"),\n  W036: $._(\"Unexpected /*member '{a}'.\"),\n  W037: $._(\"'{a}' is a statement label.\"),\n  W038: $._(\"'{a}' used out of scope.\"),\n  W039: $._(\"'{a}' is not allowed.\"),\n  W040: $._(\"Possible strict violation.\"),\n  W041: $._(\"Use '{a}' to compare with '{b}'.\"),\n  W042: $._(\"Avoid EOL escaping.\"),\n  W043: $._(\"Bad escaping of EOL. Use option multistr if needed.\"),\n  W044: $._(\"Bad or unnecessary escaping.\"),\n  W045: $._(\"Bad number '{a}'.\"),\n  W046: $._(\"Don't use extra leading zeros \\\"{a}\\\".\"),\n  W047: $._(\"A trailing decimal point can be confused with a dot: '{a}'.\"),\n  W048: $._(\"Unexpected control character in regular expression.\"),\n  W049: $._(\"Unexpected escaped character '{a}' in regular expression.\"),\n  W050: $._(\"JavaScript URL.\"),\n  W051: $._(\"Variables should not be deleted.\"),\n  W052: $._(\"Unexpected '{a}'.\"),\n  W053: $._(\"Do not use {a} as a constructor.\"),\n  W054: $._(\"The Function constructor is a form of eval.\"),\n  W055: $._(\"A constructor name should start with an uppercase letter.\"),\n  W056: $._(\"Bad constructor.\"),\n  W057: $._(\"Weird construction. Is 'new' necessary?\"),\n  W058: $._(\"I think you're missing the \\\"()\\\" to invoke the constructor.\"),\n  W059: $._(\"Avoid arguments.{a}.\"),\n  W060: $._(\"document.write can be a form of eval.\"),\n  W061: $._(\"eval can be harmful.\"),\n  W062: $._(\"Wrap an immediate function invocation in parens \" +\n    \"to assist the reader in understanding that the expression \" +\n    \"is the result of a function, and not the function itself.\"),\n  W063: $._(\"Math is not a function.\"),\n  W064: $._(\"I think you're missing using 'new' to call a constructor.\"),\n  W065: $._(\"It looks like you're missing a radix parameter.\"),\n  W066: $._(\"Implied eval. Consider passing a function instead of a string.\"),\n  W067: $._(\"Bad invocation.\"),\n  W068: $._(\"Wrapping non-IIFE function literals in parens is unnecessary.\"),\n  W069: $._(\"['{a}'] is better written in dot notation.\"),\n  W070: $._(\"Extra comma. (it breaks older versions of IE)\"),\n  W071: $._(\"This function has too many statements. ({a})\"),\n  W072: $._(\"This function has too many parameters. ({a})\"),\n  W073: $._(\"Blocks are nested too deeply. ({a})\"),\n  W074: $._(\"This function's cyclomatic complexity is too high. ({a})\"),\n  W075: $._(\"Duplicate key '{a}'.\"),\n  W076: $._(\"Unexpected parameter '{a}' in get {b} function.\"),\n  W077: $._(\"Expected a single parameter in set {a} function.\"),\n  W078: $._(\"Setter is defined without getter.\"),\n  W079: $._(\"Redefinition of '{a}'.\"),\n  W080: $._(\"It's not necessary to initialize '{a}' to 'undefined'.\"),\n  W081: $._(\"Too many var statements.\"),\n  W082: $._(\"Function declarations should not be placed in blocks. \" +\n    \"Use a function expression or move the statement to the top of \" +\n    \"the outer function.\"),\n  W083: $._(\"It's not a good idea to define functions within a loop. Can you define them outside instead?\"),\n  W084: $._(\"I thought you were going to type a conditional expression but you typed an assignment instead.\"),\n  W085: $._(\"Don't use 'with'.\"),\n  W086: $._(\"Did you forget a 'break' statement before '{a}'?\"),\n  W087: $._(\"Forgotten 'debugger' statement?\"),\n  W088: $._(\"Creating global 'for' variable. Should be 'for (var {a} ...'.\"),\n  W089: $._(\"The body of a for in should be wrapped in an if statement to filter \" +\n    \"unwanted properties from the prototype.\"),\n  W090: $._(\"'{a}' is not a statement label.\"),\n  W091: $._(\"'{a}' is out of scope.\"),\n  W092: $._(\"Wrap the /regexp/ literal in parens to disambiguate the slash operator.\"),\n  W093: $._(\"Did you mean to return a conditional instead of an assignment?\"),\n  W094: $._(\"Unexpected comma.\"),\n  W095: $._(\"I thought you were going to type a string but you typed {a}.\"),\n  W096: $._(\"The '{a}' key may produce unexpected results.\"),\n  W097: $._(\"Use the function form of \\\"use strict\\\".\"),\n  W098: $._(\"'{a}' is defined but never used.\"),\n  W099: $._(\"Mixed spaces and tabs.\"),\n  W100: $._(\"This character may get silently deleted by one or more browsers.\"),\n  W101: $._(\"Line is too long.\"),\n  W102: $._(\"Trailing whitespace.\"),\n  W103: $._(\"The '{a}' property is deprecated.\"),\n  W104: $._(\"'{a}' is only available in JavaScript 1.7.\"),\n  W105: $._(\"Unexpected {a} in '{b}'.\"),\n  W106: $._(\"Identifier '{a}' is not in camel case.\"),\n  W107: $._(\"Script URL.\"),\n  W108: $._(\"Strings must use doublequote.\"),\n  W109: $._(\"Strings must use singlequote.\"),\n  W110: $._(\"Mixed double and single quotes.\"),\n  W112: $._(\"Unclosed string! Make sure you end your string with a quote.\"),\n  W113: $._(\"Control character in string: {a}.\"),\n  W114: $._(\"Avoid {a}.\"),\n  W115: $._(\"Octal literals are not allowed in strict mode.\"),\n  W116: $._(\"I thought you were going to type \\\"{a}\\\" but you typed \\\"{b}\\\".\"),\n  W117: $._(\"\\\"{a}\\\" is not defined. Make sure you're spelling it correctly and that you declared it.\"),\n  W118: $._(\"'{a}' is only available in Mozilla JavaScript extensions (use moz option).\"),\n  W119: $._(\"'{a}' is only available in ES6 (use esnext option).\"),\n  W120: $._(\"You might be leaking a variable ({a}) here.\"),\n  W121: $._(\"I thought you were going to type a conditional expression but you typed an assignment instead. Maybe you meant to type === instead of =?\"),\n  \n};\n\nvar info = {\n  I001: $._(\"Comma warnings can be turned off with 'laxcomma'.\"),\n  I002: $._(\"Reserved words as properties can be used under the 'es5' option.\"),\n  I003: $._(\"ES5 option is now set per default\")\n};\n\nexports.errors = {};\nexports.warnings = {};\nexports.info = {};\n\nfor (var code in errors) {\n  exports.errors[code] = { code: code, desc: errors[code] };\n}\n\nfor (var code in warnings) {\n  exports.warnings[code] = { code: code, desc: warnings[code] };\n}\n\nfor (var code in info) {\n  exports.info[code] = { code: code, desc: info[code] };\n}\n\n})()\n},{}],5:[function(require,module,exports){\n/*\n * Regular expressions. Some of these are stupidly long.\n */\n\n/*jshint maxlen:1000 */\n\n\"use string\";\n\n// Unsafe comment or string (ax)\nexports.unsafeString =\n  /@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i;\n\n// Unsafe characters that are silently deleted by one or more browsers (cx)\nexports.unsafeChars =\n  /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n\n// Characters in strings that need escaping (nx and nxg)\nexports.needEsc =\n  /[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n\nexports.needEscGlobal =\n  /[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n// Star slash (lx)\nexports.starSlash = /\\*\\//;\n\n// Identifier (ix)\nexports.identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;\n\n// JavaScript URL (jx)\nexports.javascriptURL = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i;\n\n// Catches /* falls through */ comments (ft)\nexports.fallsThrough = /^\\s*\\/\\*\\s*falls?\\sthrough\\s*\\*\\/\\s*$/;\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\nvar state = {\n  syntax: {},\n\n  reset: function () {\n    this.tokens = {\n      prev: null,\n      next: null,\n      curr: null\n    };\n\n    this.option = {};\n    this.ignored = {};\n    this.directive = {};\n    this.jsonMode = false;\n    this.jsonWarnings = [];\n    this.lines = [];\n    this.tab = \"\";\n    this.cache = {}; // Node.JS doesn't have Map. Sniff.\n  }\n};\n\nexports.state = state;\n\n},{}],7:[function(require,module,exports){\n(function(){\"use strict\";\n\nexports.register = function (linter) {\n  // Check for properties named __proto__. This special property was\n  // deprecated and then re-introduced for ES6.\n\n  linter.on(\"Identifier\", function style_scanProto(data) {\n    if (linter.getOption(\"proto\")) {\n      return;\n    }\n\n    if (data.name === \"__proto__\") {\n      linter.warn(\"W103\", {\n        line: data.line,\n        char: data.char,\n        data: [ data.name ]\n      });\n    }\n  });\n\n  // Check for properties named __iterator__. This is a special property\n  // available only in browsers with JavaScript 1.7 implementation.\n\n  linter.on(\"Identifier\", function style_scanIterator(data) {\n    if (linter.getOption(\"iterator\")) {\n      return;\n    }\n\n    if (data.name === \"__iterator__\") {\n      linter.warn(\"W104\", {\n        line: data.line,\n        char: data.char,\n        data: [ data.name ]\n      });\n    }\n  });\n\n  // Check for dangling underscores.\n\n  linter.on(\"Identifier\", function style_scanDangling(data) {\n    if (!linter.getOption(\"nomen\")) {\n      return;\n    }\n\n    // Underscore.js\n    if (data.name === \"_\") {\n      return;\n    }\n\n    // In Node, __dirname and __filename should be ignored.\n    if (linter.getOption(\"node\")) {\n      if (/^(__dirname|__filename)$/.test(data.name) && !data.isProperty) {\n        return;\n      }\n    }\n\n    if (/^(_+.*|.*_+)$/.test(data.name)) {\n      linter.warn(\"W105\", {\n        line: data.line,\n        char: data.from,\n        data: [ \"dangling '_'\", data.name ]\n      });\n    }\n  });\n\n  // Check that all identifiers are using camelCase notation.\n  // Exceptions: names like MY_VAR and _myVar.\n\n  linter.on(\"Identifier\", function style_scanCamelCase(data) {\n    if (!linter.getOption(\"camelcase\")) {\n      return;\n    }\n\n    if (data.name.replace(/^_+/, \"\").indexOf(\"_\") > -1 && !data.name.match(/^[A-Z0-9_]*$/)) {\n      linter.warn(\"W106\", {\n        line: data.line,\n        char: data.from,\n        data: [ data.name ]\n      });\n    }\n  });\n\n  // Enforce consistency in style of quoting.\n\n  linter.on(\"String\", function style_scanQuotes(data) {\n    var quotmark = linter.getOption(\"quotmark\");\n    var code;\n\n    if (!quotmark) {\n      return;\n    }\n\n    // If quotmark is set to 'single' warn about all double-quotes.\n\n    if (quotmark === \"single\" && data.quote !== \"'\") {\n      code = \"W109\";\n    }\n\n    // If quotmark is set to 'double' warn about all single-quotes.\n\n    if (quotmark === \"double\" && data.quote !== \"\\\"\") {\n      code = \"W108\";\n    }\n\n    // If quotmark is set to true, remember the first quotation style\n    // and then warn about all others.\n\n    if (quotmark === true) {\n      if (!linter.getCache(\"quotmark\")) {\n        linter.setCache(\"quotmark\", data.quote);\n      }\n\n      if (linter.getCache(\"quotmark\") !== data.quote) {\n        code = \"W110\";\n      }\n    }\n\n    if (code) {\n      linter.warn(code, {\n        line: data.line,\n        char: data.char,\n      });\n    }\n  });\n\n  linter.on(\"Number\", function style_scanNumbers(data) {\n    if (data.value.charAt(0) === \".\") {\n      // Warn about a leading decimal point.\n      linter.warn(\"W008\", {\n        line: data.line,\n        char: data.char,\n        data: [ data.value ]\n      });\n    }\n\n    if (data.value.substr(data.value.length - 1) === \".\") {\n      // Warn about a trailing decimal point.\n      linter.warn(\"W047\", {\n        line: data.line,\n        char: data.char,\n        data: [ data.value ]\n      });\n    }\n\n    if (/^00+/.test(data.value)) {\n      // Multiple leading zeroes.\n      linter.warn(\"W046\", {\n        line: data.line,\n        char: data.char,\n        data: [ data.value ]\n      });\n    }\n  });\n\n  // Warn about script URLs.\n\n  linter.on(\"String\", function style_scanJavaScriptURLs(data) {\n    var re = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i;\n\n    if (linter.getOption(\"scripturl\")) {\n      return;\n    }\n\n    if (re.test(data.value)) {\n      linter.warn(\"W107\", {\n        line: data.line,\n        char: data.char\n      });\n    }\n  });\n};\n})()\n},{}],8:[function(require,module,exports){\n(function(){/*\n * Lexical analysis and token construction.\n */\n\n\"use strict\";\n\nvar events = require(\"events\");\nvar reg    = require(\"./reg.js\");\nvar state  = require(\"./state.js\").state;\n\n// Some of these token types are from JavaScript Parser API\n// while others are specific to JSHint parser.\n// JS Parser API: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nvar Token = {\n  Identifier: 1,\n  Punctuator: 2,\n  NumericLiteral: 3,\n  StringLiteral: 4,\n  Comment: 5,\n  Keyword: 6,\n  NullLiteral: 7,\n  BooleanLiteral: 8,\n  RegExp: 9\n};\n\n// This is auto generated from the unicode tables.\n// The tables are at:\n// http://www.fileformat.info/info/unicode/category/Lu/list.htm\n// http://www.fileformat.info/info/unicode/category/Ll/list.htm\n// http://www.fileformat.info/info/unicode/category/Lt/list.htm\n// http://www.fileformat.info/info/unicode/category/Lm/list.htm\n// http://www.fileformat.info/info/unicode/category/Lo/list.htm\n// http://www.fileformat.info/info/unicode/category/Nl/list.htm\n\nvar unicodeLetterTable = [\n  170, 170, 181, 181, 186, 186, 192, 214,\n  216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750,\n  880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908,\n  910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366,\n  1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610,\n  1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,\n  1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957,\n  1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069,\n  2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2308, 2361,\n  2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431,\n  2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482,\n  2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\n  2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608,\n  2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654,\n  2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736,\n  2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785,\n  2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867,\n  2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929,\n  2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,\n  2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001,\n  3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123,\n  3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212,\n  3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261,\n  3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344,\n  3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\n  3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526,\n  3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716,\n  3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,\n  3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760,\n  3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805,\n  3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138,\n  4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198,\n  4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4304, 4346,\n  4348, 4348, 4352, 4680, 4682, 4685, 4688, 4694, 4696, 4696,\n  4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789,\n  4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880,\n  4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740,\n  5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900,\n  5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,\n  6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312,\n  6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516,\n  6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823,\n  6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7104, 7141,\n  7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409,\n  7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013,\n  8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061,\n  8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140,\n  8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\n  8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455,\n  8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,\n  8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521,\n  8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358,\n  11360, 11492, 11499, 11502, 11520, 11557, 11568, 11621,\n  11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694,\n  11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,\n  11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295,\n  12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438,\n  12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589,\n  12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312,\n  19893, 19893, 19968, 19968, 40907, 40907, 40960, 42124,\n  42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539,\n  42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783,\n  42786, 42888, 42891, 42894, 42896, 42897, 42912, 42921,\n  43002, 43009, 43011, 43013, 43015, 43018, 43020, 43042,\n  43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\n  43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442,\n  43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595,\n  43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697,\n  43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714,\n  43739, 43741, 43777, 43782, 43785, 43790, 43793, 43798,\n  43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032,\n  55203, 55203, 55216, 55238, 55243, 55291, 63744, 64045,\n  64048, 64109, 64112, 64217, 64256, 64262, 64275, 64279,\n  64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316,\n  64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433,\n  64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\n  65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370,\n  65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495,\n  65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594,\n  65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786,\n  65856, 65908, 66176, 66204, 66208, 66256, 66304, 66334,\n  66352, 66378, 66432, 66461, 66464, 66499, 66504, 66511,\n  66513, 66517, 66560, 66717, 67584, 67589, 67592, 67592,\n  67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669,\n  67840, 67861, 67872, 67897, 68096, 68096, 68112, 68115,\n  68117, 68119, 68121, 68147, 68192, 68220, 68352, 68405,\n  68416, 68437, 68448, 68466, 68608, 68680, 69635, 69687,\n  69763, 69807, 73728, 74606, 74752, 74850, 77824, 78894,\n  92160, 92728, 110592, 110593, 119808, 119892, 119894, 119964,\n  119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980,\n  119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069,\n  120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121,\n  120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144,\n  120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570,\n  120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686,\n  120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779,\n  131072, 131072, 173782, 173782, 173824, 173824, 177972, 177972,\n  177984, 177984, 178205, 178205, 194560, 195101\n];\n\nvar identifierStartTable = [];\n\nfor (var i = 0; i < 128; i++) {\n  identifierStartTable[i] =\n    i === 36 ||           // $\n    i >= 65 && i <= 90 || // A-Z\n    i === 95 ||           // _\n    i >= 97 && i <= 122;  // a-z\n}\n\nvar identifierPartTable = [];\n\nfor (var i = 0; i < 128; i++) {\n  identifierPartTable[i] =\n    identifierStartTable[i] || // $, _, A-Z, a-z\n    i >= 48 && i <= 57;        // 0-9\n}\n\n// Object that handles postponed lexing verifications that checks the parsed\n// environment state.\n\nfunction asyncTrigger() {\n  var _checks = [];\n\n  return {\n    push: function (fn) {\n      _checks.push(fn);\n    },\n\n    check: function () {\n      for (var check = 0; check < _checks.length; ++check) {\n        _checks[check]();\n      }\n\n      _checks.splice(0, _checks.length);\n    }\n  };\n}\n\n/*\n * Lexer for JSHint.\n *\n * This object does a char-by-char scan of the provided source code\n * and produces a sequence of tokens.\n *\n *   var lex = new Lexer(\"var i = 0;\");\n *   lex.start();\n *   lex.token(); // returns the next token\n *\n * You have to use the token() method to move the lexer forward\n * but you don't have to use its return value to get tokens. In addition\n * to token() method returning the next token, the Lexer object also\n * emits events.\n *\n *   lex.on(\"Identifier\", function (data) {\n *     if (data.name.indexOf(\"_\") >= 0) {\n *       // Produce a warning.\n *     }\n *   });\n *\n * Note that the token() method returns tokens in a JSLint-compatible\n * format while the event emitter uses a slightly modified version of\n * Mozilla's JavaScript Parser API. Eventually, we will move away from\n * JSLint format.\n */\nfunction Lexer(source) {\n  var lines = source;\n\n  if (typeof lines === \"string\") {\n    lines = lines\n      .replace(/\\r\\n/g, \"\\n\")\n      .replace(/\\r/g, \"\\n\")\n      .split(\"\\n\");\n  }\n\n  // If the first line is a shebang (#!), make it a blank and move on.\n  // Shebangs are used by Node scripts.\n\n  if (lines[0] && lines[0].substr(0, 2) === \"#!\") {\n    lines[0] = \"\";\n  }\n\n  this.emitter = new events.EventEmitter();\n  this.source = source;\n  this.setLines(lines);\n  this.prereg = true;\n\n  this.line = 0;\n  this.char = 1;\n  this.from = 1;\n  this.input = \"\";\n\n  for (var i = 0; i < state.option.indent; i += 1) {\n    state.tab += \" \";\n  }\n}\n\nLexer.prototype = {\n  _lines: [],\n\n  getLines: function () {\n    this._lines = state.lines;\n    return this._lines;\n  },\n\n  setLines: function (val) {\n    this._lines = val;\n    state.lines = this._lines;\n  },\n\n  /*\n   * Return the next i character without actually moving the\n   * char pointer.\n   */\n  peek: function (i) {\n    return this.input.charAt(i || 0);\n  },\n\n  /*\n   * Move the char pointer forward i times.\n   */\n  skip: function (i) {\n    i = i || 1;\n    this.char += i;\n    this.input = this.input.slice(i);\n  },\n\n  /*\n   * Subscribe to a token event. The API for this method is similar\n   * Underscore.js i.e. you can subscribe to multiple events with\n   * one call:\n   *\n   *   lex.on(\"Identifier Number\", function (data) {\n   *     // ...\n   *   });\n   */\n  on: function (names, listener) {\n    names.split(\" \").forEach(function (name) {\n      this.emitter.on(name, listener);\n    }.bind(this));\n  },\n\n  /*\n   * Trigger a token event. All arguments will be passed to each\n   * listener.\n   */\n  trigger: function () {\n    this.emitter.emit.apply(this.emitter, Array.prototype.slice.call(arguments));\n  },\n\n  /*\n   * Postpone a token event. the checking condition is set as\n   * last parameter, and the trigger function is called in a\n   * stored callback. To be later called using the check() function\n   * by the parser. This avoids parser's peek() to give the lexer\n   * a false context.\n   */\n  triggerAsync: function (type, args, checks, fn) {\n    checks.push(function () {\n      if (fn()) {\n        this.trigger(type, args);\n      }\n    }.bind(this));\n  },\n\n  /*\n   * Extract a punctuator out of the next sequence of characters\n   * or return 'null' if its not possible.\n   *\n   * This method's implementation was heavily influenced by the\n   * scanPunctuator function in the Esprima parser's source code.\n   */\n  scanPunctuator: function () {\n    var ch1 = this.peek();\n    var ch2, ch3, ch4;\n\n    switch (ch1) {\n    // Most common single-character punctuators\n    case \".\":\n      if ((/^[0-9]$/).test(this.peek(1))) {\n        return null;\n      }\n      if (this.peek(1) === \".\" && this.peek(2) === \".\") {\n        return {\n          type: Token.Punctuator,\n          value: \"...\"\n        };\n      }\n      /* falls through */\n    case \"(\":\n    case \")\":\n    case \";\":\n    case \",\":\n    case \"{\":\n    case \"}\":\n    case \"[\":\n    case \"]\":\n    case \":\":\n    case \"~\":\n    case \"?\":\n      return {\n        type: Token.Punctuator,\n        value: ch1\n      };\n\n    // A pound sign (for Node shebangs)\n    case \"#\":\n      return {\n        type: Token.Punctuator,\n        value: ch1\n      };\n\n    // We're at the end of input\n    case \"\":\n      return null;\n    }\n\n    // Peek more characters\n\n    ch2 = this.peek(1);\n    ch3 = this.peek(2);\n    ch4 = this.peek(3);\n\n    // 4-character punctuator: >>>=\n\n    if (ch1 === \">\" && ch2 === \">\" && ch3 === \">\" && ch4 === \"=\") {\n      return {\n        type: Token.Punctuator,\n        value: \">>>=\"\n      };\n    }\n\n    // 3-character punctuators: === !== >>> <<= >>=\n\n    if (ch1 === \"=\" && ch2 === \"=\" && ch3 === \"=\") {\n      return {\n        type: Token.Punctuator,\n        value: \"===\"\n      };\n    }\n\n    if (ch1 === \"!\" && ch2 === \"=\" && ch3 === \"=\") {\n      return {\n        type: Token.Punctuator,\n        value: \"!==\"\n      };\n    }\n\n    if (ch1 === \">\" && ch2 === \">\" && ch3 === \">\") {\n      return {\n        type: Token.Punctuator,\n        value: \">>>\"\n      };\n    }\n\n    if (ch1 === \"<\" && ch2 === \"<\" && ch3 === \"=\") {\n      return {\n        type: Token.Punctuator,\n        value: \"<<=\"\n      };\n    }\n\n    if (ch1 === \">\" && ch2 === \">\" && ch3 === \"=\") {\n      return {\n        type: Token.Punctuator,\n        value: \">>=\"\n      };\n    }\n\n    // Fat arrow punctuator\n    if (ch1 === \"=\" && ch2 === \">\") {\n      return {\n        type: Token.Punctuator,\n        value: ch1 + ch2\n      };\n    }\n\n    // 2-character punctuators: <= >= == != ++ -- << >> && ||\n    // += -= *= %= &= |= ^= (but not /=, see below)\n    if (ch1 === ch2 && (\"+-<>&|\".indexOf(ch1) >= 0)) {\n      return {\n        type: Token.Punctuator,\n        value: ch1 + ch2\n      };\n    }\n\n    if (\"<>=!+-*%&|^\".indexOf(ch1) >= 0) {\n      if (ch2 === \"=\") {\n        return {\n          type: Token.Punctuator,\n          value: ch1 + ch2\n        };\n      }\n\n      return {\n        type: Token.Punctuator,\n        value: ch1\n      };\n    }\n\n    // Special case: /=. We need to make sure that this is an\n    // operator and not a regular expression.\n\n    if (ch1 === \"/\") {\n      if (ch2 === \"=\" && /\\/=(?!(\\S*\\/[gim]?))/.test(this.input)) {\n        // /= is not a part of a regular expression, return it as a\n        // punctuator.\n        return {\n          type: Token.Punctuator,\n          value: \"/=\"\n        };\n      }\n\n      return {\n        type: Token.Punctuator,\n        value: \"/\"\n      };\n    }\n\n    return null;\n  },\n\n  /*\n   * Extract a comment out of the next sequence of characters and/or\n   * lines or return 'null' if its not possible. Since comments can\n   * span across multiple lines this method has to move the char\n   * pointer.\n   *\n   * In addition to normal JavaScript comments (// and /*) this method\n   * also recognizes JSHint- and JSLint-specific comments such as\n   * /*jshint, /*jslint, /*globals and so on.\n   */\n  scanComments: function () {\n    var ch1 = this.peek();\n    var ch2 = this.peek(1);\n    var rest = this.input.substr(2);\n    var startLine = this.line;\n    var startChar = this.char;\n\n    // Create a comment token object and make sure it\n    // has all the data JSHint needs to work with special\n    // comments.\n\n    function commentToken(label, body, opt) {\n      var special = [\"jshint\", \"jslint\", \"members\", \"member\", \"globals\", \"global\", \"exported\"];\n      var isSpecial = false;\n      var value = label + body;\n      var commentType = \"plain\";\n      opt = opt || {};\n\n      if (opt.isMultiline) {\n        value += \"*/\";\n      }\n\n      special.forEach(function (str) {\n        if (isSpecial) {\n          return;\n        }\n\n        // Don't recognize any special comments other than jshint for single-line\n        // comments. This introduced many problems with legit comments.\n        if (label === \"//\" && str !== \"jshint\") {\n          return;\n        }\n\n        if (body.substr(0, str.length) === str) {\n          isSpecial = true;\n          label = label + str;\n          body = body.substr(str.length);\n        }\n\n        if (!isSpecial && body.charAt(0) === \" \" && body.substr(1, str.length) === str) {\n          isSpecial = true;\n          label = label + \" \" + str;\n          body = body.substr(str.length + 1);\n        }\n\n        if (!isSpecial) {\n          return;\n        }\n\n        switch (str) {\n        case \"member\":\n          commentType = \"members\";\n          break;\n        case \"global\":\n          commentType = \"globals\";\n          break;\n        default:\n          commentType = str;\n        }\n      });\n\n      return {\n        type: Token.Comment,\n        commentType: commentType,\n        value: value,\n        body: body,\n        isSpecial: isSpecial,\n        isMultiline: opt.isMultiline || false,\n        isMalformed: opt.isMalformed || false\n      };\n    }\n\n    // End of unbegun comment. Raise an error and skip that input.\n    if (ch1 === \"*\" && ch2 === \"/\") {\n      this.trigger(\"error\", {\n        code: \"E018\",\n        line: startLine,\n        character: startChar\n      });\n\n      this.skip(2);\n      return null;\n    }\n\n    // Comments must start either with // or /*\n    if (ch1 !== \"/\" || (ch2 !== \"*\" && ch2 !== \"/\")) {\n      return null;\n    }\n\n    // One-line comment\n    if (ch2 === \"/\") {\n      this.skip(this.input.length); // Skip to the EOL.\n      return commentToken(\"//\", rest);\n    }\n\n    var body = \"\";\n\n    /* Multi-line comment */\n    if (ch2 === \"*\") {\n      this.skip(2);\n\n      while (this.peek() !== \"*\" || this.peek(1) !== \"/\") {\n        if (this.peek() === \"\") { // End of Line\n          body += \"\\n\";\n\n          // If we hit EOF and our comment is still unclosed,\n          // trigger an error and end the comment implicitly.\n          if (!this.nextLine()) {\n            this.trigger(\"error\", {\n              code: \"E017\",\n              line: startLine,\n              character: startChar\n            });\n\n            return commentToken(\"/*\", body, {\n              isMultiline: true,\n              isMalformed: true\n            });\n          }\n        } else {\n          body += this.peek();\n          this.skip();\n        }\n      }\n\n      this.skip(2);\n      return commentToken(\"/*\", body, { isMultiline: true });\n    }\n  },\n\n  /*\n   * Extract a keyword out of the next sequence of characters or\n   * return 'null' if its not possible.\n   */\n  scanKeyword: function () {\n    var result = /^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input);\n    var keywords = [\n      \"if\", \"in\", \"do\", \"var\", \"for\", \"new\",\n      \"try\", \"let\", \"this\", \"else\", \"case\",\n      \"void\", \"with\", \"enum\", \"while\", \"break\",\n      \"catch\", \"throw\", \"const\", \"yield\", \"class\",\n      \"super\", \"return\", \"typeof\", \"delete\",\n      \"switch\", \"export\", \"import\", \"default\",\n      \"finally\", \"extends\", \"function\", \"continue\",\n      \"debugger\", \"instanceof\"\n    ];\n\n    if (result && keywords.indexOf(result[0]) >= 0) {\n      return {\n        type: Token.Keyword,\n        value: result[0]\n      };\n    }\n\n    return null;\n  },\n\n  /*\n   * Extract a JavaScript identifier out of the next sequence of\n   * characters or return 'null' if its not possible. In addition,\n   * to Identifier this method can also produce BooleanLiteral\n   * (true/false) and NullLiteral (null).\n   */\n  scanIdentifier: function () {\n    var id = \"\";\n    var index = 0;\n    var type, char;\n\n    // Detects any character in the Unicode categories \"Uppercase\n    // letter (Lu)\", \"Lowercase letter (Ll)\", \"Titlecase letter\n    // (Lt)\", \"Modifier letter (Lm)\", \"Other letter (Lo)\", or\n    // \"Letter number (Nl)\".\n    //\n    // Both approach and unicodeLetterTable were borrowed from\n    // Google's Traceur.\n\n    function isUnicodeLetter(code) {\n      for (var i = 0; i < unicodeLetterTable.length;) {\n        if (code < unicodeLetterTable[i++]) {\n          return false;\n        }\n\n        if (code <= unicodeLetterTable[i++]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function isHexDigit(str) {\n      return (/^[0-9a-fA-F]$/).test(str);\n    }\n\n    var readUnicodeEscapeSequence = function () {\n      /*jshint validthis:true */\n      index += 1;\n\n      if (this.peek(index) !== \"u\") {\n        return null;\n      }\n\n      var ch1 = this.peek(index + 1);\n      var ch2 = this.peek(index + 2);\n      var ch3 = this.peek(index + 3);\n      var ch4 = this.peek(index + 4);\n      var code;\n\n      if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {\n        code = parseInt(ch1 + ch2 + ch3 + ch4, 16);\n\n        if (isUnicodeLetter(code)) {\n          index += 5;\n          return \"\\\\u\" + ch1 + ch2 + ch3 + ch4;\n        }\n\n        return null;\n      }\n\n      return null;\n    }.bind(this);\n\n    var getIdentifierStart = function () {\n      /*jshint validthis:true */\n      var chr = this.peek(index);\n      var code = chr.charCodeAt(0);\n\n      if (code === 92) {\n        return readUnicodeEscapeSequence();\n      }\n\n      if (code < 128) {\n        if (identifierStartTable[code]) {\n          index += 1;\n          return chr;\n        }\n\n        return null;\n      }\n\n      if (isUnicodeLetter(code)) {\n        index += 1;\n        return chr;\n      }\n\n      return null;\n    }.bind(this);\n\n    var getIdentifierPart = function () {\n      /*jshint validthis:true */\n      var chr = this.peek(index);\n      var code = chr.charCodeAt(0);\n\n      if (code === 92) {\n        return readUnicodeEscapeSequence();\n      }\n\n      if (code < 128) {\n        if (identifierPartTable[code]) {\n          index += 1;\n          return chr;\n        }\n\n        return null;\n      }\n\n      if (isUnicodeLetter(code)) {\n        index += 1;\n        return chr;\n      }\n\n      return null;\n    }.bind(this);\n\n    char = getIdentifierStart();\n    if (char === null) {\n      return null;\n    }\n\n    id = char;\n    for (;;) {\n      char = getIdentifierPart();\n\n      if (char === null) {\n        break;\n      }\n\n      id += char;\n    }\n\n    switch (id) {\n    case \"true\":\n    case \"false\":\n      type = Token.BooleanLiteral;\n      break;\n    case \"null\":\n      type = Token.NullLiteral;\n      break;\n    default:\n      type = Token.Identifier;\n    }\n\n    return {\n      type: type,\n      value: id\n    };\n  },\n\n  /*\n   * Extract a numeric literal out of the next sequence of\n   * characters or return 'null' if its not possible. This method\n   * supports all numeric literals described in section 7.8.3\n   * of the EcmaScript 5 specification.\n   *\n   * This method's implementation was heavily influenced by the\n   * scanNumericLiteral function in the Esprima parser's source code.\n   */\n  scanNumericLiteral: function () {\n    var index = 0;\n    var value = \"\";\n    var length = this.input.length;\n    var char = this.peek(index);\n    var bad;\n\n    function isDecimalDigit(str) {\n      return (/^[0-9]$/).test(str);\n    }\n\n    function isOctalDigit(str) {\n      return (/^[0-7]$/).test(str);\n    }\n\n    function isHexDigit(str) {\n      return (/^[0-9a-fA-F]$/).test(str);\n    }\n\n    function isIdentifierStart(ch) {\n      return (ch === \"$\") || (ch === \"_\") || (ch === \"\\\\\") ||\n        (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n    }\n\n    // Numbers must start either with a decimal digit or a point.\n\n    if (char !== \".\" && !isDecimalDigit(char)) {\n      return null;\n    }\n\n    if (char !== \".\") {\n      value = this.peek(index);\n      index += 1;\n      char = this.peek(index);\n\n      if (value === \"0\") {\n        // Base-16 numbers.\n        if (char === \"x\" || char === \"X\") {\n          index += 1;\n          value += char;\n\n          while (index < length) {\n            char = this.peek(index);\n            if (!isHexDigit(char)) {\n              break;\n            }\n            value += char;\n            index += 1;\n          }\n\n          if (value.length <= 2) { // 0x\n            return {\n              type: Token.NumericLiteral,\n              value: value,\n              isMalformed: true\n            };\n          }\n\n          if (index < length) {\n            char = this.peek(index);\n            if (isIdentifierStart(char)) {\n              return null;\n            }\n          }\n\n          return {\n            type: Token.NumericLiteral,\n            value: value,\n            base: 16,\n            isMalformed: false\n          };\n        }\n\n        // Base-8 numbers.\n        if (isOctalDigit(char)) {\n          index += 1;\n          value += char;\n          bad = false;\n\n          while (index < length) {\n            char = this.peek(index);\n\n            // Numbers like '019' (note the 9) are not valid octals\n            // but we still parse them and mark as malformed.\n\n            if (isDecimalDigit(char)) {\n              bad = true;\n            } else if (!isOctalDigit(char)) {\n              break;\n            }\n            value += char;\n            index += 1;\n          }\n\n          if (index < length) {\n            char = this.peek(index);\n            if (isIdentifierStart(char)) {\n              return null;\n            }\n          }\n\n          return {\n            type: Token.NumericLiteral,\n            value: value,\n            base: 8,\n            isMalformed: false\n          };\n        }\n\n        // Decimal numbers that start with '0' such as '09' are illegal\n        // but we still parse them and return as malformed.\n\n        if (isDecimalDigit(char)) {\n          index += 1;\n          value += char;\n        }\n      }\n\n      while (index < length) {\n        char = this.peek(index);\n        if (!isDecimalDigit(char)) {\n          break;\n        }\n        value += char;\n        index += 1;\n      }\n    }\n\n    // Decimal digits.\n\n    if (char === \".\") {\n      value += char;\n      index += 1;\n\n      while (index < length) {\n        char = this.peek(index);\n        if (!isDecimalDigit(char)) {\n          break;\n        }\n        value += char;\n        index += 1;\n      }\n    }\n\n    // Exponent part.\n\n    if (char === \"e\" || char === \"E\") {\n      value += char;\n      index += 1;\n      char = this.peek(index);\n\n      if (char === \"+\" || char === \"-\") {\n        value += this.peek(index);\n        index += 1;\n      }\n\n      char = this.peek(index);\n      if (isDecimalDigit(char)) {\n        value += char;\n        index += 1;\n\n        while (index < length) {\n          char = this.peek(index);\n          if (!isDecimalDigit(char)) {\n            break;\n          }\n          value += char;\n          index += 1;\n        }\n      } else {\n        return null;\n      }\n    }\n\n    if (index < length) {\n      char = this.peek(index);\n      if (isIdentifierStart(char)) {\n        return null;\n      }\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: value,\n      base: 10,\n      isMalformed: !isFinite(value)\n    };\n  },\n\n  /*\n   * Extract a string out of the next sequence of characters and/or\n   * lines or return 'null' if its not possible. Since strings can\n   * span across multiple lines this method has to move the char\n   * pointer.\n   *\n   * This method recognizes pseudo-multiline JavaScript strings:\n   *\n   *   var str = \"hello\\\n   *   world\";\n   */\n  scanStringLiteral: function (checks) {\n    /*jshint loopfunc:true */\n    var quote = this.peek();\n\n    // String must start with a quote.\n    if (quote !== \"\\\"\" && quote !== \"'\") {\n      return null;\n    }\n\n    // In JSON strings must always use double quotes.\n    this.triggerAsync(\"warning\", {\n      code: \"W108\",\n      line: this.line,\n      character: this.char // +1?\n    }, checks, function () { return state.jsonMode && quote !== \"\\\"\"; });\n\n    var value = \"\";\n    var startLine = this.line;\n    var startChar = this.char;\n    var allowNewLine = false;\n\n    this.skip();\n\n    while (this.peek() !== quote) {\n      while (this.peek() === \"\") { // End Of Line\n\n        // If an EOL is not preceded by a backslash, show a warning\n        // and proceed like it was a legit multi-line string where\n        // author simply forgot to escape the newline symbol.\n        //\n        // Another approach is to implicitly close a string on EOL\n        // but it generates too many false positives.\n\n        if (!allowNewLine) {\n          this.trigger(\"warning\", {\n            code: \"W112\",\n            line: this.line,\n            character: this.char\n          });\n        } else {\n          allowNewLine = false;\n\n          // Otherwise show a warning if multistr option was not set.\n          // For JSON, show warning no matter what.\n\n          this.triggerAsync(\"warning\", {\n            code: \"W043\",\n            line: this.line,\n            character: this.char\n          }, checks, function () { return !state.option.multistr; });\n\n          this.triggerAsync(\"warning\", {\n            code: \"W042\",\n            line: this.line,\n            character: this.char\n          }, checks, function () { return state.jsonMode && state.option.multistr; });\n        }\n\n        // If we get an EOF inside of an unclosed string, show an\n        // error and implicitly close it at the EOF point.\n\n        if (!this.nextLine()) {\n          this.trigger(\"error\", {\n            code: \"E029\",\n            line: startLine,\n            character: startChar\n          });\n\n          return {\n            type: Token.StringLiteral,\n            value: value,\n            isUnclosed: true,\n            quote: quote\n          };\n        }\n      }\n\n      allowNewLine = false;\n      var char = this.peek();\n      var jump = 1; // A length of a jump, after we're done\n                    // parsing this character.\n\n      if (char < \" \") {\n        // Warn about a control character in a string.\n        this.trigger(\"warning\", {\n          code: \"W113\",\n          line: this.line,\n          character: this.char,\n          data: [ \"<non-printable>\" ]\n        });\n      }\n\n      // Special treatment for some escaped characters.\n\n      if (char === \"\\\\\") {\n        this.skip();\n        char = this.peek();\n\n        switch (char) {\n        case \"'\":\n          this.triggerAsync(\"warning\", {\n            code: \"W114\",\n            line: this.line,\n            character: this.char,\n            data: [ \"\\\\'\" ]\n          }, checks, function () {return state.jsonMode; });\n          break;\n        case \"b\":\n          char = \"\\b\";\n          break;\n        case \"f\":\n          char = \"\\f\";\n          break;\n        case \"n\":\n          char = \"\\n\";\n          break;\n        case \"r\":\n          char = \"\\r\";\n          break;\n        case \"t\":\n          char = \"\\t\";\n          break;\n        case \"0\":\n          char = \"\\0\";\n\n          // Octal literals fail in strict mode.\n          // Check if the number is between 00 and 07.\n          var n = parseInt(this.peek(1), 10);\n          this.triggerAsync(\"warning\", {\n            code: \"W115\",\n            line: this.line,\n            character: this.char\n          }, checks,\n          function () { return n >= 0 && n <= 7 && state.directive[\"use strict\"]; });\n          break;\n        case \"u\":\n          char = String.fromCharCode(parseInt(this.input.substr(1, 4), 16));\n          jump = 5;\n          break;\n        case \"v\":\n          this.triggerAsync(\"warning\", {\n            code: \"W114\",\n            line: this.line,\n            character: this.char,\n            data: [ \"\\\\v\" ]\n          }, checks, function () { return state.jsonMode; });\n\n          char = \"\\v\";\n          break;\n        case \"x\":\n          var x = parseInt(this.input.substr(1, 2), 16);\n\n          this.triggerAsync(\"warning\", {\n            code: \"W114\",\n            line: this.line,\n            character: this.char,\n            data: [ \"\\\\x-\" ]\n          }, checks, function () { return state.jsonMode; });\n\n          char = String.fromCharCode(x);\n          jump = 3;\n          break;\n        case \"\\\\\":\n        case \"\\\"\":\n        case \"/\":\n          break;\n        case \"\":\n          allowNewLine = true;\n          char = \"\";\n          break;\n        case \"!\":\n          if (value.slice(value.length - 2) === \"<\") {\n            break;\n          }\n\n          /*falls through */\n        default:\n          // Weird escaping.\n          this.trigger(\"warning\", {\n            code: \"W044\",\n            line: this.line,\n            character: this.char\n          });\n        }\n      }\n\n      value += char;\n      this.skip(jump);\n    }\n\n    this.skip();\n    return {\n      type: Token.StringLiteral,\n      value: value,\n      isUnclosed: false,\n      quote: quote\n    };\n  },\n\n  /*\n   * Extract a regular expression out of the next sequence of\n   * characters and/or lines or return 'null' if its not possible.\n   *\n   * This method is platform dependent: it accepts almost any\n   * regular expression values but then tries to compile and run\n   * them using system's RegExp object. This means that there are\n   * rare edge cases where one JavaScript engine complains about\n   * your regular expression while others don't.\n   */\n  scanRegExp: function () {\n    var index = 0;\n    var length = this.input.length;\n    var char = this.peek();\n    var value = char;\n    var body = \"\";\n    var flags = [];\n    var malformed = false;\n    var isCharSet = false;\n    var terminated;\n\n    var scanUnexpectedChars = function () {\n      // Unexpected control character\n      if (char < \" \") {\n        malformed = true;\n        this.trigger(\"warning\", {\n          code: \"W048\",\n          line: this.line,\n          character: this.char\n        });\n      }\n\n      // Unexpected escaped character\n      if (char === \"<\") {\n        malformed = true;\n        this.trigger(\"warning\", {\n          code: \"W049\",\n          line: this.line,\n          character: this.char,\n          data: [ char ]\n        });\n      }\n    }.bind(this);\n\n    // Regular expressions must start with '/'\n    if (!this.prereg || char !== \"/\") {\n      return null;\n    }\n\n    index += 1;\n    terminated = false;\n\n    // Try to get everything in between slashes. A couple of\n    // cases aside (see scanUnexpectedChars) we don't really\n    // care whether the resulting expression is valid or not.\n    // We will check that later using the RegExp object.\n\n    while (index < length) {\n      char = this.peek(index);\n      value += char;\n      body += char;\n\n      if (isCharSet) {\n        if (char === \"]\") {\n          if (this.peek(index - 1) !== \"\\\\\" || this.peek(index - 2) === \"\\\\\") {\n            isCharSet = false;\n          }\n        }\n\n        if (char === \"\\\\\") {\n          index += 1;\n          char = this.peek(index);\n          body += char;\n          value += char;\n\n          scanUnexpectedChars();\n        }\n\n        index += 1;\n        continue;\n      }\n\n      if (char === \"\\\\\") {\n        index += 1;\n        char = this.peek(index);\n        body += char;\n        value += char;\n\n        scanUnexpectedChars();\n\n        if (char === \"/\") {\n          index += 1;\n          continue;\n        }\n\n        if (char === \"[\") {\n          index += 1;\n          continue;\n        }\n      }\n\n      if (char === \"[\") {\n        isCharSet = true;\n        index += 1;\n        continue;\n      }\n\n      if (char === \"/\") {\n        body = body.substr(0, body.length - 1);\n        terminated = true;\n        index += 1;\n        break;\n      }\n\n      index += 1;\n    }\n\n    // A regular expression that was never closed is an\n    // error from which we cannot recover.\n\n    if (!terminated) {\n      this.trigger(\"error\", {\n        code: \"E015\",\n        line: this.line,\n        character: this.from\n      });\n\n      return void this.trigger(\"fatal\", {\n        line: this.line,\n        from: this.from\n      });\n    }\n\n    // Parse flags (if any).\n\n    while (index < length) {\n      char = this.peek(index);\n      if (!/[gim]/.test(char)) {\n        break;\n      }\n      flags.push(char);\n      value += char;\n      index += 1;\n    }\n\n    // Check regular expression for correctness.\n\n    try {\n      new RegExp(body, flags.join(\"\"));\n    } catch (err) {\n      malformed = true;\n      this.trigger(\"error\", {\n        code: \"E016\",\n        line: this.line,\n        character: this.char,\n        data: [ err.message ] // Platform dependent!\n      });\n    }\n\n    return {\n      type: Token.RegExp,\n      value: value,\n      flags: flags,\n      isMalformed: malformed\n    };\n  },\n\n  /*\n   * Scan for any occurence of mixed tabs and spaces. If smarttabs option\n   * is on, ignore tabs followed by spaces.\n   *\n   * Tabs followed by one space followed by a block comment are allowed.\n   */\n  scanMixedSpacesAndTabs: function () {\n    var at, match;\n\n    if (state.option.smarttabs) {\n      // Negative look-behind for \"//\"\n      match = this.input.match(/(\\/\\/|^\\s?\\*)? \\t/);\n      at = match && !match[1] ? 0 : -1;\n    } else {\n      at = this.input.search(/ \\t|\\t [^\\*]/);\n    }\n\n    return at;\n  },\n\n  /*\n   * Scan for characters that get silently deleted by one or more browsers.\n   */\n  scanUnsafeChars: function () {\n    return this.input.search(reg.unsafeChars);\n  },\n\n  /*\n   * Produce the next raw token or return 'null' if no tokens can be matched.\n   * This method skips over all space characters.\n   */\n  next: function (checks) {\n    this.from = this.char;\n\n    // Move to the next non-space character.\n    var start;\n    if (/\\s/.test(this.peek())) {\n      start = this.char;\n\n      while (/\\s/.test(this.peek())) {\n        this.from += 1;\n        this.skip();\n      }\n\n      if (this.peek() === \"\") { // EOL\n        if (!/^\\s*$/.test(this.getLines()[this.line - 1]) && state.option.trailing) {\n          this.trigger(\"warning\", { code: \"W102\", line: this.line, character: start });\n        }\n      }\n    }\n\n    // Methods that work with multi-line structures and move the\n    // character pointer.\n\n    var match = this.scanComments() ||\n      this.scanStringLiteral(checks);\n\n    if (match) {\n      return match;\n    }\n\n    // Methods that don't move the character pointer.\n\n    match =\n      this.scanRegExp() ||\n      this.scanPunctuator() ||\n      this.scanKeyword() ||\n      this.scanIdentifier() ||\n      this.scanNumericLiteral();\n\n    if (match) {\n      this.skip(match.value.length);\n      return match;\n    }\n\n    // No token could be matched, give up.\n\n    return null;\n  },\n\n  /*\n   * Switch to the next line and reset all char pointers. Once\n   * switched, this method also checks for mixed spaces and tabs\n   * and other minor warnings.\n   */\n  nextLine: function () {\n    var char;\n\n    if (this.line >= this.getLines().length) {\n      return false;\n    }\n\n    this.input = this.getLines()[this.line];\n    this.line += 1;\n    this.char = 1;\n    this.from = 1;\n\n    char = this.scanMixedSpacesAndTabs();\n    if (char >= 0) {\n      this.trigger(\"warning\", { code: \"W099\", line: this.line, character: char + 1 });\n    }\n\n    this.input = this.input.replace(/\\t/g, state.tab);\n    char = this.scanUnsafeChars();\n\n    if (char >= 0) {\n      this.trigger(\"warning\", { code: \"W100\", line: this.line, character: char });\n    }\n\n    // If there is a limit on line length, warn when lines get too\n    // long.\n\n    if (state.option.maxlen && state.option.maxlen < this.input.length) {\n      this.trigger(\"warning\", { code: \"W101\", line: this.line, character: this.input.length });\n    }\n\n    return true;\n  },\n\n  /*\n   * This is simply a synonym for nextLine() method with a friendlier\n   * public name.\n   */\n  start: function () {\n    this.nextLine();\n  },\n\n  /*\n   * Produce the next token. This function is called by advance() to get\n   * the next token. It retuns a token in a JSLint-compatible format.\n   */\n  token: function () {\n    /*jshint loopfunc:true */\n    var checks = asyncTrigger();\n    var token;\n\n\n    function isReserved(token, isProperty) {\n      if (!token.reserved) {\n        return false;\n      }\n      var meta = token.meta;\n\n      if (meta && meta.isFutureReservedWord && state.option.inES5()) {\n        // ES3 FutureReservedWord in an ES5 environment.\n        if (!meta.es5) {\n          return false;\n        }\n\n        // Some ES5 FutureReservedWord identifiers are active only\n        // within a strict mode environment.\n        if (meta.strictOnly) {\n          if (!state.option.strict && !state.directive[\"use strict\"]) {\n            return false;\n          }\n        }\n\n        if (isProperty) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    // Produce a token object.\n    var create = function (type, value, isProperty) {\n      /*jshint validthis:true */\n      var obj;\n\n      if (type !== \"(endline)\" && type !== \"(end)\") {\n        this.prereg = false;\n      }\n\n      if (type === \"(punctuator)\") {\n        switch (value) {\n        case \".\":\n        case \")\":\n        case \"~\":\n        case \"#\":\n        case \"]\":\n          this.prereg = false;\n          break;\n        default:\n          this.prereg = true;\n        }\n\n        obj = Object.create(state.syntax[value] || state.syntax[\"(error)\"]);\n      }\n\n      if (type === \"(identifier)\") {\n        if (value === \"return\" || value === \"case\" || value === \"typeof\") {\n          this.prereg = true;\n        }\n\n        if (state.syntax.hasOwnProperty(value)) {\n          obj = Object.create(state.syntax[value] || state.syntax[\"(error)\"]);\n\n          // If this can't be a reserved keyword, reset the object.\n          if (!isReserved(obj, isProperty && type === \"(identifier)\")) {\n            obj = null;\n          }\n        }\n      }\n\n      if (!obj) {\n        obj = Object.create(state.syntax[type]);\n      }\n\n      obj.identifier = (type === \"(identifier)\");\n      obj.type = obj.type || type;\n      obj.value = value;\n      obj.line = this.line;\n      obj.character = this.char;\n      obj.from = this.from;\n\n      if (isProperty && obj.identifier) {\n        obj.isProperty = isProperty;\n      }\n\n      obj.check = checks.check;\n\n      return obj;\n    }.bind(this);\n\n    for (;;) {\n      if (!this.input.length) {\n        return create(this.nextLine() ? \"(endline)\" : \"(end)\", \"\");\n      }\n\n      token = this.next(checks);\n\n      if (!token) {\n        if (this.input.length) {\n          // Unexpected character.\n          this.trigger(\"error\", {\n            code: \"E024\",\n            line: this.line,\n            character: this.char,\n            data: [ this.peek() ]\n          });\n\n          this.input = \"\";\n        }\n\n        continue;\n      }\n\n      switch (token.type) {\n      case Token.StringLiteral:\n        this.triggerAsync(\"String\", {\n          line: this.line,\n          char: this.char,\n          from: this.from,\n          value: token.value,\n          quote: token.quote\n        }, checks, function () { return true; });\n\n        return create(\"(string)\", token.value);\n      case Token.Identifier:\n        this.trigger(\"Identifier\", {\n          line: this.line,\n          char: this.char,\n          from: this.form,\n          name: token.value,\n          isProperty: state.tokens.curr.id === \".\"\n        });\n\n        /* falls through */\n      case Token.Keyword:\n      case Token.NullLiteral:\n      case Token.BooleanLiteral:\n        return create(\"(identifier)\", token.value, state.tokens.curr.id === \".\");\n\n      case Token.NumericLiteral:\n        if (token.isMalformed) {\n          this.trigger(\"warning\", {\n            code: \"W045\",\n            line: this.line,\n            character: this.char,\n            data: [ token.value ]\n          });\n        }\n\n        this.triggerAsync(\"warning\", {\n          code: \"W114\",\n          line: this.line,\n          character: this.char,\n          data: [ \"0x-\" ]\n        }, checks, function () { return token.base === 16 && state.jsonMode; });\n\n        this.triggerAsync(\"warning\", {\n          code: \"W115\",\n          line: this.line,\n          character: this.char\n        }, checks, function () {\n          return state.directive[\"use strict\"] && token.base === 8;\n        });\n\n        this.trigger(\"Number\", {\n          line: this.line,\n          char: this.char,\n          from: this.from,\n          value: token.value,\n          base: token.base,\n          isMalformed: token.malformed\n        });\n\n        return create(\"(number)\", token.value);\n\n      case Token.RegExp:\n        return create(\"(regexp)\", token.value);\n\n      case Token.Comment:\n        state.tokens.curr.comment = true;\n\n        if (token.isSpecial) {\n          return {\n            id: '(comment)',\n            value: token.value,\n            body: token.body,\n            type: token.commentType,\n            isSpecial: token.isSpecial,\n            line: this.line,\n            character: this.char,\n            from: this.from\n          };\n        }\n\n        break;\n\n      case \"\":\n        break;\n\n      default:\n        return create(\"(punctuator)\", token.value);\n      }\n    }\n  }\n};\n\nexports.Lexer = Lexer;\n\n})()\n},{\"events\":2,\"./reg.js\":5,\"./state.js\":6}],\"jshint\":[function(require,module,exports){\nmodule.exports=require('FD4Lxs');\n},{}],\"FD4Lxs\":[function(require,module,exports){\n(function(){/*!\n * JSHint, by JSHint Community.\n *\n * This file (and this file only) is licensed under the same slightly modified\n * MIT license that JSLint is. It stops evil-doers everywhere:\n *\n *   Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n *\n *   Permission is hereby granted, free of charge, to any person obtaining\n *   a copy of this software and associated documentation files (the \"Software\"),\n *   to deal in the Software without restriction, including without limitation\n *   the rights to use, copy, modify, merge, publish, distribute, sublicense,\n *   and/or sell copies of the Software, and to permit persons to whom\n *   the Software is furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included\n *   in all copies or substantial portions of the Software.\n *\n *   The Software shall be used for Good, not Evil.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n *   DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*jshint quotmark:double */\n/*global console:true */\n/*exported console */\n\nvar events   = require(\"events\");\nvar vars     = require(\"./vars.js\");\nvar messages = require(\"./messages.js\");\nvar Lexer    = require(\"./lex.js\").Lexer;\nvar reg      = require(\"./reg.js\");\nvar state    = require(\"./state.js\").state;\nvar style    = require(\"./style.js\");\n\n// We need this module here because environments such as IE and Rhino\n// don't necessarilly expose the 'console' API and browserify uses\n// it to log things. It's a sad state of affair, really.\nvar console = require(\"console-browserify\");\n\n// We build the application inside a function so that we produce only a singleton\n// variable. That function will be invoked immediately, and its return value is\n// the JSHINT function itself.\n\nvar JSHINT = (function () {\n  \"use strict\";\n\n  var anonname, // The guessed name for anonymous functions.\n    api, // Extension API\n\n    // These are operators that should not be used with the ! operator.\n    bang = {\n      \"<\"  : true,\n      \"<=\" : true,\n      \"==\" : true,\n      \"===\": true,\n      \"!==\": true,\n      \"!=\" : true,\n      \">\"  : true,\n      \">=\" : true,\n      \"+\"  : true,\n      \"-\"  : true,\n      \"*\"  : true,\n      \"/\"  : true,\n      \"%\"  : true\n    },\n\n    // These are the JSHint boolean options.\n    boolOptions = {\n      asi         : true, // if automatic semicolon insertion should be tolerated\n      bitwise     : true, // if bitwise operators should not be allowed\n      boss        : true, // if advanced usage of assignments should be allowed\n      browser     : true, // if the standard browser globals should be predefined\n      camelcase   : true, // if identifiers should be required in camel case\n      couch       : true, // if CouchDB globals should be predefined\n      curly       : true, // if curly braces around all blocks should be required\n      debug       : true, // if debugger statements should be allowed\n      devel       : true, // if logging globals should be predefined (console, alert, etc.)\n      dojo        : true, // if Dojo Toolkit globals should be predefined\n      eqeqeq      : true, // if === should be required\n      eqnull      : true, // if == null comparisons should be tolerated\n      es3         : true, // if ES3 syntax should be allowed\n      es5         : true, // if ES5 syntax should be allowed (is now set per default)\n      esnext      : true, // if es.next specific syntax should be allowed\n      moz         : true, // if mozilla specific syntax should be allowed\n      evil        : true, // if eval should be allowed\n      expr        : true, // if ExpressionStatement should be allowed as Programs\n      forin       : true, // if for in statements must filter\n      funcscope   : true, // if only function scope should be used for scope tests\n      gcl         : true, // if JSHint should be compatible with Google Closure Linter\n      globalstrict: true, // if global \"use strict\"; should be allowed (also enables 'strict')\n      immed       : true, // if immediate invocations must be wrapped in parens\n      iterator    : true, // if the `__iterator__` property should be allowed\n      jquery      : true, // if jQuery globals should be predefined\n      lastsemic   : true, // if semicolons may be ommitted for the trailing\n                          // statements inside of a one-line blocks.\n      laxbreak    : true, // if line breaks should not be checked\n      laxcomma    : true, // if line breaks should not be checked around commas\n      loopfunc    : true, // if functions should be allowed to be defined within\n                          // loops\n      mootools    : true, // if MooTools globals should be predefined\n      multistr    : true, // allow multiline strings\n      newcap      : true, // if constructor names must be capitalized\n      noarg       : true, // if arguments.caller and arguments.callee should be\n                          // disallowed\n      node        : true, // if the Node.js environment globals should be\n                          // predefined\n      noempty     : true, // if empty blocks should be disallowed\n      nonew       : true, // if using `new` for side-effects should be disallowed\n      nonstandard : true, // if non-standard (but widely adopted) globals should\n                          // be predefined\n      nomen       : true, // if names should be checked\n      onevar      : true, // if only one var statement per function should be\n                          // allowed\n      passfail    : true, // if the scan should stop on first error\n      phantom     : true, // if PhantomJS symbols should be allowed\n      plusplus    : true, // if increment/decrement should not be allowed\n      proto       : true, // if the `__proto__` property should be allowed\n      prototypejs : true, // if Prototype and Scriptaculous globals should be\n                          // predefined\n      rhino       : true, // if the Rhino environment globals should be predefined\n      shelljs     : true, // if ShellJS globals should be predefined\n      typed       : true, // if typed array globals should be predefined\n      undef       : true, // if variables should be declared before used\n      scripturl   : true, // if script-targeted URLs should be tolerated\n      shadow      : true, // if variable shadowing should be tolerated\n      smarttabs   : true, // if smarttabs should be tolerated\n                          // (http://www.emacswiki.org/emacs/SmartTabs)\n      strict      : true, // require the \"use strict\"; pragma\n      sub         : true, // if all forms of subscript notation are tolerated\n      supernew    : true, // if `new function () { ... };` and `new Object;`\n                          // should be tolerated\n      trailing    : true, // if trailing whitespace rules apply\n      validthis   : true, // if 'this' inside a non-constructor function is valid.\n                          // This is a function scoped option only.\n      withstmt    : true, // if with statements should be allowed\n      white       : true, // if strict whitespace rules apply\n      worker      : true, // if Web Worker script symbols should be allowed\n      wsh         : true, // if the Windows Scripting Host environment globals\n                          // should be predefined\n      yui         : true, // YUI variables should be predefined\n\n      // Obsolete options\n      onecase     : true, // if one case switch statements should be allowed\n      regexp      : true, // if the . should not be allowed in regexp literals\n      regexdash   : true  // if unescaped first/last dash (-) inside brackets\n                          // should be tolerated\n    },\n\n    // These are the JSHint options that can take any value\n    // (we use this object to detect invalid options)\n    valOptions = {\n      maxlen       : false,\n      indent       : false,\n      maxerr       : false,\n      predef       : false,\n      quotmark     : false, //'single'|'double'|true\n      scope        : false,\n      maxstatements: false, // {int} max statements per function\n      maxdepth     : false, // {int} max nested block depth per function\n      maxparams    : false, // {int} max params per function\n      maxcomplexity: false, // {int} max cyclomatic complexity per function\n      unused       : true,  // warn if variables are unused. Available options:\n                            //   false    - don't check for unused variables\n                            //   true     - \"vars\" + check last function param\n                            //   \"vars\"   - skip checking unused function params\n                            //   \"strict\" - \"vars\" + check all function params\n      latedef      : false  // warn if the variable is used before its definition\n                            //   false    - don't emit any warnings\n                            //   true     - warn if any variable is used before its definition\n                            //   \"nofunc\" - warn for any variable but function declarations\n    },\n\n    // These are JSHint boolean options which are shared with JSLint\n    // where the definition in JSHint is opposite JSLint\n    invertedOptions = {\n      bitwise : true,\n      forin   : true,\n      newcap  : true,\n      nomen   : true,\n      plusplus: true,\n      regexp  : true,\n      undef   : true,\n      white   : true,\n\n      // Inverted and renamed, use JSHint name here\n      eqeqeq  : true,\n      onevar  : true,\n      strict  : true\n    },\n\n    // These are JSHint boolean options which are shared with JSLint\n    // where the name has been changed but the effect is unchanged\n    renamedOptions = {\n      eqeq   : \"eqeqeq\",\n      vars   : \"onevar\",\n      windows: \"wsh\",\n      sloppy : \"strict\"\n    },\n\n    declared, // Globals that were declared using /*global ... */ syntax.\n    exported, // Variables that are used outside of the current file.\n\n    functionicity = [\n      \"closure\", \"exception\", \"global\", \"label\",\n      \"outer\", \"unused\", \"var\"\n    ],\n\n    funct, // The current function\n    functions, // All of the functions\n\n    global, // The global scope\n    implied, // Implied globals\n    inblock,\n    indent,\n    lookahead,\n    lex,\n    member,\n    membersOnly,\n    noreach,\n    predefined,   // Global variables defined by option\n\n    scope,  // The current scope\n    stack,\n    unuseds,\n    urls,\n    warnings,\n\n    extraModules = [],\n    emitter = new events.EventEmitter(),\n        \n    hasOwnProperty = Object.prototype.hasOwnProperty,\n    _ = {};\n\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  _.contains = function(obj, target) {\n    if (obj === null || obj === undefined) {\n      return false;\n    }\n    return obj.indexOf(target) !== -1;\n  };\n\n  function checkOption(name, t) {\n    name = name.trim();\n\n    if (/^[+-]W\\d{3}$/g.test(name)) {\n      return true;\n    }\n\n    if (valOptions[name] === undefined && boolOptions[name] === undefined) {\n      if (t.type !== \"jslint\") {\n        error(\"E001\", t, name);\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function isString(obj) {\n    return Object.prototype.toString.call(obj) === \"[object String]\";\n  }\n\n  function isIdentifier(tkn, value) {\n    if (!tkn)\n      return false;\n\n    if (!tkn.identifier || tkn.value !== value)\n      return false;\n\n    return true;\n  }\n\n  function isReserved(token) {\n    if (!token.reserved) {\n      return false;\n    }\n    var meta = token.meta;\n\n    if (meta && meta.isFutureReservedWord && state.option.inES5()) {\n      // ES3 FutureReservedWord in an ES5 environment.\n      if (!meta.es5) {\n        return false;\n      }\n\n      // Some ES5 FutureReservedWord identifiers are active only\n      // within a strict mode environment.\n      if (meta.strictOnly) {\n        if (!state.option.strict && !state.directive[\"use strict\"]) {\n          return false;\n        }\n      }\n\n      if (token.isProperty) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function supplant(str, data) {\n    return str.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n      var r = data[b];\n      return typeof r === \"string\" || typeof r === \"number\" ? r : a;\n    });\n  }\n\n  function combine(t, o) {\n    var n;\n    for (n in o) {\n      if (_.has(o, n) && !_.has(JSHINT.blacklist, n)) {\n        t[n] = o[n];\n      }\n    }\n  }\n\n  function updatePredefined() {\n    Object.keys(JSHINT.blacklist).forEach(function (key) {\n      delete predefined[key];\n    });\n  }\n\n  function assume() {\n    if (state.option.es5) {\n      warning(\"I003\");\n    }\n    if (state.option.couch) {\n      combine(predefined, vars.couch);\n    }\n\n    if (state.option.rhino) {\n      combine(predefined, vars.rhino);\n    }\n\n    if (state.option.shelljs) {\n      combine(predefined, vars.shelljs);\n      combine(predefined, vars.node);\n    }\n    if (state.option.typed) {\n      combine(predefined, vars.typed);\n    }\n\n    if (state.option.phantom) {\n      combine(predefined, vars.phantom);\n    }\n\n    if (state.option.prototypejs) {\n      combine(predefined, vars.prototypejs);\n    }\n\n    if (state.option.node) {\n      combine(predefined, vars.node);\n      combine(predefined, vars.typed);\n    }\n\n    if (state.option.devel) {\n      combine(predefined, vars.devel);\n    }\n\n    if (state.option.dojo) {\n      combine(predefined, vars.dojo);\n    }\n\n    if (state.option.browser) {\n      combine(predefined, vars.browser);\n      combine(predefined, vars.typed);\n    }\n\n    if (state.option.nonstandard) {\n      combine(predefined, vars.nonstandard);\n    }\n\n    if (state.option.jquery) {\n      combine(predefined, vars.jquery);\n    }\n\n    if (state.option.mootools) {\n      combine(predefined, vars.mootools);\n    }\n\n    if (state.option.worker) {\n      combine(predefined, vars.worker);\n    }\n\n    if (state.option.wsh) {\n      combine(predefined, vars.wsh);\n    }\n\n    if (state.option.globalstrict && state.option.strict !== false) {\n      state.option.strict = true;\n    }\n\n    if (state.option.yui) {\n      combine(predefined, vars.yui);\n    }\n\n    // Let's assume that chronologically ES3 < ES5 < ES6/ESNext < Moz\n\n    state.option.inMoz = function (strict) {\n      if (strict) {\n        return state.option.moz && !state.option.esnext;\n      }\n      return state.option.moz;\n    };\n\n    state.option.inESNext = function (strict) {\n      if (strict) {\n        return !state.option.moz && state.option.esnext;\n      }\n      return state.option.moz || state.option.esnext;\n    };\n\n    state.option.inES5 = function (/* strict */) {\n      return !state.option.es3;\n    };\n\n    state.option.inES3 = function (strict) {\n      if (strict) {\n        return !state.option.moz && !state.option.esnext && state.option.es3;\n      }\n      return state.option.es3;\n    };\n  }\n\n  // Produce an error warning.\n  function quit(code, line, chr) {\n    var percentage = Math.floor((line / state.lines.length) * 100);\n    var message = messages.errors[code].desc;\n\n    throw {\n      name: \"JSHintError\",\n      line: line,\n      character: chr,\n      message: message + \" (\" + percentage + \"% scanned).\",\n      raw: message,\n      code: code\n    };\n  }\n\n  function isundef(scope, code, token, a) {\n    return JSHINT.undefs.push([scope, code, token, a]);\n  }\n\n  function warning(code, t, a, b, c, d) {\n    var ch, l, w, msg;\n\n    if (/^W\\d{3}$/.test(code)) {\n      if (state.ignored[code])\n        return;\n\n      msg = messages.warnings[code];\n    } else if (/E\\d{3}/.test(code)) {\n      msg = messages.errors[code];\n    } else if (/I\\d{3}/.test(code)) {\n      msg = messages.info[code];\n    }\n\n    t = t || state.tokens.next;\n    if (t.id === \"(end)\") {  // `~\n      t = state.tokens.curr;\n    }\n\n    l = t.line || 0;\n    ch = t.from || 0;\n\n    w = {\n      id: \"(error)\",\n      raw: msg.desc,\n      code: msg.code,\n      evidence: state.lines[l - 1] || \"\",\n      line: l,\n      character: ch,\n      scope: JSHINT.scope,\n      a: a,\n      b: b,\n      c: c,\n      d: d\n    };\n\n    w.reason = supplant(msg.desc, w);\n    JSHINT.errors.push(w);\n\n    if (state.option.passfail) {\n      quit(\"E042\", l, ch);\n    }\n\n    warnings += 1;\n    if (warnings >= state.option.maxerr) {\n      quit(\"E043\", l, ch);\n    }\n\n    return w;\n  }\n\n  function warningAt(m, l, ch, a, b, c, d) {\n    return warning(m, {\n      line: l,\n      from: ch\n    }, a, b, c, d);\n  }\n\n  function error(m, t, a, b, c, d) {\n    warning(m, t, a, b, c, d);\n  }\n\n  function errorAt(m, l, ch, a, b, c, d) {\n    return error(m, {\n      line: l,\n      from: ch\n    }, a, b, c, d);\n  }\n\n  // Tracking of \"internal\" scripts, like eval containing a static string\n  function addInternalSrc(elem, src) {\n    var i;\n    i = {\n      id: \"(internal)\",\n      elem: elem,\n      value: src\n    };\n    JSHINT.internals.push(i);\n    return i;\n  }\n\n  function addlabel(t, type, tkn, islet) {\n    // Define t in the current function in the current scope.\n    if (type === \"exception\") {\n      if (_.has(funct[\"(context)\"], t)) {\n        if (funct[t] !== true && !state.option.node) {\n          warning(\"W002\", state.tokens.next, t);\n        }\n      }\n    }\n\n    if (_.has(funct, t) && !funct[\"(global)\"]) {\n      if (funct[t] === true) {\n        if (state.option.latedef) {\n          if ((state.option.latedef === true && _.contains([funct[t], type], \"unction\")) ||\n              !_.contains([funct[t], type], \"unction\")) {\n            warning(\"W003\", state.tokens.next, t);\n          }\n        }\n      } else {\n        if (!state.option.shadow && type !== \"exception\" ||\n              (funct[\"(blockscope)\"].getlabel(t))) {\n          warning(\"W004\", state.tokens.next, t);\n        }\n      }\n    }\n\n    // a double definition of a let variable in same block throws a TypeError\n    if (funct[\"(blockscope)\"] && funct[\"(blockscope)\"].current.has(t)) {\n      error(\"E044\", state.tokens.next, t);\n    }\n\n    // if the identifier is from a let, adds it only to the current blockscope\n    if (islet) {\n      funct[\"(blockscope)\"].current.add(t, type, state.tokens.curr);\n    } else {\n\n      funct[t] = type;\n\n      if (tkn) {\n        funct[\"(tokens)\"][t] = tkn;\n      }\n\n      if (funct[\"(global)\"]) {\n        global[t] = funct;\n        if (_.has(implied, t)) {\n          if (state.option.latedef) {\n            if ((state.option.latedef === true && _.contains([funct[t], type], \"unction\")) ||\n                !_.contains([funct[t], type], \"unction\")) {\n              warning(\"W003\", state.tokens.next, t);\n            }\n          }\n\n          delete implied[t];\n        }\n      } else {\n        scope[t] = funct;\n      }\n    }\n  }\n\n  function doOption() {\n    var nt = state.tokens.next;\n    var body = nt.body.split(\",\").map(function (s) { return s.trim(); });\n    var predef = {};\n\n    if (nt.type === \"globals\") {\n      body.forEach(function (g) {\n        g = g.split(\":\");\n        var key = (g[0] || \"\").trim();\n        var val = (g[1] || \"\").trim();\n\n        if (key.charAt(0) === \"-\") {\n          key = key.slice(1);\n          val = false;\n\n          JSHINT.blacklist[key] = key;\n          updatePredefined();\n        } else {\n          predef[key] = (val === \"true\");\n        }\n      });\n\n      combine(predefined, predef);\n\n      for (var key in predef) {\n        if (_.has(predef, key)) {\n          declared[key] = nt;\n        }\n      }\n    }\n\n    if (nt.type === \"exported\") {\n      body.forEach(function (e) {\n        exported[e] = true;\n      });\n    }\n\n    if (nt.type === \"members\") {\n      membersOnly = membersOnly || {};\n\n      body.forEach(function (m) {\n        var ch1 = m.charAt(0);\n        var ch2 = m.charAt(m.length - 1);\n\n        if (ch1 === ch2 && (ch1 === \"\\\"\" || ch1 === \"'\")) {\n          m = m\n            .substr(1, m.length - 2)\n            .replace(\"\\\\b\", \"\\b\")\n            .replace(\"\\\\t\", \"\\t\")\n            .replace(\"\\\\n\", \"\\n\")\n            .replace(\"\\\\v\", \"\\v\")\n            .replace(\"\\\\f\", \"\\f\")\n            .replace(\"\\\\r\", \"\\r\")\n            .replace(\"\\\\\\\\\", \"\\\\\")\n            .replace(\"\\\\\\\"\", \"\\\"\");\n        }\n\n        membersOnly[m] = false;\n      });\n    }\n\n    var numvals = [\n      \"maxstatements\",\n      \"maxparams\",\n      \"maxdepth\",\n      \"maxcomplexity\",\n      \"maxerr\",\n      \"maxlen\",\n      \"indent\"\n    ];\n\n    if (nt.type === \"jshint\" || nt.type === \"jslint\") {\n      body.forEach(function (g) {\n        g = g.split(\":\");\n        var key = (g[0] || \"\").trim();\n        var val = (g[1] || \"\").trim();\n\n        if (!checkOption(key, nt)) {\n          return;\n        }\n\n        if (numvals.indexOf(key) >= 0) {\n\n          // GH988 - numeric options can be disabled by setting them to `false`\n          if (val !== \"false\") {\n            val = +val;\n\n            if (typeof val !== \"number\" || !isFinite(val) || val <= 0 || Math.floor(val) !== val) {\n              error(\"E032\", nt, g[1].trim());\n              return;\n            }\n\n            if (key === \"indent\") {\n              state.option[\"(explicitIndent)\"] = true;\n            }\n            state.option[key] = val;\n          } else {\n            if (key === \"indent\") {\n              state.option[\"(explicitIndent)\"] = false;\n            } else {\n              state.option[key] = false;\n            }\n          }\n\n          return;\n        }\n\n        if (key === \"validthis\") {\n          // `validthis` is valid only within a function scope.\n          if (funct[\"(global)\"]) {\n            error(\"E009\");\n          } else {\n            if (val === \"true\" || val === \"false\") {\n              state.option.validthis = (val === \"true\");\n            } else {\n              error(\"E002\", nt);\n            }\n          }\n          return;\n        }\n\n        if (key === \"quotmark\") {\n          switch (val) {\n          case \"true\":\n          case \"false\":\n            state.option.quotmark = (val === \"true\");\n            break;\n          case \"double\":\n          case \"single\":\n            state.option.quotmark = val;\n            break;\n          default:\n            error(\"E002\", nt);\n          }\n          return;\n        }\n\n        if (key === \"unused\") {\n          switch (val) {\n          case \"true\":\n            state.option.unused = true;\n            break;\n          case \"false\":\n            state.option.unused = false;\n            break;\n          case \"vars\":\n          case \"strict\":\n            state.option.unused = val;\n            break;\n          default:\n            error(\"E002\", nt);\n          }\n          return;\n        }\n\n        if (key === \"latedef\") {\n          switch (val) {\n          case \"true\":\n            state.option.latedef = true;\n            break;\n          case \"false\":\n            state.option.latedef = false;\n            break;\n          case \"nofunc\":\n            state.option.latedef = \"nofunc\";\n            break;\n          default:\n            error(\"E002\", nt);\n          }\n          return;\n        }\n\n        var match = /^([+-])(W\\d{3})$/g.exec(key);\n        if (match) {\n          // ignore for -W..., unignore for +W...\n          state.ignored[match[2]] = (match[1] === \"-\");\n          return;\n        }\n\n        var tn;\n        if (val === \"true\" || val === \"false\") {\n          if (nt.type === \"jslint\") {\n            tn = renamedOptions[key] || key;\n            state.option[tn] = (val === \"true\");\n\n            if (invertedOptions[tn] !== undefined) {\n              state.option[tn] = !state.option[tn];\n            }\n          } else {\n            state.option[key] = (val === \"true\");\n          }\n\n          if (key === \"newcap\") {\n            state.option[\"(explicitNewcap)\"] = true;\n          }\n          return;\n        }\n\n        error(\"E002\", nt);\n      });\n\n      assume();\n    }\n  }\n\n  // We need a peek function. If it has an argument, it peeks that much farther\n  // ahead. It is used to distinguish\n  //     for ( var i in ...\n  // from\n  //     for ( var i = ...\n\n  function peek(p) {\n    var i = p || 0, j = 0, t;\n\n    while (j <= i) {\n      t = lookahead[j];\n      if (!t) {\n        t = lookahead[j] = lex.token();\n      }\n      j += 1;\n    }\n    return t;\n  }\n\n  // Produce the next token. It looks for programming errors.\n\n  function advance(id, t) {\n    switch (state.tokens.curr.id) {\n    case \"(number)\":\n      if (state.tokens.next.id === \".\") {\n        warning(\"W005\", state.tokens.curr);\n      }\n      break;\n    case \"-\":\n      if (state.tokens.next.id === \"-\" || state.tokens.next.id === \"--\") {\n        warning(\"W006\");\n      }\n      break;\n    case \"+\":\n      if (state.tokens.next.id === \"+\" || state.tokens.next.id === \"++\") {\n        warning(\"W007\");\n      }\n      break;\n    }\n\n    if (state.tokens.curr.type === \"(string)\" || state.tokens.curr.identifier) {\n      anonname = state.tokens.curr.value;\n    }\n\n    if (id && state.tokens.next.id !== id) {\n      if (t) {\n        if (state.tokens.next.id === \"(end)\") {\n          error(\"E019\", t, t.id);\n        } else {\n          error(\"E020\", state.tokens.next, id, t.id, t.line, state.tokens.next.value);\n        }\n      } else if (state.tokens.next.type !== \"(identifier)\" || state.tokens.next.value !== id) {\n        warning(\"W116\", state.tokens.next, id, state.tokens.next.value);\n      }\n    }\n\n    state.tokens.prev = state.tokens.curr;\n    state.tokens.curr = state.tokens.next;\n    for (;;) {\n      state.tokens.next = lookahead.shift() || lex.token();\n\n      if (!state.tokens.next) { // No more tokens left, give up\n        quit(\"E041\", state.tokens.curr.line);\n      }\n\n      if (state.tokens.next.id === \"(end)\" || state.tokens.next.id === \"(error)\") {\n        return;\n      }\n\n      if (state.tokens.next.check) {\n        state.tokens.next.check();\n      }\n\n      if (state.tokens.next.isSpecial) {\n        doOption();\n      } else {\n        if (state.tokens.next.id !== \"(endline)\") {\n          break;\n        }\n      }\n    }\n  }\n\n  function isInfix(token) {\n    return token.infix || (!token.identifier && !!token.led);\n  }\n\n  function isEndOfExpr() {\n    var curr = state.tokens.curr;\n    var next = state.tokens.next;\n    if (next.id === \";\" || next.id === \"}\" || next.id === \":\") {\n      return true;\n    }\n    if (isInfix(next) === isInfix(curr) || (curr.id === \"yield\" && state.option.inMoz(true))) {\n      return curr.line !== next.line;\n    }\n    return false;\n  }\n\n  // This is the heart of JSHINT, the Pratt parser. In addition to parsing, it\n  // is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n  // like .nud except that it is only used on the first token of a statement.\n  // Having .fud makes it much easier to define statement-oriented languages like\n  // JavaScript. I retained Pratt's nomenclature.\n\n  // .nud  Null denotation\n  // .fud  First null denotation\n  // .led  Left denotation\n  //  lbp  Left binding power\n  //  rbp  Right binding power\n\n  // They are elements of the parsing method called Top Down Operator Precedence.\n\n  function expression(rbp, initial) {\n    var left, isArray = false, isObject = false, isLetExpr = false;\n\n    // if current expression is a let expression\n    if (!initial && state.tokens.next.value === \"let\" && peek(0).value === \"(\") {\n      if (!state.option.inMoz(true)) {\n        warning(\"W118\", state.tokens.next, \"let expressions\");\n      }\n      isLetExpr = true;\n      // create a new block scope we use only for the current expression\n      funct[\"(blockscope)\"].stack();\n      advance(\"let\");\n      advance(\"(\");\n      state.syntax[\"let\"].fud.call(state.syntax[\"let\"].fud, false);\n      advance(\")\");\n    }\n\n    if (state.tokens.next.id === \"(end)\")\n      error(\"E006\", state.tokens.curr);\n\n    advance();\n\n    if (initial) {\n      anonname = \"anonymous\";\n      funct[\"(verb)\"] = state.tokens.curr.value;\n    }\n\n    if (initial === true && state.tokens.curr.fud) {\n      left = state.tokens.curr.fud();\n    } else {\n      if (state.tokens.curr.nud) {\n        left = state.tokens.curr.nud();\n      } else {\n        if (state.tokens.curr.value === \",\") {\n          error(\"E052\", state.tokens.curr, state.tokens.curr.id);\n        } else {\n          error(\"E030\", state.tokens.curr, state.tokens.curr.id);\n        }\n      }\n\n      while (rbp < state.tokens.next.lbp && !isEndOfExpr()) {\n        isArray = state.tokens.curr.value === \"Array\";\n        isObject = state.tokens.curr.value === \"Object\";\n\n        // #527, new Foo.Array(), Foo.Array(), new Foo.Object(), Foo.Object()\n        // Line breaks in IfStatement heads exist to satisfy the checkJSHint\n        // \"Line too long.\" error.\n        if (left && (left.value || (left.first && left.first.value))) {\n          // If the left.value is not \"new\", or the left.first.value is a \".\"\n          // then safely assume that this is not \"new Array()\" and possibly\n          // not \"new Object()\"...\n          if (left.value !== \"new\" ||\n            (left.first && left.first.value && left.first.value === \".\")) {\n            isArray = false;\n            // ...In the case of Object, if the left.value and state.tokens.curr.value\n            // are not equal, then safely assume that this not \"new Object()\"\n            if (left.value !== state.tokens.curr.value) {\n              isObject = false;\n            }\n          }\n        }\n\n        advance();\n\n        if (isArray && state.tokens.curr.id === \"(\" && state.tokens.next.id === \")\") {\n          warning(\"W009\", state.tokens.curr);\n        }\n\n        if (isObject && state.tokens.curr.id === \"(\" && state.tokens.next.id === \")\") {\n          warning(\"W010\", state.tokens.curr);\n        }\n\n        if (left && state.tokens.curr.led) {\n          left = state.tokens.curr.led(left);\n        } else {\n          error(\"E033\", state.tokens.curr, state.tokens.curr.id);\n        }\n      }\n    }\n    if (isLetExpr) {\n      funct[\"(blockscope)\"].unstack();\n    }\n    return left;\n  }\n\n\n// Functions for conformance of style.\n\n  function adjacent(left, right) {\n    left = left || state.tokens.curr;\n    right = right || state.tokens.next;\n    if (state.option.white) {\n      if (left.character !== right.from && left.line === right.line) {\n        left.from += (left.character - left.from);\n        warning(\"W011\", left, left.value);\n      }\n    }\n  }\n\n  function nobreak(left, right) {\n    left = left || state.tokens.curr;\n    right = right || state.tokens.next;\n    if (state.option.white && (left.character !== right.from || left.line !== right.line)) {\n      warning(\"W012\", right, right.value);\n    }\n  }\n\n  function nospace(left, right) {\n    left = left || state.tokens.curr;\n    right = right || state.tokens.next;\n    if (state.option.white && !left.comment) {\n      if (left.line === right.line) {\n        adjacent(left, right);\n      }\n    }\n  }\n\n  function nonadjacent(left, right) {\n    if (state.option.white) {\n      left = left || state.tokens.curr;\n      right = right || state.tokens.next;\n\n      if (left.value === \";\" && right.value === \";\") {\n        return;\n      }\n\n      if (left.line === right.line && left.character === right.from) {\n        left.from += (left.character - left.from);\n        warning(\"W013\", left, left.value);\n      }\n    }\n  }\n\n  function nobreaknonadjacent(left, right) {\n    left = left || state.tokens.curr;\n    right = right || state.tokens.next;\n    if (!state.option.laxbreak && left.line !== right.line) {\n      warning(\"W014\", right, right.value);\n    } else if (state.option.white) {\n      left = left || state.tokens.curr;\n      right = right || state.tokens.next;\n      if (left.character === right.from) {\n        left.from += (left.character - left.from);\n        warning(\"W013\", left, left.value);\n      }\n    }\n  }\n\n  function indentation(bias) {\n    if (!state.option.white && !state.option[\"(explicitIndent)\"]) {\n      return;\n    }\n\n    if (state.tokens.next.id === \"(end)\") {\n      return;\n    }\n\n    var i = indent + (bias || 0);\n    if (state.tokens.next.from !== i) {\n      warning(\"W015\", state.tokens.next, state.tokens.next.value, i, state.tokens.next.from);\n    }\n  }\n\n  function nolinebreak(t) {\n    t = t || state.tokens.curr;\n    if (t.line !== state.tokens.next.line) {\n      warning(\"E022\", t, t.value);\n    }\n  }\n\n  function nobreakcomma(left, right) {\n    if (left.line !== right.line) {\n      if (!state.option.laxcomma) {\n        if (comma.first) {\n          warning(\"I001\");\n          comma.first = false;\n        }\n        warning(\"W014\", left, right.value);\n      }\n    } else if (!left.comment && left.character !== right.from && state.option.white) {\n      left.from += (left.character - left.from);\n      warning(\"W011\", left, left.value);\n    }\n  }\n\n  function comma(opts) {\n    opts = opts || {};\n\n    if (!opts.peek) {\n      nobreakcomma(state.tokens.curr, state.tokens.next);\n      advance(\",\");\n    } else {\n      nobreakcomma(state.tokens.prev, state.tokens.curr);\n    }\n\n    // TODO: This is a temporary solution to fight against false-positives in\n    // arrays and objects with trailing commas (see GH-363). The best solution\n    // would be to extract all whitespace rules out of parser.\n\n    if (state.tokens.next.value !== \"]\" && state.tokens.next.value !== \"}\") {\n      nonadjacent(state.tokens.curr, state.tokens.next);\n    }\n\n    if (state.tokens.next.identifier && !(opts.property && state.option.inES5())) {\n      // Keywords that cannot follow a comma operator.\n      switch (state.tokens.next.value) {\n      case \"break\":\n      case \"case\":\n      case \"catch\":\n      case \"continue\":\n      case \"default\":\n      case \"do\":\n      case \"else\":\n      case \"finally\":\n      case \"for\":\n      case \"if\":\n      case \"in\":\n      case \"instanceof\":\n      case \"return\":\n      case \"switch\":\n      case \"throw\":\n      case \"try\":\n      case \"var\":\n      case \"let\":\n      case \"while\":\n      case \"with\":\n        error(\"E024\", state.tokens.next, state.tokens.next.value);\n        return false;\n      }\n    }\n\n    if (state.tokens.next.type === \"(punctuator)\") {\n      switch (state.tokens.next.value) {\n      case \"}\":\n      case \"]\":\n      case \",\":\n        if (opts.allowTrailing) {\n          return true;\n        }\n\n        /* falls through */\n      case \")\":\n        var errorCode = \"E024\";\n        if (state.tokens.next.value === \")\") {\n          errorCode = \"E053\";\n        } else if (state.tokens.next.value === \",\") {\n          errorCode = \"E052\";\n        }\n        error(errorCode, state.tokens.next, state.tokens.next.value);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Functional constructors for making the symbols that will be inherited by\n  // tokens.\n\n  function symbol(s, p) {\n    var x = state.syntax[s];\n    if (!x || typeof x !== \"object\") {\n      state.syntax[s] = x = {\n        id: s,\n        lbp: p,\n        value: s\n      };\n    }\n    return x;\n  }\n\n  function delim(s) {\n    return symbol(s, 0);\n  }\n\n  function stmt(s, f) {\n    var x = delim(s);\n    x.identifier = x.reserved = true;\n    x.fud = f;\n    return x;\n  }\n\n  function blockstmt(s, f) {\n    var x = stmt(s, f);\n    x.block = true;\n    return x;\n  }\n\n  function reserveName(x) {\n    var c = x.id.charAt(0);\n    if ((c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\")) {\n      x.identifier = x.reserved = true;\n    }\n    return x;\n  }\n\n  function prefix(s, f) {\n    var x = symbol(s, 150);\n    reserveName(x);\n    x.nud = (typeof f === \"function\") ? f : function () {\n      this.right = expression(150);\n      this.arity = \"unary\";\n      if (this.id === \"++\" || this.id === \"--\") {\n        if (state.option.plusplus) {\n          warning(\"W016\", this, this.id);\n        } else if ((!this.right.identifier || isReserved(this.right)) &&\n            this.right.id !== \".\" && this.right.id !== \"[\") {\n          warning(\"W017\", this);\n        }\n      }\n      return this;\n    };\n    return x;\n  }\n\n  function type(s, f) {\n    var x = delim(s);\n    x.type = s;\n    x.nud = f;\n    return x;\n  }\n\n  function reserve(name, func) {\n    var x = type(name, func);\n    x.identifier = true;\n    x.reserved = true;\n    return x;\n  }\n\n  function FutureReservedWord(name, meta) {\n    var x = type(name, (meta && meta.nud) || function () {\n      return this;\n    });\n\n    meta = meta || {};\n    meta.isFutureReservedWord = true;\n\n    x.value = name;\n    x.identifier = true;\n    x.reserved = true;\n    x.meta = meta;\n\n    return x;\n  }\n\n  function reservevar(s, v) {\n    return reserve(s, function () {\n      if (typeof v === \"function\") {\n        v(this);\n      }\n      return this;\n    });\n  }\n\n  function infix(s, f, p, w) {\n    var x = symbol(s, p);\n    reserveName(x);\n    x.infix = true;\n    x.led = function (left) {\n      if (!w) {\n        nobreaknonadjacent(state.tokens.prev, state.tokens.curr);\n        nonadjacent(state.tokens.curr, state.tokens.next);\n      }\n      if (s === \"in\" && left.id === \"!\") {\n        warning(\"W018\", left, \"!\");\n      }\n      if (typeof f === \"function\") {\n        return f(left, this);\n      } else {\n        this.left = left;\n        this.right = expression(p);\n        return this;\n      }\n    };\n    return x;\n  }\n\n\n  function application(s) {\n    var x = symbol(s, 42);\n\n    x.led = function (left) {\n      if (!state.option.inESNext()) {\n        warning(\"W104\", state.tokens.curr, \"arrow function syntax (=>)\");\n      }\n\n      nobreaknonadjacent(state.tokens.prev, state.tokens.curr);\n      nonadjacent(state.tokens.curr, state.tokens.next);\n\n      this.left = left;\n      this.right = doFunction(undefined, undefined, false, left);\n      return this;\n    };\n    return x;\n  }\n\n  function relation(s, f) {\n    var x = symbol(s, 100);\n\n    x.led = function (left) {\n      nobreaknonadjacent(state.tokens.prev, state.tokens.curr);\n      nonadjacent(state.tokens.curr, state.tokens.next);\n      var right = expression(100);\n\n      if (isIdentifier(left, \"NaN\") || isIdentifier(right, \"NaN\")) {\n        warning(\"W019\", this);\n      } else if (f) {\n        f.apply(this, [left, right]);\n      }\n\n      if (!left || !right) {\n        quit(\"E041\", state.tokens.curr.line);\n      }\n\n      if (left.id === \"!\") {\n        warning(\"W018\", left, \"!\");\n      }\n\n      if (right.id === \"!\") {\n        warning(\"W018\", right, \"!\");\n      }\n\n      this.left = left;\n      this.right = right;\n      return this;\n    };\n    return x;\n  }\n\n  function isPoorRelation(node) {\n    return node &&\n        ((node.type === \"(number)\" && +node.value === 0) ||\n         (node.type === \"(string)\" && node.value === \"\") ||\n         (node.type === \"null\" && !state.option.eqnull) ||\n        node.type === \"true\" ||\n        node.type === \"false\" ||\n        node.type === \"undefined\");\n  }\n\n  function assignop(s, f, p) {\n    var x = infix(s, typeof f === \"function\" ? f : function (left, that) {\n      that.left = left;\n\n      if (left) {\n        if (predefined[left.value] === false &&\n            scope[left.value][\"(global)\"] === true) {\n          warning(\"W020\", left);\n        } else if (left[\"function\"]) {\n          warning(\"W021\", left, left.value);\n        }\n\n        if (funct[left.value] === \"const\") {\n          error(\"E013\", left, left.value);\n        }\n\n        if (left.id === \".\") {\n          if (!left.left) {\n            warning(\"E031\", that);\n          } else if (left.left.value === \"arguments\" && !state.directive[\"use strict\"]) {\n            warning(\"E031\", that);\n          }\n\n          that.right = expression(10);\n          return that;\n        } else if (left.id === \"[\") {\n          if (state.tokens.curr.left.first) {\n            state.tokens.curr.left.first.forEach(function (t) {\n              if (funct[t.value] === \"const\") {\n                error(\"E013\", t, t.value);\n              }\n            });\n          } else if (!left.left) {\n            warning(\"E031\", that);\n          } else if (left.left.value === \"arguments\" && !state.directive[\"use strict\"]) {\n            warning(\"E031\", that);\n          }\n          that.right = expression(10);\n          return that;\n        } else if (left.identifier && !isReserved(left)) {\n          if (funct[left.value] === \"exception\") {\n            warning(\"W022\", left);\n          }\n          that.right = expression(10);\n          return that;\n        }\n\n        if (left === state.syntax[\"function\"]) {\n          warning(\"W023\", state.tokens.curr);\n        }\n      }\n\n      error(\"E031\", that);\n    }, p);\n\n    x.exps = true;\n    x.assign = true;\n    return x;\n  }\n\n\n  function bitwise(s, f, p) {\n    var x = symbol(s, p);\n    reserveName(x);\n    x.led = (typeof f === \"function\") ? f : function (left) {\n      if (state.option.bitwise) {\n        warning(\"W016\", this, this.id);\n      }\n      this.left = left;\n      this.right = expression(p);\n      return this;\n    };\n    return x;\n  }\n\n\n  function bitwiseassignop(s) {\n    return assignop(s, function (left, that) {\n      if (state.option.bitwise) {\n        warning(\"W016\", that, that.id);\n      }\n      nonadjacent(state.tokens.prev, state.tokens.curr);\n      nonadjacent(state.tokens.curr, state.tokens.next);\n      if (left) {\n        if (left.id === \".\" || left.id === \"[\" ||\n            (left.identifier && !isReserved(left))) {\n          expression(10);\n          return that;\n        }\n        if (left === state.syntax[\"function\"]) {\n          warning(\"W023\", state.tokens.curr);\n        }\n        return that;\n      }\n      error(\"E031\", that);\n    }, 20);\n  }\n\n\n  function suffix(s) {\n    var x = symbol(s, 150);\n\n    x.led = function (left) {\n      if (state.option.plusplus) {\n        warning(\"W016\", this, this.id);\n      } else if ((!left.identifier || isReserved(left)) && left.id !== \".\" && left.id !== \"[\") {\n        warning(\"W017\", this);\n      }\n\n      this.left = left;\n      return this;\n    };\n    return x;\n  }\n\n  // fnparam means that this identifier is being defined as a function\n  // argument (see identifier())\n  // prop means that this identifier is that of an object property\n\n  function optionalidentifier(fnparam, prop) {\n    if (!state.tokens.next.identifier) {\n      return;\n    }\n\n    advance();\n\n    var curr = state.tokens.curr;\n    var val  = state.tokens.curr.value;\n\n    if (!isReserved(curr)) {\n      return val;\n    }\n\n    if (prop) {\n      if (state.option.inES5()) {\n        return val;\n      }\n    }\n\n    if (fnparam && val === \"undefined\") {\n      return val;\n    }\n\n    // Display an info message about reserved words as properties\n    // and ES5 but do it only once.\n    if (prop && !api.getCache(\"displayed:I002\")) {\n      api.setCache(\"displayed:I002\", true);\n      warning(\"I002\");\n    }\n\n    warning(\"W024\", state.tokens.curr, state.tokens.curr.id);\n    return val;\n  }\n\n  // fnparam means that this identifier is being defined as a function\n  // argument\n  // prop means that this identifier is that of an object property\n  function identifier(fnparam, prop) {\n    var i = optionalidentifier(fnparam, prop);\n    if (i) {\n      return i;\n    }\n    if (state.tokens.curr.id === \"function\" && state.tokens.next.id === \"(\") {\n      warning(\"W025\");\n    } else {\n      error(\"E030\", state.tokens.next, state.tokens.next.value);\n    }\n  }\n\n\n  function reachable(s) {\n    var i = 0, t;\n    if (state.tokens.next.id !== \";\" || noreach) {\n      return;\n    }\n    for (;;) {\n      do {\n        t = peek(i);\n        i += 1;\n      } while (t.id != \"(end)\" && t.id === \"(comment)\");\n\n      if (t.reach) {\n        return;\n      }\n      if (t.id !== \"(endline)\") {\n        if (t.id === \"function\") {\n          if (!state.option.latedef) {\n            break;\n          }\n\n          warning(\"W026\", t);\n          break;\n        }\n\n        warning(\"W027\", t, t.value, s);\n        break;\n      }\n    }\n  }\n\n\n  function statement(noindent) {\n    var values;\n    var i = indent, r, s = scope, t = state.tokens.next;\n\n    if (t.id === \";\") {\n      advance(\";\");\n      return;\n    }\n\n    // Is this a labelled statement?\n    var res = isReserved(t);\n\n    // We're being more tolerant here: if someone uses\n    // a FutureReservedWord as a label, we warn but proceed\n    // anyway.\n\n    if (res && t.meta && t.meta.isFutureReservedWord && peek().id === \":\") {\n      warning(\"W024\", t, t.id);\n      res = false;\n    }\n\n    // detect a destructuring assignment\n    if (_.has([\"[\", \"{\"], t.value)) {\n      if (lookupBlockType().isDestAssign) {\n        if (!state.option.inESNext()) {\n          warning(\"W104\", state.tokens.curr, \"destructuring expression\");\n        }\n        values = destructuringExpression();\n        values.forEach(function (tok) {\n          isundef(funct, \"W117\", tok.token, tok.id);\n        });\n        advance(\"=\");\n        destructuringExpressionMatch(values, expression(10, true));\n        advance(\";\");\n        return;\n      }\n    }\n    if (t.identifier && !res && peek().id === \":\") {\n      advance();\n      advance(\":\");\n      scope = Object.create(s);\n      addlabel(t.value, \"label\");\n\n      if (!state.tokens.next.labelled && state.tokens.next.value !== \"{\") {\n        warning(\"W028\", state.tokens.next, t.value, state.tokens.next.value);\n      }\n\n      state.tokens.next.label = t.value;\n      t = state.tokens.next;\n    }\n\n    // Is it a lonely block?\n\n    if (t.id === \"{\") {\n      block(true, true);\n      return;\n    }\n\n    // Parse the statement.\n\n    if (!noindent) {\n      indentation();\n    }\n    r = expression(0, true);\n\n    // Look for the final semicolon.\n\n    if (!t.block) {\n      if (!state.option.expr && (!r || !r.exps)) {\n        warning(\"W030\", state.tokens.curr);\n      } else if (state.option.nonew && r && r.left && r.id === \"(\" && r.left.id === \"new\") {\n        warning(\"W031\", t);\n      }\n\n      if (state.tokens.next.id !== \";\") {\n        if (!state.option.asi) {\n          // If this is the last statement in a block that ends on\n          // the same line *and* option lastsemic is on, ignore the warning.\n          // Otherwise, complain about missing semicolon.\n          if (!state.option.lastsemic || state.tokens.next.id !== \"}\" ||\n            state.tokens.next.line !== state.tokens.curr.line) {\n            warningAt(\"W033\", state.tokens.curr.line, state.tokens.curr.character);\n          }\n        }\n      } else {\n        adjacent(state.tokens.curr, state.tokens.next);\n        advance(\";\");\n        nonadjacent(state.tokens.curr, state.tokens.next);\n      }\n    }\n\n    // Restore the indentation.\n\n    indent = i;\n    scope = s;\n    return r;\n  }\n\n\n  function statements(startLine) {\n    var a = [], p;\n\n    while (!state.tokens.next.reach && state.tokens.next.id !== \"(end)\") {\n      if (state.tokens.next.id === \";\") {\n        p = peek();\n\n        if (!p || (p.id !== \"(\" && p.id !== \"[\")) {\n          warning(\"W032\");\n        }\n\n        advance(\";\");\n      } else {\n        a.push(statement(startLine === state.tokens.next.line));\n      }\n    }\n    return a;\n  }\n\n\n  /*\n   * read all directives\n   * recognizes a simple form of asi, but always\n   * warns, if it is used\n   */\n  function directives() {\n    var i, p, pn;\n\n    for (;;) {\n      if (state.tokens.next.id === \"(string)\") {\n        p = peek(0);\n        if (p.id === \"(endline)\") {\n          i = 1;\n          do {\n            pn = peek(i);\n            i = i + 1;\n          } while (pn.id === \"(endline)\");\n\n          if (pn.id !== \";\") {\n            if (pn.id !== \"(string)\" && pn.id !== \"(number)\" &&\n              pn.id !== \"(regexp)\" && pn.identifier !== true &&\n              pn.id !== \"}\") {\n              break;\n            }\n            warning(\"W033\", state.tokens.next);\n          } else {\n            p = pn;\n          }\n        } else if (p.id === \"}\") {\n          // Directive with no other statements, warn about missing semicolon\n          warning(\"W033\", p);\n        } else if (p.id !== \";\") {\n          break;\n        }\n\n        indentation();\n        advance();\n        if (state.directive[state.tokens.curr.value]) {\n          warning(\"W034\", state.tokens.curr, state.tokens.curr.value);\n        }\n\n        if (state.tokens.curr.value === \"use strict\") {\n          if (!state.option[\"(explicitNewcap)\"])\n            state.option.newcap = true;\n          state.option.undef = true;\n        }\n\n        // there's no directive negation, so always set to true\n        state.directive[state.tokens.curr.value] = true;\n\n        if (p.id === \";\") {\n          advance(\";\");\n        }\n        continue;\n      }\n      break;\n    }\n  }\n\n\n  /*\n   * Parses a single block. A block is a sequence of statements wrapped in\n   * braces.\n   *\n   * ordinary - true for everything but function bodies and try blocks.\n   * stmt   - true if block can be a single statement (e.g. in if/for/while).\n   * isfunc - true if block is a function body\n   */\n  function block(ordinary, stmt, isfunc, isfatarrow) {\n    var a,\n      b = inblock,\n      old_indent = indent,\n      m,\n      s = scope,\n      t,\n      line,\n      d;\n\n    inblock = ordinary;\n\n    if (!ordinary || !state.option.funcscope)\n      scope = Object.create(scope);\n\n    nonadjacent(state.tokens.curr, state.tokens.next);\n    t = state.tokens.next;\n\n    var metrics = funct[\"(metrics)\"];\n    metrics.nestedBlockDepth += 1;\n    metrics.verifyMaxNestedBlockDepthPerFunction();\n\n    if (state.tokens.next.id === \"{\") {\n      advance(\"{\");\n\n      // create a new block scope\n      funct[\"(blockscope)\"].stack();\n\n      line = state.tokens.curr.line;\n      if (state.tokens.next.id !== \"}\") {\n        indent += state.option.indent;\n        while (!ordinary && state.tokens.next.from > indent) {\n          indent += state.option.indent;\n        }\n\n        if (isfunc) {\n          m = {};\n          for (d in state.directive) {\n            if (_.has(state.directive, d)) {\n              m[d] = state.directive[d];\n            }\n          }\n          directives();\n\n          if (state.option.strict && funct[\"(context)\"][\"(global)\"]) {\n            if (!m[\"use strict\"] && !state.directive[\"use strict\"]) {\n              warning(\"E007\");\n            }\n          }\n        }\n\n        a = statements(line);\n\n        metrics.statementCount += a.length;\n\n        if (isfunc) {\n          state.directive = m;\n        }\n\n        indent -= state.option.indent;\n        if (line !== state.tokens.next.line) {\n          indentation();\n        }\n      } else if (line !== state.tokens.next.line) {\n        indentation();\n      }\n      advance(\"}\", t);\n\n      funct[\"(blockscope)\"].unstack();\n\n      indent = old_indent;\n    } else if (!ordinary) {\n      if (isfunc) {\n        m = {};\n        if (stmt && !isfatarrow && !state.option.inMoz(true)) {\n          error(\"W118\", state.tokens.curr, \"function closure expressions\");\n        }\n\n        if (!stmt) {\n          for (d in state.directive) {\n            if (_.has(state.directive, d)) {\n              m[d] = state.directive[d];\n            }\n          }\n        }\n        expression(10);\n\n        if (state.option.strict && funct[\"(context)\"][\"(global)\"]) {\n          if (!m[\"use strict\"] && !state.directive[\"use strict\"]) {\n            warning(\"E007\");\n          }\n        }\n      } else {\n        error(\"E021\", state.tokens.next, \"{\", state.tokens.next.value);\n      }\n    } else {\n\n      // check to avoid let declaration not within a block\n      funct[\"(nolet)\"] = true;\n\n      if (!stmt || state.option.curly) {\n        warning(\"W116\", state.tokens.next, \"{\", state.tokens.next.value);\n      }\n\n      noreach = true;\n      indent += state.option.indent;\n      // test indentation only if statement is in new line\n      a = [statement(state.tokens.next.line === state.tokens.curr.line)];\n      indent -= state.option.indent;\n      noreach = false;\n\n      delete funct[\"(nolet)\"];\n    }\n    funct[\"(verb)\"] = null;\n    if (!ordinary || !state.option.funcscope) scope = s;\n    inblock = b;\n    if (ordinary && state.option.noempty && (!a || a.length === 0)) {\n      warning(\"W035\");\n    }\n    metrics.nestedBlockDepth -= 1;\n    return a;\n  }\n\n\n  function countMember(m) {\n    if (membersOnly && typeof membersOnly[m] !== \"boolean\") {\n      warning(\"W036\", state.tokens.curr, m);\n    }\n    if (typeof member[m] === \"number\") {\n      member[m] += 1;\n    } else {\n      member[m] = 1;\n    }\n  }\n\n\n  function note_implied(tkn) {\n    var name = tkn.value, line = tkn.line, a = implied[name];\n    if (typeof a === \"function\") {\n      a = false;\n    }\n\n    if (!a) {\n      a = [line];\n      implied[name] = a;\n    } else if (a[a.length - 1] !== line) {\n      a.push(line);\n    }\n  }\n\n\n  // Build the syntax table by declaring the syntactic elements of the language.\n\n  type(\"(number)\", function () {\n    return this;\n  });\n\n  type(\"(string)\", function () {\n    return this;\n  });\n\n  state.syntax[\"(identifier)\"] = {\n    type: \"(identifier)\",\n    lbp: 0,\n    identifier: true,\n    nud: function () {\n      var v = this.value,\n        s = scope[v],\n        f;\n\n      if (typeof s === \"function\") {\n        // Protection against accidental inheritance.\n        s = undefined;\n      } else if (typeof s === \"boolean\") {\n        f = funct;\n        funct = functions[0];\n        addlabel(v, \"var\");\n        s = funct;\n        funct = f;\n      }\n      var block;\n      if (_.has(funct, \"(blockscope)\")) {\n        block = funct[\"(blockscope)\"].getlabel(v);\n      }\n\n      // The name is in scope and defined in the current function.\n      if (funct === s || block) {\n        // Change 'unused' to 'var', and reject labels.\n        // the name is in a block scope\n        switch (block ? block[v][\"(type)\"] : funct[v]) {\n        case \"unused\":\n          if (block) block[v][\"(type)\"] = \"var\";\n          else funct[v] = \"var\";\n          break;\n        case \"unction\":\n          if (block) block[v][\"(type)\"] = \"function\";\n          else funct[v] = \"function\";\n          this[\"function\"] = true;\n          break;\n        case \"function\":\n          this[\"function\"] = true;\n          break;\n        case \"label\":\n          warning(\"W037\", state.tokens.curr, v);\n          break;\n        }\n      } else if (funct[\"(global)\"]) {\n        // The name is not defined in the function.  If we are in the global\n        // scope, then we have an undefined variable.\n        //\n        // Operators typeof and delete do not raise runtime errors even if\n        // the base object of a reference is null so no need to display warning\n        // if we're inside of typeof or delete.\n\n        if (typeof predefined[v] !== \"boolean\") {\n          // Attempting to subscript a null reference will throw an\n          // error, even within the typeof and delete operators\n          if (!(anonname === \"typeof\" || anonname === \"delete\") ||\n            (state.tokens.next && (state.tokens.next.value === \".\" ||\n              state.tokens.next.value === \"[\"))) {\n\n            // if we're in a list comprehension, variables are declared\n            // locally and used before being defined. So we check\n            // the presence of the given variable in the comp array\n            // before declaring it undefined.\n\n            if (!funct[\"(comparray)\"].check(v)) {\n              isundef(funct, \"W117\", state.tokens.curr, v);\n            }\n          }\n        }\n\n        note_implied(state.tokens.curr);\n      } else {\n        // If the name is already defined in the current\n        // function, but not as outer, then there is a scope error.\n\n        switch (funct[v]) {\n        case \"closure\":\n        case \"function\":\n        case \"var\":\n        case \"unused\":\n          warning(\"W038\", state.tokens.curr, v);\n          break;\n        case \"label\":\n          warning(\"W037\", state.tokens.curr, v);\n          break;\n        case \"outer\":\n        case \"global\":\n          break;\n        default:\n          // If the name is defined in an outer function, make an outer entry,\n          // and if it was unused, make it var.\n          if (s === true) {\n            funct[v] = true;\n          } else if (s === null) {\n            warning(\"W039\", state.tokens.curr, v);\n            note_implied(state.tokens.curr);\n          } else if (typeof s !== \"object\") {\n            // Operators typeof and delete do not raise runtime errors even\n            // if the base object of a reference is null so no need to\n            //\n            // display warning if we're inside of typeof or delete.\n            // Attempting to subscript a null reference will throw an\n            // error, even within the typeof and delete operators\n            if (!(anonname === \"typeof\" || anonname === \"delete\") ||\n              (state.tokens.next &&\n                (state.tokens.next.value === \".\" || state.tokens.next.value === \"[\"))) {\n\n              isundef(funct, \"W117\", state.tokens.curr, v);\n            }\n            funct[v] = true;\n            note_implied(state.tokens.curr);\n          } else {\n            switch (s[v]) {\n            case \"function\":\n            case \"unction\":\n              this[\"function\"] = true;\n              s[v] = \"closure\";\n              funct[v] = s[\"(global)\"] ? \"global\" : \"outer\";\n              break;\n            case \"var\":\n            case \"unused\":\n              s[v] = \"closure\";\n              funct[v] = s[\"(global)\"] ? \"global\" : \"outer\";\n              break;\n            case \"closure\":\n              funct[v] = s[\"(global)\"] ? \"global\" : \"outer\";\n              break;\n            case \"label\":\n              warning(\"W037\", state.tokens.curr, v);\n            }\n          }\n        }\n      }\n      return this;\n    },\n    led: function () {\n      error(\"E033\", state.tokens.next, state.tokens.next.value);\n    }\n  };\n\n  type(\"(regexp)\", function () {\n    return this;\n  });\n\n  // ECMAScript parser\n\n  delim(\"(endline)\");\n  delim(\"(begin)\");\n  delim(\"(end)\").reach = true;\n  delim(\"(error)\").reach = true;\n  delim(\"}\").reach = true;\n  delim(\")\");\n  delim(\"]\");\n  delim(\"\\\"\").reach = true;\n  delim(\"'\").reach = true;\n  delim(\";\");\n  delim(\":\").reach = true;\n  delim(\"#\");\n\n  reserve(\"else\");\n  reserve(\"case\").reach = true;\n  reserve(\"catch\");\n  reserve(\"default\").reach = true;\n  reserve(\"finally\");\n  reservevar(\"arguments\", function (x) {\n    if (state.directive[\"use strict\"] && funct[\"(global)\"]) {\n      warning(\"E008\", x);\n    }\n  });\n  reservevar(\"eval\");\n  reservevar(\"false\");\n  reservevar(\"Infinity\");\n  reservevar(\"null\");\n  reservevar(\"this\", function (x) {\n    if (state.directive[\"use strict\"] && !state.option.validthis && ((funct[\"(statement)\"] &&\n        funct[\"(name)\"].charAt(0) > \"Z\") || funct[\"(global)\"])) {\n      warning(\"W040\", x);\n    }\n  });\n  reservevar(\"true\");\n  reservevar(\"undefined\");\n\n  assignop(\"=\", \"assign\", 20);\n  assignop(\"+=\", \"assignadd\", 20);\n  assignop(\"-=\", \"assignsub\", 20);\n  assignop(\"*=\", \"assignmult\", 20);\n  assignop(\"/=\", \"assigndiv\", 20).nud = function () {\n    error(\"E014\");\n  };\n  assignop(\"%=\", \"assignmod\", 20);\n\n  bitwiseassignop(\"&=\", \"assignbitand\", 20);\n  bitwiseassignop(\"|=\", \"assignbitor\", 20);\n  bitwiseassignop(\"^=\", \"assignbitxor\", 20);\n  bitwiseassignop(\"<<=\", \"assignshiftleft\", 20);\n  bitwiseassignop(\">>=\", \"assignshiftright\", 20);\n  bitwiseassignop(\">>>=\", \"assignshiftrightunsigned\", 20);\n  infix(\",\", function (left, that) {\n    var expr;\n    that.exprs = [left];\n    if (!comma({peek: true})) {\n      return that;\n    }\n    while (true) {\n      if (!(expr = expression(10)))  {\n        break;\n      }\n      that.exprs.push(expr);\n      if (state.tokens.next.value !== \",\" || !comma()) {\n        break;\n      }\n    }\n    return that;\n  }, 10, true);\n\n  infix(\"?\", function (left, that) {\n    increaseComplexityCount();\n    that.left = left;\n    that.right = expression(10);\n    advance(\":\");\n    that[\"else\"] = expression(10);\n    return that;\n  }, 30);\n\n  var orPrecendence = 40;\n  infix(\"||\", function (left, that) {\n    increaseComplexityCount();\n    that.left = left;\n    that.right = expression(orPrecendence);\n    return that;\n  }, orPrecendence);\n  infix(\"&&\", \"and\", 50);\n  bitwise(\"|\", \"bitor\", 70);\n  bitwise(\"^\", \"bitxor\", 80);\n  bitwise(\"&\", \"bitand\", 90);\n  relation(\"==\", function (left, right) {\n    var eqnull = state.option.eqnull && (left.value === \"null\" || right.value === \"null\");\n\n    if (!eqnull && state.option.eqeqeq)\n      warning(\"W116\", this, \"===\", \"==\");\n    else if (isPoorRelation(left))\n      warning(\"W041\", this, \"===\", left.value);\n    else if (isPoorRelation(right))\n      warning(\"W041\", this, \"===\", right.value);\n\n    return this;\n  });\n  relation(\"===\");\n  relation(\"!=\", function (left, right) {\n    var eqnull = state.option.eqnull &&\n        (left.value === \"null\" || right.value === \"null\");\n\n    if (!eqnull && state.option.eqeqeq) {\n      warning(\"W116\", this, \"!==\", \"!=\");\n    } else if (isPoorRelation(left)) {\n      warning(\"W041\", this, \"!==\", left.value);\n    } else if (isPoorRelation(right)) {\n      warning(\"W041\", this, \"!==\", right.value);\n    }\n    return this;\n  });\n  relation(\"!==\");\n  relation(\"<\");\n  relation(\">\");\n  relation(\"<=\");\n  relation(\">=\");\n  bitwise(\"<<\", \"shiftleft\", 120);\n  bitwise(\">>\", \"shiftright\", 120);\n  bitwise(\">>>\", \"shiftrightunsigned\", 120);\n  infix(\"in\", \"in\", 120);\n  infix(\"instanceof\", \"instanceof\", 120);\n  infix(\"+\", function (left, that) {\n    var right = expression(130);\n    if (left && right && left.id === \"(string)\" && right.id === \"(string)\") {\n      left.value += right.value;\n      left.character = right.character;\n      if (!state.option.scripturl && reg.javascriptURL.test(left.value)) {\n        warning(\"W050\", left);\n      }\n      return left;\n    }\n    that.left = left;\n    that.right = right;\n    return that;\n  }, 130);\n  prefix(\"+\", \"num\");\n  prefix(\"+++\", function () {\n    warning(\"W007\");\n    this.right = expression(150);\n    this.arity = \"unary\";\n    return this;\n  });\n  infix(\"+++\", function (left) {\n    warning(\"W007\");\n    this.left = left;\n    this.right = expression(130);\n    return this;\n  }, 130);\n  infix(\"-\", \"sub\", 130);\n  prefix(\"-\", \"neg\");\n  prefix(\"---\", function () {\n    warning(\"W006\");\n    this.right = expression(150);\n    this.arity = \"unary\";\n    return this;\n  });\n  infix(\"---\", function (left) {\n    warning(\"W006\");\n    this.left = left;\n    this.right = expression(130);\n    return this;\n  }, 130);\n  infix(\"*\", \"mult\", 140);\n  infix(\"/\", \"div\", 140);\n  infix(\"%\", \"mod\", 140);\n\n  suffix(\"++\", \"postinc\");\n  prefix(\"++\", \"preinc\");\n  state.syntax[\"++\"].exps = true;\n\n  suffix(\"--\", \"postdec\");\n  prefix(\"--\", \"predec\");\n  state.syntax[\"--\"].exps = true;\n  prefix(\"delete\", function () {\n    var p = expression(10);\n    if (!p || (p.id !== \".\" && p.id !== \"[\")) {\n      warning(\"W051\");\n    }\n    this.first = p;\n    return this;\n  }).exps = true;\n\n  prefix(\"~\", function () {\n    if (state.option.bitwise) {\n      warning(\"W052\", this, \"~\");\n    }\n    expression(150);\n    return this;\n  });\n\n  prefix(\"...\", function () {\n    if (!state.option.inESNext()) {\n      warning(\"W104\", this, \"spread/rest operator\");\n    }\n    if (!state.tokens.next.identifier) {\n      error(\"E030\", state.tokens.next, state.tokens.next.value);\n    }\n    expression(150);\n    return this;\n  });\n\n  prefix(\"!\", function () {\n    this.right = expression(150);\n    this.arity = \"unary\";\n\n    if (!this.right) { // '!' followed by nothing? Give up.\n      quit(\"E041\", this.line || 0);\n    }\n\n    if (bang[this.right.id] === true) {\n      warning(\"W018\", this, \"!\");\n    }\n    return this;\n  });\n\n  prefix(\"typeof\", \"typeof\");\n  prefix(\"new\", function () {\n    var c = expression(155), i;\n    if (c && c.id !== \"function\") {\n      if (c.identifier) {\n        c[\"new\"] = true;\n        switch (c.value) {\n        case \"Number\":\n        case \"String\":\n        case \"Boolean\":\n        case \"Math\":\n        case \"JSON\":\n          warning(\"W053\", state.tokens.prev, c.value);\n          break;\n        case \"Function\":\n          if (!state.option.evil) {\n            warning(\"W054\");\n          }\n          break;\n        case \"Date\":\n        case \"RegExp\":\n          break;\n        default:\n          if (c.id !== \"function\") {\n            i = c.value.substr(0, 1);\n            if (state.option.newcap && (i < \"A\" || i > \"Z\") && !_.has(global, c.value)) {\n              warning(\"W055\", state.tokens.curr);\n            }\n          }\n        }\n      } else {\n        if (c.id !== \".\" && c.id !== \"[\" && c.id !== \"(\") {\n          warning(\"W056\", state.tokens.curr);\n        }\n      }\n    } else {\n      if (!state.option.supernew)\n        warning(\"W057\", this);\n    }\n    adjacent(state.tokens.curr, state.tokens.next);\n    if (state.tokens.next.id !== \"(\" && !state.option.supernew) {\n      warning(\"W058\", state.tokens.curr, state.tokens.curr.value);\n    }\n    this.first = c;\n    return this;\n  });\n  state.syntax[\"new\"].exps = true;\n\n  prefix(\"void\").exps = true;\n\n  infix(\".\", function (left, that) {\n    adjacent(state.tokens.prev, state.tokens.curr);\n    nobreak();\n    var m = identifier(false, true);\n\n    if (typeof m === \"string\") {\n      countMember(m);\n    }\n\n    that.left = left;\n    that.right = m;\n\n    if (m && m === \"hasOwnProperty\" && state.tokens.next.value === \"=\") {\n      warning(\"W001\");\n    }\n\n    if (left && left.value === \"arguments\" && (m === \"callee\" || m === \"caller\")) {\n      if (state.option.noarg)\n        warning(\"W059\", left, m);\n      else if (state.directive[\"use strict\"])\n        error(\"E008\");\n    } else if (!state.option.evil && left && left.value === \"document\" &&\n        (m === \"write\" || m === \"writeln\")) {\n      warning(\"W060\", left);\n    }\n\n    if (!state.option.evil && (m === \"eval\" || m === \"execScript\")) {\n      warning(\"W061\");\n    }\n\n    return that;\n  }, 160, true);\n\n  infix(\"(\", function (left, that) {\n    if (state.tokens.prev.id !== \"}\" && state.tokens.prev.id !== \")\") {\n      nobreak(state.tokens.prev, state.tokens.curr);\n    }\n\n    nospace();\n    if (state.option.immed && left && !left.immed && left.id === \"function\") {\n      warning(\"W062\");\n    }\n\n    var n = 0;\n    var p = [];\n\n    if (left) {\n      if (left.type === \"(identifier)\") {\n        if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n          if (\"Number String Boolean Date Object\".indexOf(left.value) === -1) {\n            if (left.value === \"Math\") {\n              warning(\"W063\", left);\n            } else if (state.option.newcap) {\n              warning(\"W064\", left);\n            }\n          }\n        }\n      }\n    }\n\n    if (state.tokens.next.id !== \")\") {\n      for (;;) {\n        p[p.length] = expression(10);\n        n += 1;\n        if (state.tokens.next.id !== \",\") {\n          break;\n        }\n        comma();\n      }\n    }\n\n    advance(\")\");\n    nospace(state.tokens.prev, state.tokens.curr);\n\n    if (typeof left === \"object\") {\n      if (left.value === \"parseInt\" && n === 1) {\n        warning(\"W065\", state.tokens.curr);\n      }\n      if (!state.option.evil) {\n        if (left.value === \"eval\" || left.value === \"Function\" ||\n            left.value === \"execScript\") {\n          warning(\"W061\", left);\n\n          if (p[0] && [0].id === \"(string)\") {\n            addInternalSrc(left, p[0].value);\n          }\n        } else if (p[0] && p[0].id === \"(string)\" &&\n             (left.value === \"setTimeout\" ||\n            left.value === \"setInterval\")) {\n          warning(\"W066\", left);\n          addInternalSrc(left, p[0].value);\n\n        // window.setTimeout/setInterval\n        } else if (p[0] && p[0].id === \"(string)\" &&\n             left.value === \".\" &&\n             left.left.value === \"window\" &&\n             (left.right === \"setTimeout\" ||\n            left.right === \"setInterval\")) {\n          warning(\"W066\", left);\n          addInternalSrc(left, p[0].value);\n        }\n      }\n      if (!left.identifier && left.id !== \".\" && left.id !== \"[\" &&\n          left.id !== \"(\" && left.id !== \"&&\" && left.id !== \"||\" &&\n          left.id !== \"?\") {\n        warning(\"W067\", left);\n      }\n    }\n\n    that.left = left;\n    return that;\n  }, 155, true).exps = true;\n\n  prefix(\"(\", function () {\n    nospace();\n    var bracket, brackets = [];\n    var pn, pn1, i = 0;\n    var ret;\n\n    do {\n      pn = peek(i);\n      i += 1;\n      pn1 = peek(i);\n      i += 1;\n    } while (pn.value !== \")\" && pn1.value !== \"=>\" && pn1.value !== \";\" && pn1.type !== \"(end)\");\n\n    if (state.tokens.next.id === \"function\") {\n      state.tokens.next.immed = true;\n    }\n\n    var exprs = [];\n\n    if (state.tokens.next.id !== \")\") {\n      for (;;) {\n        if (pn1.value === \"=>\" && state.tokens.next.value === \"{\") {\n          bracket = state.tokens.next;\n          bracket.left = destructuringExpression();\n          brackets.push(bracket);\n          for (var t in bracket.left) {\n            exprs.push(bracket.left[t].token);\n          }\n        } else {\n          exprs.push(expression(10));\n        }\n        if (state.tokens.next.id !== \",\") {\n          break;\n        }\n        comma();\n      }\n    }\n\n    advance(\")\", this);\n    nospace(state.tokens.prev, state.tokens.curr);\n    if (state.option.immed && exprs[0] && exprs[0].id === \"function\") {\n      if (state.tokens.next.id !== \"(\" &&\n        (state.tokens.next.id !== \".\" || (peek().value !== \"call\" && peek().value !== \"apply\"))) {\n        warning(\"W068\", this);\n      }\n    }\n\n    if (state.tokens.next.value === \"=>\") {\n      return exprs;\n    }\n    if (!exprs.length) {\n      return;\n    }\n    if (exprs.length > 1) {\n      ret = Object.create(state.syntax[\",\"]);\n      ret.exprs = exprs;\n    } else {\n      ret = exprs[0];\n    }\n    if (ret) {\n      ret.paren = true;\n    }\n    return ret;\n  });\n\n  application(\"=>\");\n\n  infix(\"[\", function (left, that) {\n    nobreak(state.tokens.prev, state.tokens.curr);\n    nospace();\n    var e = expression(10), s;\n    if (e && e.type === \"(string)\") {\n      if (!state.option.evil && (e.value === \"eval\" || e.value === \"execScript\")) {\n        warning(\"W061\", that);\n      }\n\n      countMember(e.value);\n      if (!state.option.sub && reg.identifier.test(e.value)) {\n        s = state.syntax[e.value];\n        if (!s || !isReserved(s)) {\n          warning(\"W069\", state.tokens.prev, e.value);\n        }\n      }\n    }\n    advance(\"]\", that);\n\n    if (e && e.value === \"hasOwnProperty\" && state.tokens.next.value === \"=\") {\n      warning(\"W001\");\n    }\n\n    nospace(state.tokens.prev, state.tokens.curr);\n    that.left = left;\n    that.right = e;\n    return that;\n  }, 160, true);\n\n  function comprehensiveArrayExpression() {\n    var res = {};\n    res.exps = true;\n    funct[\"(comparray)\"].stack();\n\n    // Handle reversed for expressions, used in spidermonkey\n    var reversed = false;\n    if (state.tokens.next.value !== \"for\") {\n      reversed = true;\n      if (!state.option.inMoz(true)) {\n        warning(\"W116\", state.tokens.next, \"for\", state.tokens.next.value);\n      }\n      funct[\"(comparray)\"].setState(\"use\");\n      res.right = expression(10);\n    }\n\n    advance(\"for\");\n    if (state.tokens.next.value === \"each\") {\n      advance(\"each\");\n      if (!state.option.inMoz(true)) {\n        warning(\"W118\", state.tokens.curr, \"for each\");\n      }\n    }\n    advance(\"(\");\n    funct[\"(comparray)\"].setState(\"define\");\n    res.left = expression(130);\n    if (_.contains([\"in\", \"of\"], state.tokens.next.value)) {\n      advance();\n    } else {\n      error(\"E045\", state.tokens.curr);\n    }\n    funct[\"(comparray)\"].setState(\"generate\");\n    expression(10);\n\n    advance(\")\");\n    if (state.tokens.next.value === \"if\") {\n      advance(\"if\");\n      advance(\"(\");\n      funct[\"(comparray)\"].setState(\"filter\");\n      res.filter = expression(10);\n      advance(\")\");\n    }\n\n    if (!reversed) {\n      funct[\"(comparray)\"].setState(\"use\");\n      res.right = expression(10);\n    }\n\n    advance(\"]\");\n    funct[\"(comparray)\"].unstack();\n    return res;\n  }\n\n  prefix(\"[\", function () {\n    var blocktype = lookupBlockType(true);\n    if (blocktype.isCompArray) {\n      if (!state.option.inESNext()) {\n        warning(\"W119\", state.tokens.curr, \"array comprehension\");\n      }\n      return comprehensiveArrayExpression();\n    } else if (blocktype.isDestAssign && !state.option.inESNext()) {\n      warning(\"W104\", state.tokens.curr, \"destructuring assignment\");\n    }\n    var b = state.tokens.curr.line !== state.tokens.next.line;\n    this.first = [];\n    if (b) {\n      indent += state.option.indent;\n      if (state.tokens.next.from === indent + state.option.indent) {\n        indent += state.option.indent;\n      }\n    }\n    while (state.tokens.next.id !== \"(end)\") {\n      while (state.tokens.next.id === \",\") {\n        if (!state.option.inES5())\n          warning(\"W070\");\n        advance(\",\");\n      }\n      if (state.tokens.next.id === \"]\") {\n        break;\n      }\n      if (b && state.tokens.curr.line !== state.tokens.next.line) {\n        indentation();\n      }\n      this.first.push(expression(10));\n      if (state.tokens.next.id === \",\") {\n        comma({ allowTrailing: true });\n        if (state.tokens.next.id === \"]\" && !state.option.inES5(true)) {\n          warning(\"W070\", state.tokens.curr);\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (b) {\n      indent -= state.option.indent;\n      indentation();\n    }\n    advance(\"]\", this);\n    return this;\n  }, 160);\n\n\n  function property_name() {\n    var id = optionalidentifier(false, true);\n\n    if (!id) {\n      if (state.tokens.next.id === \"(string)\") {\n        id = state.tokens.next.value;\n        advance();\n      } else if (state.tokens.next.id === \"(number)\") {\n        id = state.tokens.next.value.toString();\n        advance();\n      }\n    }\n\n    if (id === \"hasOwnProperty\") {\n      warning(\"W001\");\n    }\n\n    return id;\n  }\n\n\n  function functionparams(parsed) {\n    var curr, next;\n    var params = [];\n    var ident;\n    var tokens = [];\n    var t;\n    var pastDefault = false;\n\n    if (parsed) {\n      if (parsed instanceof Array) {\n        for (var i in parsed) {\n          curr = parsed[i];\n          if (_.contains([\"{\", \"[\"], curr.id)) {\n            for (t in curr.left) {\n              t = tokens[t];\n              if (t.id) {\n                params.push(t.id);\n                addlabel(t.id, \"unused\", t.token);\n              }\n            }\n          } else if (curr.value === \"...\") {\n            if (!state.option.inESNext()) {\n              warning(\"W104\", curr, \"spread/rest operator\");\n            }\n            continue;\n          } else {\n            addlabel(curr.value, \"unused\", curr);\n          }\n        }\n        return params;\n      } else {\n        if (parsed.identifier === true) {\n          addlabel(parsed.value, \"unused\", parsed);\n          return [parsed];\n        }\n      }\n    }\n\n    next = state.tokens.next;\n\n    advance(\"(\");\n    nospace();\n\n    if (state.tokens.next.id === \")\") {\n      advance(\")\");\n      return;\n    }\n\n    for (;;) {\n      if (_.contains([\"{\", \"[\"], state.tokens.next.id)) {\n        tokens = destructuringExpression();\n        for (t in tokens) {\n          t = tokens[t];\n          if (t.id) {\n            params.push(t.id);\n            addlabel(t.id, \"unused\", t.token);\n          }\n        }\n      } else if (state.tokens.next.value === \"...\") {\n        if (!state.option.inESNext()) {\n          warning(\"W104\", state.tokens.next, \"spread/rest operator\");\n        }\n        advance(\"...\");\n        nospace();\n        ident = identifier(true);\n        params.push(ident);\n        addlabel(ident, \"unused\", state.tokens.curr);\n      } else {\n        ident = identifier(true);\n        params.push(ident);\n        addlabel(ident, \"unused\", state.tokens.curr);\n      }\n\n      // it is a syntax error to have a regular argument after a default argument\n      if (pastDefault) {\n        if (state.tokens.next.id !== \"=\") {\n          error(\"E051\", state.tokens.current);\n        }\n      }\n      if (state.tokens.next.id === \"=\") {\n        if (!state.option.inESNext()) {\n          warning(\"W119\", state.tokens.next, \"default parameters\");\n        }\n        advance(\"=\");\n        pastDefault = true;\n        expression(10);\n      }\n      if (state.tokens.next.id === \",\") {\n        comma();\n      } else {\n        advance(\")\", next);\n        nospace(state.tokens.prev, state.tokens.curr);\n        return params;\n      }\n    }\n  }\n\n\n  function doFunction(name, statement, generator, fatarrowparams) {\n    var f;\n    var oldOption = state.option;\n    var oldIgnored = state.ignored;\n    var oldScope  = scope;\n\n    state.option = Object.create(state.option);\n    state.ignored = Object.create(state.ignored);\n    scope  = Object.create(scope);\n\n    funct = {\n      \"(name)\"      : name || \"\\\"\" + anonname + \"\\\"\",\n      \"(line)\"      : state.tokens.next.line,\n      \"(character)\" : state.tokens.next.character,\n      \"(context)\"   : funct,\n      \"(breakage)\"  : 0,\n      \"(loopage)\"   : 0,\n      \"(metrics)\"   : createMetrics(state.tokens.next),\n      \"(scope)\"     : scope,\n      \"(statement)\" : statement,\n      \"(tokens)\"    : {},\n      \"(blockscope)\": funct[\"(blockscope)\"],\n      \"(comparray)\" : funct[\"(comparray)\"]\n    };\n\n    if (generator) {\n      funct[\"(generator)\"] = true;\n    }\n\n    f = funct;\n    state.tokens.curr.funct = funct;\n\n    functions.push(funct);\n\n    if (name) {\n      addlabel(name, \"function\");\n    }\n\n    funct[\"(params)\"] = functionparams(fatarrowparams);\n    funct[\"(metrics)\"].verifyMaxParametersPerFunction(funct[\"(params)\"]);\n\n    block(false, true, true, fatarrowparams ? true:false);\n\n    if (generator && funct[\"(generator)\"] !== \"yielded\") {\n      error(\"E047\", state.tokens.curr);\n    }\n\n    funct[\"(metrics)\"].verifyMaxStatementsPerFunction();\n    funct[\"(metrics)\"].verifyMaxComplexityPerFunction();\n    funct[\"(unusedOption)\"] = state.option.unused;\n\n    scope = oldScope;\n    state.option = oldOption;\n    state.ignored = oldIgnored;\n    funct[\"(last)\"] = state.tokens.curr.line;\n    funct[\"(lastcharacter)\"] = state.tokens.curr.character;\n    funct = funct[\"(context)\"];\n\n    return f;\n  }\n\n  function createMetrics(functionStartToken) {\n    return {\n      statementCount: 0,\n      nestedBlockDepth: -1,\n      ComplexityCount: 1,\n\n      verifyMaxStatementsPerFunction: function () {\n        if (state.option.maxstatements &&\n          this.statementCount > state.option.maxstatements) {\n          warning(\"W071\", functionStartToken, this.statementCount);\n        }\n      },\n\n      verifyMaxParametersPerFunction: function (params) {\n        params = params || [];\n\n        if (state.option.maxparams && params.length > state.option.maxparams) {\n          warning(\"W072\", functionStartToken, params.length);\n        }\n      },\n\n      verifyMaxNestedBlockDepthPerFunction: function () {\n        if (state.option.maxdepth &&\n          this.nestedBlockDepth > 0 &&\n          this.nestedBlockDepth === state.option.maxdepth + 1) {\n          warning(\"W073\", null, this.nestedBlockDepth);\n        }\n      },\n\n      verifyMaxComplexityPerFunction: function () {\n        var max = state.option.maxcomplexity;\n        var cc = this.ComplexityCount;\n        if (max && cc > max) {\n          warning(\"W074\", functionStartToken, cc);\n        }\n      }\n    };\n  }\n\n  function increaseComplexityCount() {\n    funct[\"(metrics)\"].ComplexityCount += 1;\n  }\n\n  // Parse assignments that were found instead of conditionals.\n  // For example: if (a = 1) { ... }\n\n  function checkCondAssignment(expr) {\n    var id, paren;\n    if (expr) {\n      id = expr.id;\n      paren = expr.paren;\n      if (id === \",\" && (expr = expr.exprs[expr.exprs.length - 1])) {\n        id = expr.id;\n        paren = paren || expr.paren;\n      }\n    }\n    switch (id) {\n    case \"=\":\n      if (!paren && !state.option.boss) {\n        warning(\"W121\");\n        break;\n      }\n    case \"+=\":\n    case \"-=\":\n    case \"*=\":\n    case \"%=\":\n    case \"&=\":\n    case \"|=\":\n    case \"^=\":\n    case \"/=\":\n      if (!paren && !state.option.boss) {\n        warning(\"W084\");\n      }\n    }\n  }\n\n\n  (function (x) {\n    x.nud = function (isclassdef) {\n      var b, f, i, p, t, g;\n      var props = {}; // All properties, including accessors\n      var tag = \"\";\n\n      function saveProperty(name, tkn) {\n        if (props[name] && _.has(props, name))\n          warning(\"W075\", state.tokens.next, i);\n        else\n          props[name] = {};\n\n        props[name].basic = true;\n        props[name].basictkn = tkn;\n      }\n\n      function saveSetter(name, tkn) {\n        if (props[name] && _.has(props, name)) {\n          if (props[name].basic || props[name].setter)\n            warning(\"W075\", state.tokens.next, i);\n        } else {\n          props[name] = {};\n        }\n\n        props[name].setter = true;\n        props[name].setterToken = tkn;\n      }\n\n      function saveGetter(name) {\n        if (props[name] && _.has(props, name)) {\n          if (props[name].basic || props[name].getter)\n            warning(\"W075\", state.tokens.next, i);\n        } else {\n          props[name] = {};\n        }\n\n        props[name].getter = true;\n        props[name].getterToken = state.tokens.curr;\n      }\n\n      b = state.tokens.curr.line !== state.tokens.next.line;\n      if (b) {\n        indent += state.option.indent;\n        if (state.tokens.next.from === indent + state.option.indent) {\n          indent += state.option.indent;\n        }\n      }\n\n      for (;;) {\n        if (state.tokens.next.id === \"}\") {\n          break;\n        }\n\n        if (b) {\n          indentation();\n        }\n\n        if (isclassdef && state.tokens.next.value === \"static\") {\n          advance(\"static\");\n          tag = \"static \";\n        }\n\n        if (state.tokens.next.value === \"get\" && peek().id !== \":\") {\n          advance(\"get\");\n\n          if (!state.option.inES5(!isclassdef)) {\n            error(\"E034\");\n          }\n\n          i = property_name();\n          if (!i) {\n            error(\"E035\");\n          }\n\n          // It is a Syntax Error if PropName of MethodDefinition is\n          // \"constructor\" and SpecialMethod of MethodDefinition is true.\n          if (isclassdef && i === \"constructor\") {\n            error(\"E049\", state.tokens.next, \"class getter method\", i);\n          }\n\n          saveGetter(tag + i);\n          t = state.tokens.next;\n          adjacent(state.tokens.curr, state.tokens.next);\n          f = doFunction();\n          p = f[\"(params)\"];\n\n          if (p) {\n            warning(\"W076\", t, p[0], i);\n          }\n\n          adjacent(state.tokens.curr, state.tokens.next);\n        } else if (state.tokens.next.value === \"set\" && peek().id !== \":\") {\n          advance(\"set\");\n\n          if (!state.option.inES5(!isclassdef)) {\n            error(\"E034\");\n          }\n\n          i = property_name();\n          if (!i) {\n            error(\"E035\");\n          }\n\n          // It is a Syntax Error if PropName of MethodDefinition is\n          // \"constructor\" and SpecialMethod of MethodDefinition is true.\n          if (isclassdef && i === \"constructor\") {\n            error(\"E049\", state.tokens.next, \"class setter method\", i);\n          }\n\n          saveSetter(tag + i, state.tokens.next);\n          t = state.tokens.next;\n          adjacent(state.tokens.curr, state.tokens.next);\n          f = doFunction();\n          p = f[\"(params)\"];\n\n          if (!p || p.length !== 1) {\n            warning(\"W077\", t, i);\n          }\n        } else {\n          g = false;\n          if (state.tokens.next.value === \"*\" && state.tokens.next.type === \"(punctuator)\") {\n            if (!state.option.inESNext()) {\n              warning(\"W104\", state.tokens.next, \"generator functions\");\n            }\n            advance(\"*\");\n            g = true;\n          }\n          i = property_name();\n          saveProperty(tag + i, state.tokens.next);\n\n          if (typeof i !== \"string\") {\n            break;\n          }\n\n          if (state.tokens.next.value === \"(\") {\n            if (!state.option.inESNext()) {\n              warning(\"W104\", state.tokens.curr, \"concise methods\");\n            }\n            doFunction(i, undefined, g);\n          } else if (!isclassdef) {\n            advance(\":\");\n            nonadjacent(state.tokens.curr, state.tokens.next);\n            expression(10);\n          }\n        }\n        // It is a Syntax Error if PropName of MethodDefinition is \"prototype\".\n        if (isclassdef && i === \"prototype\") {\n          error(\"E049\", state.tokens.next, \"class method\", i);\n        }\n\n        countMember(i);\n        if (isclassdef) {\n          tag = \"\";\n          continue;\n        }\n        if (state.tokens.next.id === \",\") {\n          comma({ allowTrailing: true, property: true });\n          if (state.tokens.next.id === \",\") {\n            warning(\"W070\", state.tokens.curr);\n          } else if (state.tokens.next.id === \"}\" && !state.option.inES5(true)) {\n            warning(\"W070\", state.tokens.curr);\n          }\n        } else {\n          break;\n        }\n      }\n      if (b) {\n        indent -= state.option.indent;\n        indentation();\n      }\n      advance(\"}\", this);\n\n      // Check for lonely setters if in the ES5 mode.\n      if (state.option.inES5()) {\n        for (var name in props) {\n          if (_.has(props, name) && props[name].setter && !props[name].getter) {\n            warning(\"W078\", props[name].setterToken);\n          }\n        }\n      }\n      return this;\n    };\n    x.fud = function () {\n      error(\"E036\", state.tokens.curr);\n    };\n  }(delim(\"{\")));\n\n  function destructuringExpression() {\n    var id, ids;\n    var identifiers = [];\n    if (!state.option.inESNext()) {\n      warning(\"W104\", state.tokens.curr, \"destructuring expression\");\n    }\n    var nextInnerDE = function () {\n      var ident;\n      if (_.contains([\"[\", \"{\"], state.tokens.next.value)) {\n        ids = destructuringExpression();\n        for (var id in ids) {\n          id = ids[id];\n          identifiers.push({ id: id.id, token: id.token });\n        }\n      } else if (state.tokens.next.value === \",\") {\n        identifiers.push({ id: null, token: state.tokens.curr });\n      } else {\n        ident = identifier();\n        if (ident)\n          identifiers.push({ id: ident, token: state.tokens.curr });\n      }\n    };\n    if (state.tokens.next.value === \"[\") {\n      advance(\"[\");\n      nextInnerDE();\n      while (state.tokens.next.value !== \"]\") {\n        advance(\",\");\n        nextInnerDE();\n      }\n      advance(\"]\");\n    } else if (state.tokens.next.value === \"{\") {\n      advance(\"{\");\n      id = identifier();\n      if (state.tokens.next.value === \":\") {\n        advance(\":\");\n        nextInnerDE();\n      } else {\n        identifiers.push({ id: id, token: state.tokens.curr });\n      }\n      while (state.tokens.next.value !== \"}\") {\n        advance(\",\");\n        id = identifier();\n        if (state.tokens.next.value === \":\") {\n          advance(\":\");\n          nextInnerDE();\n        } else {\n          identifiers.push({ id: id, token: state.tokens.curr });\n        }\n      }\n      advance(\"}\");\n    }\n    return identifiers;\n  }\n  function destructuringExpressionMatch(tokens, value) {\n    if (value.first) {\n      for (var i = 0; i < tokens.length && i < value.first.length; i++) {\n        var token = tokens[i];\n        var val = value.first[i];\n        if (token && val) {\n          token.first = val;\n        } else if (token && token.first && !val) {\n          warning(\"W080\", token.first, token.first.value);\n        } /* else {\n          XXX value is discarded: wouldn't it need a warning ?\n        } */\n      }\n    }\n  }\n\n  var conststatement = stmt(\"const\", function (prefix) {\n    var tokens, value;\n    // state variable to know if it is a lone identifier, or a destructuring statement.\n    var lone;\n\n    if (!state.option.inESNext()) {\n      warning(\"W104\", state.tokens.curr, \"const\");\n    }\n\n    this.first = [];\n    for (;;) {\n      var names = [];\n      nonadjacent(state.tokens.curr, state.tokens.next);\n      if (_.contains([\"{\", \"[\"], state.tokens.next.value)) {\n        tokens = destructuringExpression();\n        lone = false;\n      } else {\n        tokens = [ { id: identifier(), token: state.tokens.curr } ];\n        lone = true;\n      }\n      for (var t in tokens) {\n        t = tokens[t];\n        if (funct[t.id] === \"const\") {\n          warning(\"E011\", null, t.id);\n        }\n        if (funct[\"(global)\"] && predefined[t.id] === false) {\n          warning(\"W079\", t.token, t.id);\n        }\n        if (t.id) {\n          addlabel(t.id, \"const\");\n          names.push(t.token);\n        }\n      }\n      if (prefix) {\n        break;\n      }\n\n      this.first = this.first.concat(names);\n\n      if (state.tokens.next.id !== \"=\") {\n        warning(\"E012\", state.tokens.curr, state.tokens.curr.value);\n      }\n\n      if (state.tokens.next.id === \"=\") {\n        nonadjacent(state.tokens.curr, state.tokens.next);\n        advance(\"=\");\n        nonadjacent(state.tokens.curr, state.tokens.next);\n        if (state.tokens.next.id === \"undefined\") {\n          warning(\"W080\", state.tokens.prev, state.tokens.prev.value);\n        }\n        if (peek(0).id === \"=\" && state.tokens.next.identifier) {\n          warning(\"W120\", state.tokens.next, state.tokens.next.value);\n        }\n        value = expression(10);\n        if (lone) {\n          tokens[0].first = value;\n        } else {\n          destructuringExpressionMatch(names, value);\n        }\n      }\n\n      if (state.tokens.next.id !== \",\") {\n        break;\n      }\n      comma();\n    }\n    return this;\n  });\n  conststatement.exps = true;\n  var varstatement = stmt(\"var\", function (prefix) {\n    // JavaScript does not have block scope. It only has function scope. So,\n    // declaring a variable in a block can have unexpected consequences.\n    var tokens, lone, value;\n\n    if (funct[\"(onevar)\"] && state.option.onevar) {\n      warning(\"W081\");\n    } else if (!funct[\"(global)\"]) {\n      funct[\"(onevar)\"] = true;\n    }\n\n    this.first = [];\n    for (;;) {\n      var names = [];\n      nonadjacent(state.tokens.curr, state.tokens.next);\n      if (_.contains([\"{\", \"[\"], state.tokens.next.value)) {\n        tokens = destructuringExpression();\n        lone = false;\n      } else {\n        tokens = [ { id: identifier(), token: state.tokens.curr } ];\n        lone = true;\n      }\n      for (var t in tokens) {\n        t = tokens[t];\n        if (state.option.inESNext() && funct[t.id] === \"const\") {\n          warning(\"E011\", null, t.id);\n        }\n        if (funct[\"(global)\"] && predefined[t.id] === false) {\n          warning(\"W079\", t.token, t.id);\n        }\n        if (t.id) {\n          addlabel(t.id, \"unused\", t.token);\n          names.push(t.token);\n        }\n      }\n      if (prefix) {\n        break;\n      }\n\n      this.first = this.first.concat(names);\n\n      if (state.tokens.next.id === \"=\") {\n        nonadjacent(state.tokens.curr, state.tokens.next);\n        advance(\"=\");\n        nonadjacent(state.tokens.curr, state.tokens.next);\n        if (state.tokens.next.id === \"undefined\") {\n          warning(\"W080\", state.tokens.prev, state.tokens.prev.value);\n        }\n        if (peek(0).id === \"=\" && state.tokens.next.identifier) {\n          warning(\"W120\", state.tokens.next, state.tokens.next.value);\n        }\n        value = expression(10);\n        if (lone) {\n          tokens[0].first = value;\n        } else {\n          destructuringExpressionMatch(names, value);\n        }\n      }\n\n      if (state.tokens.next.id !== \",\") {\n        break;\n      }\n      comma();\n    }\n    return this;\n  });\n  varstatement.exps = true;\n  var letstatement = stmt(\"let\", function (prefix) {\n    var tokens, lone, value, letblock;\n\n    if (!state.option.inESNext()) {\n      warning(\"W104\", state.tokens.curr, \"let\");\n    }\n\n    if (state.tokens.next.value === \"(\") {\n      if (!state.option.inMoz(true)) {\n        warning(\"W118\", state.tokens.next, \"let block\");\n      }\n      advance(\"(\");\n      funct[\"(blockscope)\"].stack();\n      letblock = true;\n    } else if (funct[\"(nolet)\"]) {\n      error(\"E048\", state.tokens.curr);\n    }\n\n    if (funct[\"(onevar)\"] && state.option.onevar) {\n      warning(\"W081\");\n    } else if (!funct[\"(global)\"]) {\n      funct[\"(onevar)\"] = true;\n    }\n\n    this.first = [];\n    for (;;) {\n      var names = [];\n      nonadjacent(state.tokens.curr, state.tokens.next);\n      if (_.contains([\"{\", \"[\"], state.tokens.next.value)) {\n        tokens = destructuringExpression();\n        lone = false;\n      } else {\n        tokens = [ { id: identifier(), token: state.tokens.curr.value } ];\n        lone = true;\n      }\n      for (var t in tokens) {\n        t = tokens[t];\n        if (state.option.inESNext() && funct[t.id] === \"const\") {\n          warning(\"E011\", null, t.id);\n        }\n        if (funct[\"(global)\"] && predefined[t.id] === false) {\n          warning(\"W079\", t.token, t.id);\n        }\n        if (t.id && !funct[\"(nolet)\"]) {\n          addlabel(t.id, \"unused\", t.token, true);\n          names.push(t.token);\n        }\n      }\n      if (prefix) {\n        break;\n      }\n\n      this.first = this.first.concat(names);\n\n      if (state.tokens.next.id === \"=\") {\n        nonadjacent(state.tokens.curr, state.tokens.next);\n        advance(\"=\");\n        nonadjacent(state.tokens.curr, state.tokens.next);\n        if (state.tokens.next.id === \"undefined\") {\n          warning(\"W080\", state.tokens.prev, state.tokens.prev.value);\n        }\n        if (peek(0).id === \"=\" && state.tokens.next.identifier) {\n          warning(\"W120\", state.tokens.next, state.tokens.next.value);\n        }\n        value = expression(10);\n        if (lone) {\n          tokens[0].first = value;\n        } else {\n          destructuringExpressionMatch(names, value);\n        }\n      }\n\n      if (state.tokens.next.id !== \",\") {\n        break;\n      }\n      comma();\n    }\n    if (letblock) {\n      advance(\")\");\n      block(true, true);\n      this.block = true;\n      funct[\"(blockscope)\"].unstack();\n    }\n\n    return this;\n  });\n  letstatement.exps = true;\n\n  blockstmt(\"class\", function () {\n    return classdef.call(this, true);\n  });\n\n  function classdef(stmt) {\n    /*jshint validthis:true */\n    if (!state.option.inESNext()) {\n      warning(\"W104\", state.tokens.curr, \"class\");\n    }\n    if (stmt) {\n      // BindingIdentifier\n      this.name = identifier();\n      addlabel(this.name, \"unused\", state.tokens.curr);\n    } else if (state.tokens.next.identifier && state.tokens.next.value !== \"extends\") {\n      // BindingIdentifier(opt)\n      this.name = identifier();\n    }\n    classtail(this);\n    return this;\n  }\n\n  function classtail(c) {\n    var strictness = state.directive[\"use strict\"];\n\n    // ClassHeritage(opt)\n    if (state.tokens.next.value === \"extends\") {\n      advance(\"extends\");\n      c.heritage = expression(10);\n    }\n\n    // A ClassBody is always strict code.\n    state.directive[\"use strict\"] = true;\n    advance(\"{\");\n    // ClassBody(opt)\n    c.body = state.syntax[\"{\"].nud(true);\n    state.directive[\"use strict\"] = strictness;\n  }\n\n  blockstmt(\"function\", function () {\n    var generator = false;\n    if (state.tokens.next.value === \"*\") {\n      advance(\"*\");\n      if (state.option.inESNext(true)) {\n        generator = true;\n      } else {\n        warning(\"W119\", state.tokens.curr, \"function*\");\n      }\n    }\n    if (inblock) {\n      warning(\"W082\", state.tokens.curr);\n\n    }\n    var i = identifier();\n    if (funct[i] === \"const\") {\n      warning(\"E011\", null, i);\n    }\n    adjacent(state.tokens.curr, state.tokens.next);\n    addlabel(i, \"unction\", state.tokens.curr);\n\n    doFunction(i, { statement: true }, generator);\n    if (state.tokens.next.id === \"(\" && state.tokens.next.line === state.tokens.curr.line) {\n      error(\"E039\");\n    }\n    return this;\n  });\n\n  prefix(\"function\", function () {\n    var generator = false;\n    if (state.tokens.next.value === \"*\") {\n      if (!state.option.inESNext()) {\n        warning(\"W119\", state.tokens.curr, \"function*\");\n      }\n      advance(\"*\");\n      generator = true;\n    }\n    var i = optionalidentifier();\n    if (i || state.option.gcl) {\n      adjacent(state.tokens.curr, state.tokens.next);\n    } else {\n      nonadjacent(state.tokens.curr, state.tokens.next);\n    }\n    doFunction(i, undefined, generator);\n    if (!state.option.loopfunc && funct[\"(loopage)\"]) {\n      warning(\"W083\");\n    }\n    return this;\n  });\n\n  blockstmt(\"if\", function () {\n    var t = state.tokens.next;\n    increaseComplexityCount();\n    state.condition = true;\n    advance(\"(\");\n    nonadjacent(this, t);\n    nospace();\n    checkCondAssignment(expression(0));\n    advance(\")\", t);\n    state.condition = false;\n    nospace(state.tokens.prev, state.tokens.curr);\n    block(true, true);\n    if (state.tokens.next.id === \"else\") {\n      nonadjacent(state.tokens.curr, state.tokens.next);\n      advance(\"else\");\n      if (state.tokens.next.id === \"if\" || state.tokens.next.id === \"switch\") {\n        statement(true);\n      } else {\n        block(true, true);\n      }\n    }\n    return this;\n  });\n\n  blockstmt(\"try\", function () {\n    var b;\n\n    function doCatch() {\n      var oldScope = scope;\n      var e;\n\n      advance(\"catch\");\n      nonadjacent(state.tokens.curr, state.tokens.next);\n      advance(\"(\");\n\n      scope = Object.create(oldScope);\n\n      e = state.tokens.next.value;\n      if (state.tokens.next.type !== \"(identifier)\") {\n        e = null;\n        warning(\"E030\", state.tokens.next, e);\n      }\n\n      advance();\n\n      funct = {\n        \"(name)\"     : \"(catch)\",\n        \"(line)\"     : state.tokens.next.line,\n        \"(character)\": state.tokens.next.character,\n        \"(context)\"  : funct,\n        \"(breakage)\" : funct[\"(breakage)\"],\n        \"(loopage)\"  : funct[\"(loopage)\"],\n        \"(scope)\"    : scope,\n        \"(statement)\": false,\n        \"(metrics)\"  : createMetrics(state.tokens.next),\n        \"(catch)\"    : true,\n        \"(tokens)\"   : {},\n        \"(blockscope)\": funct[\"(blockscope)\"],\n        \"(comparray)\": funct[\"(comparray)\"]\n      };\n\n      if (e) {\n        addlabel(e, \"exception\");\n      }\n\n      if (state.tokens.next.value === \"if\") {\n        if (!state.option.inMoz(true)) {\n          warning(\"W118\", state.tokens.curr, \"catch filter\");\n        }\n        advance(\"if\");\n        expression(0);\n      }\n\n      advance(\")\");\n\n      state.tokens.curr.funct = funct;\n      functions.push(funct);\n\n      block(false);\n\n      scope = oldScope;\n\n      funct[\"(last)\"] = state.tokens.curr.line;\n      funct[\"(lastcharacter)\"] = state.tokens.curr.character;\n      funct = funct[\"(context)\"];\n    }\n\n    block(false);\n\n    while (state.tokens.next.id === \"catch\") {\n      increaseComplexityCount();\n      if (b && (!state.option.inMoz(true))) {\n        warning(\"W118\", state.tokens.next, \"multiple catch blocks\");\n      }\n      doCatch();\n      b = true;\n    }\n\n    if (state.tokens.next.id === \"finally\") {\n      advance(\"finally\");\n      block(false);\n      return;\n    }\n\n    if (!b) {\n      error(\"E021\", state.tokens.next, \"catch\", state.tokens.next.value);\n    }\n\n    return this;\n  });\n\n  blockstmt(\"while\", function () {\n    var t = state.tokens.next;\n    funct[\"(breakage)\"] += 1;\n    funct[\"(loopage)\"] += 1;\n    increaseComplexityCount();\n    advance(\"(\");\n    nonadjacent(this, t);\n    nospace();\n    checkCondAssignment(expression(0));\n    advance(\")\", t);\n    nospace(state.tokens.prev, state.tokens.curr);\n    block(true, true);\n    funct[\"(breakage)\"] -= 1;\n    funct[\"(loopage)\"] -= 1;\n    return this;\n  }).labelled = true;\n\n  blockstmt(\"with\", function () {\n    var t = state.tokens.next;\n    if (state.directive[\"use strict\"]) {\n      error(\"E010\", state.tokens.curr);\n    } else if (!state.option.withstmt) {\n      warning(\"W085\", state.tokens.curr);\n    }\n\n    advance(\"(\");\n    nonadjacent(this, t);\n    nospace();\n    expression(0);\n    advance(\")\", t);\n    nospace(state.tokens.prev, state.tokens.curr);\n    block(true, true);\n\n    return this;\n  });\n\n  blockstmt(\"switch\", function () {\n    var t = state.tokens.next,\n      g = false;\n    funct[\"(breakage)\"] += 1;\n    advance(\"(\");\n    nonadjacent(this, t);\n    nospace();\n    checkCondAssignment(expression(0));\n    advance(\")\", t);\n    nospace(state.tokens.prev, state.tokens.curr);\n    nonadjacent(state.tokens.curr, state.tokens.next);\n    t = state.tokens.next;\n    advance(\"{\");\n    nonadjacent(state.tokens.curr, state.tokens.next);\n    indent += state.option.indent;\n    this.cases = [];\n\n    for (;;) {\n      switch (state.tokens.next.id) {\n      case \"case\":\n        switch (funct[\"(verb)\"]) {\n        case \"yield\":\n        case \"break\":\n        case \"case\":\n        case \"continue\":\n        case \"return\":\n        case \"switch\":\n        case \"throw\":\n          break;\n        default:\n          // You can tell JSHint that you don't use break intentionally by\n          // adding a comment /* falls through */ on a line just before\n          // the next `case`.\n          if (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {\n            warning(\"W086\", state.tokens.curr, \"case\");\n          }\n        }\n        indentation(-state.option.indent);\n        advance(\"case\");\n        this.cases.push(expression(20));\n        increaseComplexityCount();\n        g = true;\n        advance(\":\");\n        funct[\"(verb)\"] = \"case\";\n        break;\n      case \"default\":\n        switch (funct[\"(verb)\"]) {\n        case \"yield\":\n        case \"break\":\n        case \"continue\":\n        case \"return\":\n        case \"throw\":\n          break;\n        default:\n          // Do not display a warning if 'default' is the first statement or if\n          // there is a special /* falls through */ comment.\n          if (this.cases.length) {\n            if (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {\n              warning(\"W086\", state.tokens.curr, \"default\");\n            }\n          }\n        }\n        indentation(-state.option.indent);\n        advance(\"default\");\n        g = true;\n        advance(\":\");\n        break;\n      case \"}\":\n        indent -= state.option.indent;\n        indentation();\n        advance(\"}\", t);\n        funct[\"(breakage)\"] -= 1;\n        funct[\"(verb)\"] = undefined;\n        return;\n      case \"(end)\":\n        error(\"E023\", state.tokens.next, \"}\");\n        return;\n      default:\n        if (g) {\n          switch (state.tokens.curr.id) {\n          case \",\":\n            error(\"E040\");\n            return;\n          case \":\":\n            g = false;\n            statements();\n            break;\n          default:\n            error(\"E025\", state.tokens.curr);\n            return;\n          }\n        } else {\n          if (state.tokens.curr.id === \":\") {\n            advance(\":\");\n            error(\"E024\", state.tokens.curr, \":\");\n            statements();\n          } else {\n            error(\"E021\", state.tokens.next, \"case\", state.tokens.next.value);\n            return;\n          }\n        }\n      }\n    }\n  }).labelled = true;\n\n  stmt(\"debugger\", function () {\n    if (!state.option.debug) {\n      warning(\"W087\", this);\n    }\n    return this;\n  }).exps = true;\n\n  (function () {\n    var x = stmt(\"do\", function () {\n      funct[\"(breakage)\"] += 1;\n      funct[\"(loopage)\"] += 1;\n      increaseComplexityCount();\n\n      this.first = block(true, true);\n      advance(\"while\");\n      var t = state.tokens.next;\n      nonadjacent(state.tokens.curr, t);\n      advance(\"(\");\n      nospace();\n      checkCondAssignment(expression(0));\n      advance(\")\", t);\n      nospace(state.tokens.prev, state.tokens.curr);\n      funct[\"(breakage)\"] -= 1;\n      funct[\"(loopage)\"] -= 1;\n      return this;\n    });\n    x.labelled = true;\n    x.exps = true;\n  }());\n\n  blockstmt(\"for\", function () {\n    var s, t = state.tokens.next;\n    var letscope = false;\n    var foreachtok = null;\n\n    if (t.value === \"each\") {\n      foreachtok = t;\n      advance(\"each\");\n      if (!state.option.inMoz(true)) {\n        warning(\"W118\", state.tokens.curr, \"for each\");\n      }\n    }\n\n    funct[\"(breakage)\"] += 1;\n    funct[\"(loopage)\"] += 1;\n    increaseComplexityCount();\n    advance(\"(\");\n    nonadjacent(this, t);\n    nospace();\n\n    // what kind of for(…) statement it is? for(…of…)? for(…in…)? for(…;…;…)?\n    var nextop; // contains the token of the \"in\" or \"of\" operator\n    var i = 0;\n    var inof = [\"in\", \"of\"];\n    do {\n      nextop = peek(i);\n      ++i;\n    } while (!_.contains(inof, nextop.value) && nextop.value !== \";\" &&\n          nextop.type !== \"(end)\");\n\n    // if we're in a for (… in|of …) statement\n    if (_.contains(inof, nextop.value)) {\n      if (!state.option.inESNext() && nextop.value === \"of\") {\n        error(\"W104\", nextop, \"for of\");\n      }\n      if (state.tokens.next.id === \"var\") {\n        advance(\"var\");\n        state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud, true);\n      } else if (state.tokens.next.id === \"let\") {\n        advance(\"let\");\n        // create a new block scope\n        letscope = true;\n        funct[\"(blockscope)\"].stack();\n        state.syntax[\"let\"].fud.call(state.syntax[\"let\"].fud, true);\n      } else {\n        switch (funct[state.tokens.next.value]) {\n        case \"unused\":\n          funct[state.tokens.next.value] = \"var\";\n          break;\n        case \"var\":\n          break;\n        default:\n          if (!funct[\"(blockscope)\"].getlabel(state.tokens.next.value))\n            warning(\"W088\", state.tokens.next, state.tokens.next.value);\n        }\n        advance();\n      }\n      advance(nextop.value);\n      expression(20);\n      advance(\")\", t);\n      s = block(true, true);\n      if (state.option.forin && s && (s.length > 1 || typeof s[0] !== \"object\" ||\n          s[0].value !== \"if\")) {\n        warning(\"W089\", this);\n      }\n      funct[\"(breakage)\"] -= 1;\n      funct[\"(loopage)\"] -= 1;\n    } else {\n      if (foreachtok) {\n        error(\"E045\", foreachtok);\n      }\n      if (state.tokens.next.id !== \";\") {\n        if (state.tokens.next.id === \"var\") {\n          advance(\"var\");\n          state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud);\n        } else if (state.tokens.next.id === \"let\") {\n          advance(\"let\");\n          // create a new block scope\n          letscope = true;\n          funct[\"(blockscope)\"].stack();\n          state.syntax[\"let\"].fud.call(state.syntax[\"let\"].fud);\n        } else {\n          for (;;) {\n            expression(0, \"for\");\n            if (state.tokens.next.id !== \",\") {\n              break;\n            }\n            comma();\n          }\n        }\n      }\n      nolinebreak(state.tokens.curr);\n      advance(\";\");\n      if (state.tokens.next.id !== \";\") {\n        checkCondAssignment(expression(0));\n      }\n      nolinebreak(state.tokens.curr);\n      advance(\";\");\n      if (state.tokens.next.id === \";\") {\n        error(\"E021\", state.tokens.next, \")\", \";\");\n      }\n      if (state.tokens.next.id !== \")\") {\n        for (;;) {\n          expression(0, \"for\");\n          if (state.tokens.next.id !== \",\") {\n            break;\n          }\n          comma();\n        }\n      }\n      advance(\")\", t);\n      nospace(state.tokens.prev, state.tokens.curr);\n      block(true, true);\n      funct[\"(breakage)\"] -= 1;\n      funct[\"(loopage)\"] -= 1;\n\n    }\n    // unstack loop blockscope\n    if (letscope) {\n      funct[\"(blockscope)\"].unstack();\n    }\n    return this;\n  }).labelled = true;\n\n\n  stmt(\"break\", function () {\n    var v = state.tokens.next.value;\n\n    if (funct[\"(breakage)\"] === 0)\n      warning(\"W052\", state.tokens.next, this.value);\n\n    if (!state.option.asi)\n      nolinebreak(this);\n\n    if (state.tokens.next.id !== \";\" && !state.tokens.next.reach) {\n      if (state.tokens.curr.line === state.tokens.next.line) {\n        if (funct[v] !== \"label\") {\n          warning(\"W090\", state.tokens.next, v);\n        } else if (scope[v] !== funct) {\n          warning(\"W091\", state.tokens.next, v);\n        }\n        this.first = state.tokens.next;\n        advance();\n      }\n    }\n    reachable(\"break\");\n    return this;\n  }).exps = true;\n\n\n  stmt(\"continue\", function () {\n    var v = state.tokens.next.value;\n\n    if (funct[\"(breakage)\"] === 0)\n      warning(\"W052\", state.tokens.next, this.value);\n\n    if (!state.option.asi)\n      nolinebreak(this);\n\n    if (state.tokens.next.id !== \";\" && !state.tokens.next.reach) {\n      if (state.tokens.curr.line === state.tokens.next.line) {\n        if (funct[v] !== \"label\") {\n          warning(\"W090\", state.tokens.next, v);\n        } else if (scope[v] !== funct) {\n          warning(\"W091\", state.tokens.next, v);\n        }\n        this.first = state.tokens.next;\n        advance();\n      }\n    } else if (!funct[\"(loopage)\"]) {\n      warning(\"W052\", state.tokens.next, this.value);\n    }\n    reachable(\"continue\");\n    return this;\n  }).exps = true;\n\n\n  stmt(\"return\", function () {\n    if (this.line === state.tokens.next.line) {\n      if (state.tokens.next.id === \"(regexp)\")\n        warning(\"W092\");\n\n      if (state.tokens.next.id !== \";\" && !state.tokens.next.reach) {\n        nonadjacent(state.tokens.curr, state.tokens.next);\n        this.first = expression(0);\n\n        if (this.first &&\n            this.first.type === \"(punctuator)\" && this.first.value === \"=\" && !state.option.boss) {\n          warningAt(\"W093\", this.first.line, this.first.character);\n        }\n      }\n    } else {\n      if (state.tokens.next.type === \"(punctuator)\" &&\n        [\"[\", \"{\", \"+\", \"-\"].indexOf(state.tokens.next.value) > -1) {\n        nolinebreak(this); // always warn (Line breaking error)\n      }\n    }\n    reachable(\"return\");\n    return this;\n  }).exps = true;\n\n  (function (x) {\n    x.exps = true;\n    x.lbp = 25;\n  }(prefix(\"yield\", function () {\n    var prev = state.tokens.prev;\n    if (state.option.inESNext(true) && !funct[\"(generator)\"]) {\n      error(\"E046\", state.tokens.curr, \"yield\");\n    } else if (!state.option.inESNext()) {\n      warning(\"W104\", state.tokens.curr, \"yield\");\n    }\n    funct[\"(generator)\"] = \"yielded\";\n    if (this.line === state.tokens.next.line || !state.option.inMoz(true)) {\n      if (state.tokens.next.id === \"(regexp)\")\n        warning(\"W092\");\n\n      if (state.tokens.next.id !== \";\" && !state.tokens.next.reach && state.tokens.next.nud) {\n        nobreaknonadjacent(state.tokens.curr, state.tokens.next);\n        this.first = expression(10);\n\n        if (this.first.type === \"(punctuator)\" && this.first.value === \"=\" && !state.option.boss) {\n          warningAt(\"W093\", this.first.line, this.first.character);\n        }\n      }\n\n      if (state.option.inMoz(true) && state.tokens.next.id !== \")\" &&\n          (prev.lbp > 30 || (!prev.assign && !isEndOfExpr()) || prev.id === \"yield\")) {\n        error(\"E050\", this);\n      }\n    } else if (!state.option.asi) {\n      nolinebreak(this); // always warn (Line breaking error)\n    }\n    return this;\n  })));\n\n\n  stmt(\"throw\", function () {\n    nolinebreak(this);\n    nonadjacent(state.tokens.curr, state.tokens.next);\n    this.first = expression(20);\n    reachable(\"throw\");\n    return this;\n  }).exps = true;\n\n  stmt(\"import\", function () {\n    if (!state.option.inESNext()) {\n      warning(\"W119\", state.tokens.curr, \"import\");\n    }\n\n    if (state.tokens.next.identifier) {\n      this.name = identifier();\n      addlabel(this.name, \"unused\", state.tokens.curr);\n    } else {\n      advance(\"{\");\n      for (;;) {\n        var importName;\n        if (state.tokens.next.type === \"default\") {\n          importName = \"default\";\n          advance(\"default\");\n        } else {\n          importName = identifier();\n        }\n        if (state.tokens.next.value === \"as\") {\n          advance(\"as\");\n          importName = identifier();\n        }\n        addlabel(importName, \"unused\", state.tokens.curr);\n\n        if (state.tokens.next.value === \",\") {\n          advance(\",\");\n        } else if (state.tokens.next.value === \"}\") {\n          advance(\"}\");\n          break;\n        } else {\n          error(\"E024\", state.tokens.next, state.tokens.next.value);\n          break;\n        }\n      }\n    }\n\n    advance(\"from\");\n    advance(\"(string)\");\n    return this;\n  }).exps = true;\n\n  stmt(\"export\", function () {\n    if (!state.option.inESNext()) {\n      warning(\"W119\", state.tokens.curr, \"export\");\n    }\n\n    if (state.tokens.next.type === \"default\") {\n      advance(\"default\");\n      if (state.tokens.next.id === \"function\" || state.tokens.next.id === \"class\") {\n        this.block = true;\n      }\n      this.exportee = expression(10);\n\n      return this;\n    }\n\n    if (state.tokens.next.value === \"{\") {\n      advance(\"{\");\n      for (;;) {\n        identifier();\n\n        if (state.tokens.next.value === \",\") {\n          advance(\",\");\n        } else if (state.tokens.next.value === \"}\") {\n          advance(\"}\");\n          break;\n        } else {\n          error(\"E024\", state.tokens.next, state.tokens.next.value);\n          break;\n        }\n      }\n      return this;\n    }\n\n    if (state.tokens.next.id === \"var\") {\n      advance(\"var\");\n      state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud);\n    } else if (state.tokens.next.id === \"let\") {\n      advance(\"let\");\n      state.syntax[\"let\"].fud.call(state.syntax[\"let\"].fud);\n    } else if (state.tokens.next.id === \"const\") {\n      advance(\"const\");\n      state.syntax[\"const\"].fud.call(state.syntax[\"const\"].fud);\n    } else if (state.tokens.next.id === \"function\") {\n      this.block = true;\n      advance(\"function\");\n      state.syntax[\"function\"].fud();\n    } else if (state.tokens.next.id === \"class\") {\n      this.block = true;\n      advance(\"class\");\n      state.syntax[\"class\"].fud();\n    } else {\n      error(\"E024\", state.tokens.next, state.tokens.next.value);\n    }\n\n    return this;\n  }).exps = true;\n\n  // Future Reserved Words\n\n  FutureReservedWord(\"abstract\");\n  FutureReservedWord(\"boolean\");\n  FutureReservedWord(\"byte\");\n  FutureReservedWord(\"char\");\n  FutureReservedWord(\"class\", { es5: true, nud: classdef });\n  FutureReservedWord(\"double\");\n  FutureReservedWord(\"enum\", { es5: true });\n  FutureReservedWord(\"export\", { es5: true });\n  FutureReservedWord(\"extends\", { es5: true });\n  FutureReservedWord(\"final\");\n  FutureReservedWord(\"float\");\n  FutureReservedWord(\"goto\");\n  FutureReservedWord(\"implements\", { es5: true, strictOnly: true });\n  FutureReservedWord(\"import\", { es5: true });\n  FutureReservedWord(\"int\");\n  FutureReservedWord(\"interface\", { es5: true, strictOnly: true });\n  FutureReservedWord(\"long\");\n  FutureReservedWord(\"native\");\n  FutureReservedWord(\"package\", { es5: true, strictOnly: true });\n  FutureReservedWord(\"private\", { es5: true, strictOnly: true });\n  FutureReservedWord(\"protected\", { es5: true, strictOnly: true });\n  FutureReservedWord(\"public\", { es5: true, strictOnly: true });\n  FutureReservedWord(\"short\");\n  FutureReservedWord(\"static\", { es5: true, strictOnly: true });\n  FutureReservedWord(\"super\", { es5: true });\n  FutureReservedWord(\"synchronized\");\n  FutureReservedWord(\"throws\");\n  FutureReservedWord(\"transient\");\n  FutureReservedWord(\"volatile\");\n\n  // this function is used to determine wether a squarebracket or a curlybracket\n  // expression is a comprehension array, destructuring assignment or a json value.\n\n  var lookupBlockType = function () {\n    var pn, pn1;\n    var i = -1;\n    var bracketStack = 0;\n    var ret = {};\n    if (_.contains([\"[\", \"{\"], state.tokens.curr.value))\n      bracketStack += 1;\n    do {\n      pn = (i === -1) ? state.tokens.next : peek(i);\n      pn1 = peek(i + 1);\n      i = i + 1;\n      if (_.contains([\"[\", \"{\"], pn.value)) {\n        bracketStack += 1;\n      } else if (_.contains([\"]\", \"}\"], pn.value)) {\n        bracketStack -= 1;\n      }\n      if (pn.identifier && pn.value === \"for\" && bracketStack === 1) {\n        ret.isCompArray = true;\n        ret.notJson = true;\n        break;\n      }\n      if (_.contains([\"}\", \"]\"], pn.value) && pn1.value === \"=\" && bracketStack === 0) {\n        ret.isDestAssign = true;\n        ret.notJson = true;\n        break;\n      }\n      if (pn.value === \";\") {\n        ret.isBlock = true;\n        ret.notJson = true;\n      }\n    } while (bracketStack > 0 && pn.id !== \"(end)\" && i < 15);\n    return ret;\n  };\n\n  // Check whether this function has been reached for a destructuring assign with undeclared values\n  function destructuringAssignOrJsonValue() {\n    // lookup for the assignment (esnext only)\n    // if it has semicolons, it is a block, so go parse it as a block\n    // or it's not a block, but there are assignments, check for undeclared variables\n\n    var block = lookupBlockType();\n    if (block.notJson) {\n      if (!state.option.inESNext() && block.isDestAssign) {\n        warning(\"W104\", state.tokens.curr, \"destructuring assignment\");\n      }\n      statements();\n    // otherwise parse json value\n    } else {\n      state.option.laxbreak = true;\n      state.jsonMode = true;\n      jsonValue();\n    }\n  }\n\n  // array comprehension parsing function\n  // parses and defines the three states of the list comprehension in order\n  // to avoid defining global variables, but keeping them to the list comprehension scope\n  // only. The order of the states are as follows:\n  //  * \"use\" which will be the returned iterative part of the list comprehension\n  //  * \"define\" which will define the variables local to the list comprehension\n  //  * \"filter\" which will help filter out values\n\n  var arrayComprehension = function () {\n    var CompArray = function () {\n      this.mode = \"use\";\n      this.variables = [];\n    };\n    var _carrays = [];\n    var _current;\n    function declare(v) {\n      var l = _current.variables.filter(function (elt) {\n        // if it has, change its undef state\n        if (elt.value === v) {\n          elt.undef = false;\n          return v;\n        }\n      }).length;\n      return l !== 0;\n    }\n    function use(v) {\n      var l = _current.variables.filter(function (elt) {\n        // and if it has been defined\n        if (elt.value === v && !elt.undef) {\n          if (elt.unused === true) {\n            elt.unused = false;\n          }\n          return v;\n        }\n      }).length;\n      // otherwise we warn about it\n      return (l === 0);\n    }\n    return {stack: function () {\n          _current = new CompArray();\n          _carrays.push(_current);\n        },\n        unstack: function () {\n          _current.variables.filter(function (v) {\n            if (v.unused)\n              warning(\"W098\", v.token, v.value);\n            if (v.undef)\n              isundef(v.funct, \"W117\", v.token, v.value);\n          });\n          _carrays.splice(-1, 1);\n          _current = _carrays[_carrays.length - 1];\n        },\n        setState: function (s) {\n          if (_.contains([\"use\", \"define\", \"generate\", \"filter\"], s))\n            _current.mode = s;\n        },\n        check: function (v) {\n          if (!_current) {\n            return;\n          }\n          // When we are in \"use\" state of the list comp, we enqueue that var\n          if (_current && _current.mode === \"use\") {\n            if (use(v)) {\n              _current.variables.push({\n                funct: funct,\n                token: state.tokens.curr,\n                value: v,\n                undef: true,\n                unused: false\n              });\n            }\n            return true;\n          // When we are in \"define\" state of the list comp,\n          } else if (_current && _current.mode === \"define\") {\n            // check if the variable has been used previously\n            if (!declare(v)) {\n              _current.variables.push({\n                funct: funct,\n                token: state.tokens.curr,\n                value: v,\n                undef: false,\n                unused: true\n              });\n            }\n            return true;\n          // When we are in the \"generate\" state of the list comp,\n          } else if (_current && _current.mode === \"generate\") {\n            isundef(funct, \"W117\", state.tokens.curr, v);\n            return true;\n          // When we are in \"filter\" state,\n          } else if (_current && _current.mode === \"filter\") {\n            // we check whether current variable has been declared\n            if (use(v)) {\n              // if not we warn about it\n              isundef(funct, \"W117\", state.tokens.curr, v);\n            }\n            return true;\n          }\n          return false;\n        }\n        };\n  };\n\n\n  // Parse JSON\n\n  function jsonValue() {\n\n    function jsonObject() {\n      var o = {}, t = state.tokens.next;\n      advance(\"{\");\n      if (state.tokens.next.id !== \"}\") {\n        for (;;) {\n          if (state.tokens.next.id === \"(end)\") {\n            error(\"E026\", state.tokens.next, t.line);\n          } else if (state.tokens.next.id === \"}\") {\n            warning(\"W094\", state.tokens.curr);\n            break;\n          } else if (state.tokens.next.id === \",\") {\n            error(\"E028\", state.tokens.next);\n          } else if (state.tokens.next.id !== \"(string)\") {\n            warning(\"W095\", state.tokens.next, state.tokens.next.value);\n          }\n          if (o[state.tokens.next.value] === true) {\n            warning(\"W075\", state.tokens.next, state.tokens.next.value);\n          } else if ((state.tokens.next.value === \"__proto__\" &&\n            !state.option.proto) || (state.tokens.next.value === \"__iterator__\" &&\n            !state.option.iterator)) {\n            warning(\"W096\", state.tokens.next, state.tokens.next.value);\n          } else {\n            o[state.tokens.next.value] = true;\n          }\n          advance();\n          advance(\":\");\n          jsonValue();\n          if (state.tokens.next.id !== \",\") {\n            break;\n          }\n          advance(\",\");\n        }\n      }\n      advance(\"}\");\n    }\n\n    function jsonArray() {\n      var t = state.tokens.next;\n      advance(\"[\");\n      if (state.tokens.next.id !== \"]\") {\n        for (;;) {\n          if (state.tokens.next.id === \"(end)\") {\n            error(\"E027\", state.tokens.next, t.line);\n          } else if (state.tokens.next.id === \"]\") {\n            warning(\"W094\", state.tokens.curr);\n            break;\n          } else if (state.tokens.next.id === \",\") {\n            error(\"E028\", state.tokens.next);\n          }\n          jsonValue();\n          if (state.tokens.next.id !== \",\") {\n            break;\n          }\n          advance(\",\");\n        }\n      }\n      advance(\"]\");\n    }\n\n    switch (state.tokens.next.id) {\n    case \"{\":\n      jsonObject();\n      break;\n    case \"[\":\n      jsonArray();\n      break;\n    case \"true\":\n    case \"false\":\n    case \"null\":\n    case \"(number)\":\n    case \"(string)\":\n      advance();\n      break;\n    case \"-\":\n      advance(\"-\");\n      if (state.tokens.curr.character !== state.tokens.next.from) {\n        warning(\"W011\", state.tokens.curr);\n      }\n      adjacent(state.tokens.curr, state.tokens.next);\n      advance(\"(number)\");\n      break;\n    default:\n      error(\"E003\", state.tokens.next);\n    }\n  }\n\n  var blockScope = function () {\n    var _current = {};\n    var _variables = [_current];\n\n    function _checkBlockLabels() {\n      for (var t in _current) {\n        if (_current[t][\"(type)\"] === \"unused\") {\n          if (state.option.unused) {\n            var tkn = _current[t][\"(token)\"];\n            var line = tkn.line;\n            var chr  = tkn.character;\n            warningAt(\"W098\", line, chr, t);\n          }\n        }\n      }\n    }\n\n    return {\n      stack: function () {\n        _current = {};\n        _variables.push(_current);\n      },\n\n      unstack: function () {\n        _checkBlockLabels();\n        _variables.splice(_variables.length - 1, 1);\n        _current = _variables[_variables.length - 1];\n      },\n\n      getlabel: function (l) {\n        for (var i = _variables.length - 1 ; i >= 0; --i) {\n          if (_.has(_variables[i], l)) {\n            return _variables[i];\n          }\n        }\n      },\n\n      current: {\n        has: function (t) {\n          return _.has(_current, t);\n        },\n        add: function (t, type, tok) {\n          _current[t] = { \"(type)\" : type,\n                  \"(token)\": tok };\n        }\n      }\n    };\n  };\n\n  // The actual JSHINT function itself.\n  var itself = function (s, o, g) {\n    var i, k, x;\n    var optionKeys;\n    var newOptionObj = {};\n    var newIgnoredObj = {};\n\n    state.reset();\n\n    if (o && o.scope) {\n      JSHINT.scope = o.scope;\n    } else {\n      JSHINT.errors = [];\n      JSHINT.undefs = [];\n      JSHINT.internals = [];\n      JSHINT.blacklist = {};\n      JSHINT.scope = \"(main)\";\n    }\n\n    predefined = Object.create(null);\n    combine(predefined, vars.ecmaIdentifiers);\n    combine(predefined, vars.reservedVars);\n\n    combine(predefined, g || {});\n\n    declared = Object.create(null);\n    exported = Object.create(null);\n\n    function each(obj, cb) {\n      if (!obj)\n        return;\n\n      if (!Array.isArray(obj) && typeof obj === \"object\")\n        obj = Object.keys(obj);\n\n      obj.forEach(cb);\n    }\n\n    if (o) {\n      each(o.predef || null, function (item) {\n        var slice, prop;\n\n        if (item[0] === \"-\") {\n          slice = item.slice(1);\n          JSHINT.blacklist[slice] = slice;\n        } else {\n          prop = Object.getOwnPropertyDescriptor(o.predef, item);\n          predefined[item] = prop ? prop.value : false;\n        }\n      });\n\n      each(o.exported || null, function (item) {\n        exported[item] = true;\n      });\n\n      delete o.predef;\n      delete o.exported;\n\n      optionKeys = Object.keys(o);\n      for (x = 0; x < optionKeys.length; x++) {\n        if (/^-W\\d{3}$/g.test(optionKeys[x])) {\n          newIgnoredObj[optionKeys[x].slice(1)] = true;\n        } else {\n          newOptionObj[optionKeys[x]] = o[optionKeys[x]];\n\n          if (optionKeys[x] === \"newcap\" && o[optionKeys[x]] === false)\n            newOptionObj[\"(explicitNewcap)\"] = true;\n\n          if (optionKeys[x] === \"indent\")\n            newOptionObj[\"(explicitIndent)\"] = o[optionKeys[x]] === false ? false : true;\n        }\n      }\n    }\n\n    state.option = newOptionObj;\n    state.ignored = newIgnoredObj;\n\n    state.option.indent = state.option.indent || 4;\n    state.option.maxerr = state.option.maxerr || 50;\n\n    indent = 1;\n    global = Object.create(predefined);\n    scope = global;\n    funct = {\n      \"(global)\":   true,\n      \"(name)\":   \"(global)\",\n      \"(scope)\":    scope,\n      \"(breakage)\": 0,\n      \"(loopage)\":  0,\n      \"(tokens)\":   {},\n      \"(metrics)\":   createMetrics(state.tokens.next),\n      \"(blockscope)\": blockScope(),\n      \"(comparray)\": arrayComprehension()\n    };\n    functions = [funct];\n    urls = [];\n    stack = null;\n    member = {};\n    membersOnly = null;\n    implied = {};\n    inblock = false;\n    lookahead = [];\n    warnings = 0;\n    unuseds = [];\n\n    if (!isString(s) && !Array.isArray(s)) {\n      errorAt(\"E004\", 0);\n      return false;\n    }\n\n    api = {\n      get isJSON() {\n        return state.jsonMode;\n      },\n\n      getOption: function (name) {\n        return state.option[name] || null;\n      },\n\n      getCache: function (name) {\n        return state.cache[name];\n      },\n\n      setCache: function (name, value) {\n        state.cache[name] = value;\n      },\n\n      warn: function (code, data) {\n        warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));\n      },\n\n      on: function (names, listener) {\n        names.split(\" \").forEach(function (name) {\n          emitter.on(name, listener);\n        }.bind(this));\n      }\n    };\n\n    emitter.removeAllListeners();\n    (extraModules || []).forEach(function (func) {\n      func(api);\n    });\n\n    state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[\"(begin)\"];\n\n    lex = new Lexer(s);\n\n    lex.on(\"warning\", function (ev) {\n      warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));\n    });\n\n    lex.on(\"error\", function (ev) {\n      errorAt.apply(null, [ ev.code, ev.line, ev.character ].concat(ev.data));\n    });\n\n    lex.on(\"fatal\", function (ev) {\n      quit(\"E041\", ev.line, ev.from);\n    });\n\n    lex.on(\"Identifier\", function (ev) {\n      emitter.emit(\"Identifier\", ev);\n    });\n\n    lex.on(\"String\", function (ev) {\n      emitter.emit(\"String\", ev);\n    });\n\n    lex.on(\"Number\", function (ev) {\n      emitter.emit(\"Number\", ev);\n    });\n\n    lex.start();\n\n    // Check options\n    for (var name in o) {\n      if (_.has(o, name)) {\n        checkOption(name, state.tokens.curr);\n      }\n    }\n\n    assume();\n\n    // combine the passed globals after we've assumed all our options\n    combine(predefined, g || {});\n\n    //reset values\n    comma.first = true;\n\n    try {\n      advance();\n      switch (state.tokens.next.id) {\n      case \"{\":\n      case \"[\":\n        destructuringAssignOrJsonValue();\n        break;\n      default:\n        directives();\n\n        if (state.directive[\"use strict\"]) {\n          if (!state.option.globalstrict && !(state.option.node || state.option.phantom)) {\n            warning(\"W097\", state.tokens.prev);\n          }\n        }\n\n        statements();\n      }\n      advance((state.tokens.next && state.tokens.next.value !== \".\")  ? \"(end)\" : undefined);\n      funct[\"(blockscope)\"].unstack();\n\n      var markDefined = function (name, context) {\n        do {\n          if (typeof context[name] === \"string\") {\n            // JSHINT marks unused variables as 'unused' and\n            // unused function declaration as 'unction'. This\n            // code changes such instances back 'var' and\n            // 'closure' so that the code in JSHINT.data()\n            // doesn't think they're unused.\n\n            if (context[name] === \"unused\")\n              context[name] = \"var\";\n            else if (context[name] === \"unction\")\n              context[name] = \"closure\";\n\n            return true;\n          }\n\n          context = context[\"(context)\"];\n        } while (context);\n\n        return false;\n      };\n\n      var clearImplied = function (name, line) {\n        if (!implied[name])\n          return;\n\n        var newImplied = [];\n        for (var i = 0; i < implied[name].length; i += 1) {\n          if (implied[name][i] !== line)\n            newImplied.push(implied[name][i]);\n        }\n\n        if (newImplied.length === 0)\n          delete implied[name];\n        else\n          implied[name] = newImplied;\n      };\n\n      var warnUnused = function (name, tkn, type, unused_opt) {\n        var line = tkn.line;\n        var chr  = tkn.character;\n\n        if (unused_opt === undefined) {\n          unused_opt = state.option.unused;\n        }\n\n        if (unused_opt === true) {\n          unused_opt = \"last-param\";\n        }\n\n        var warnable_types = {\n          \"vars\": [\"var\"],\n          \"last-param\": [\"var\", \"param\"],\n          \"strict\": [\"var\", \"param\", \"last-param\"]\n        };\n\n        if (unused_opt) {\n          if (warnable_types[unused_opt] && warnable_types[unused_opt].indexOf(type) !== -1) {\n            warningAt(\"W098\", line, chr, name);\n          }\n        }\n\n        unuseds.push({\n          name: name,\n          line: line,\n          character: chr\n        });\n      };\n\n      var checkUnused = function (func, key) {\n        var type = func[key];\n        var tkn = func[\"(tokens)\"][key];\n\n        if (key.charAt(0) === \"(\")\n          return;\n\n        if (type !== \"unused\" && type !== \"unction\")\n          return;\n\n        // Params are checked separately from other variables.\n        if (func[\"(params)\"] && func[\"(params)\"].indexOf(key) !== -1)\n          return;\n\n        // Variable is in global scope and defined as exported.\n        if (func[\"(global)\"] && _.has(exported, key)) {\n          return;\n        }\n\n        warnUnused(key, tkn, \"var\");\n      };\n\n      // Check queued 'x is not defined' instances to see if they're still undefined.\n      for (i = 0; i < JSHINT.undefs.length; i += 1) {\n        k = JSHINT.undefs[i].slice(0);\n\n        if (markDefined(k[2].value, k[0])) {\n          clearImplied(k[2].value, k[2].line);\n        } else if (state.option.undef) {\n          warning.apply(warning, k.slice(1));\n        }\n      }\n\n      functions.forEach(function (func) {\n        if (func[\"(unusedOption)\"] === false) {\n          return;\n        }\n\n        for (var key in func) {\n          if (_.has(func, key)) {\n            checkUnused(func, key);\n          }\n        }\n\n        if (!func[\"(params)\"])\n          return;\n\n        var params = func[\"(params)\"].slice();\n        var param  = params.pop();\n        var type, unused_opt;\n\n        while (param) {\n          type = func[param];\n          unused_opt = func[\"(unusedOption)\"] || state.option.unused;\n          unused_opt = unused_opt === true ? \"last-param\" : unused_opt;\n\n          // 'undefined' is a special case for (function (window, undefined) { ... })();\n          // patterns.\n\n          if (param === \"undefined\")\n            return;\n\n          if (type === \"unused\" || type === \"unction\") {\n            warnUnused(param, func[\"(tokens)\"][param], \"param\", func[\"(unusedOption)\"]);\n          } else if (unused_opt === \"last-param\") {\n            return;\n          }\n\n          param = params.pop();\n        }\n      });\n\n      for (var key in declared) {\n        if (_.has(declared, key) && !_.has(global, key)) {\n          warnUnused(key, declared[key], \"var\");\n        }\n      }\n\n    } catch (err) {\n      if (err && err.name === \"JSHintError\") {\n        var nt = state.tokens.next || {};\n        JSHINT.errors.push({\n          scope     : \"(main)\",\n          raw       : err.raw,\n          code      : err.code,\n          reason    : err.message,\n          line      : err.line || nt.line,\n          character : err.character || nt.from\n        }, null);\n      } else {\n        throw err;\n      }\n    }\n\n    // Loop over the listed \"internals\", and check them as well.\n\n    if (JSHINT.scope === \"(main)\") {\n      o = o || {};\n\n      for (i = 0; i < JSHINT.internals.length; i += 1) {\n        k = JSHINT.internals[i];\n        o.scope = k.elem;\n        itself(k.value, o, g);\n      }\n    }\n\n    return JSHINT.errors.length === 0;\n  };\n\n  // Modules.\n  itself.addModule = function (func) {\n    extraModules.push(func);\n  };\n\n  itself.addModule(style.register);\n\n  // Data summary.\n  itself.data = function () {\n    var data = {\n      functions: [],\n      options: state.option\n    };\n\n    var implieds = [];\n    var members = [];\n    var fu, f, i, j, n, globals;\n\n    if (itself.errors.length) {\n      data.errors = itself.errors;\n    }\n\n    if (state.jsonMode) {\n      data.json = true;\n    }\n\n    for (n in implied) {\n      if (_.has(implied, n)) {\n        implieds.push({\n          name: n,\n          line: implied[n]\n        });\n      }\n    }\n\n    if (implieds.length > 0) {\n      data.implieds = implieds;\n    }\n\n    if (urls.length > 0) {\n      data.urls = urls;\n    }\n\n    globals = Object.keys(scope);\n    if (globals.length > 0) {\n      data.globals = globals;\n    }\n\n    for (i = 1; i < functions.length; i += 1) {\n      f = functions[i];\n      fu = {};\n\n      for (j = 0; j < functionicity.length; j += 1) {\n        fu[functionicity[j]] = [];\n      }\n\n      for (j = 0; j < functionicity.length; j += 1) {\n        if (fu[functionicity[j]].length === 0) {\n          delete fu[functionicity[j]];\n        }\n      }\n\n      fu.name = f[\"(name)\"];\n      fu.param = f[\"(params)\"];\n      fu.line = f[\"(line)\"];\n      fu.character = f[\"(character)\"];\n      fu.last = f[\"(last)\"];\n      fu.lastcharacter = f[\"(lastcharacter)\"];\n\n      fu.metrics = {\n        complexity: f[\"(metrics)\"].ComplexityCount,\n        parameters: (f[\"(params)\"] || []).length,\n        statements: f[\"(metrics)\"].statementCount\n      };\n\n      data.functions.push(fu);\n    }\n\n    if (unuseds.length > 0) {\n      data.unused = unuseds;\n    }\n\n    members = [];\n    for (n in member) {\n      if (typeof member[n] === \"number\") {\n        data.member = member;\n        break;\n      }\n    }\n\n    return data;\n  };\n\n  itself.jshint = itself;\n\n  return itself;\n}());\n\n// Make JSHINT a Node module, if possible.\nif (typeof exports === \"object\" && exports) {\n  exports.JSHINT = JSHINT;\n}\n\n})()\n},{\"events\":2,\"./vars.js\":3,\"./messages.js\":4,\"./lex.js\":8,\"./reg.js\":5,\"./state.js\":6,\"./style.js\":7,\"console-browserify\":9}],9:[function(require,module,exports){\n(function(global){/*global window, global*/\nvar util = require(\"util\")\nvar assert = require(\"assert\")\n\nvar slice = Array.prototype.slice\nvar console\nvar times = {}\n\nif (typeof global !== \"undefined\" && global.console) {\n    console = global.console\n} else if (typeof window !== \"undefined\" && window.console) {\n    console = window.console\n} else {\n    console = window.console = {}\n}\n\nvar functions = [\n    [log, \"log\"]\n    , [info, \"info\"]\n    , [warn, \"warn\"]\n    , [error, \"error\"]\n    , [time, \"time\"]\n    , [timeEnd, \"timeEnd\"]\n    , [trace, \"trace\"]\n    , [dir, \"dir\"]\n    , [assert, \"assert\"]\n]\n\nfor (var i = 0; i < functions.length; i++) {\n    var tuple = functions[i]\n    var f = tuple[0]\n    var name = tuple[1]\n\n    if (!console[name]) {\n        console[name] = f\n    }\n}\n\nmodule.exports = console\n\nfunction log() {}\n\nfunction info() {\n    console.log.apply(console, arguments)\n}\n\nfunction warn() {\n    console.log.apply(console, arguments)\n}\n\nfunction error() {\n    console.warn.apply(console, arguments)\n}\n\nfunction time(label) {\n    times[label] = Date.now()\n}\n\nfunction timeEnd(label) {\n    var time = times[label]\n    if (!time) {\n        throw new Error(\"No such label: \" + label)\n    }\n\n    var duration = Date.now() - time\n    console.log(label + \": \" + duration + \"ms\")\n}\n\nfunction trace() {\n    var err = new Error()\n    err.name = \"Trace\"\n    err.message = util.format.apply(null, arguments)\n    console.error(err.stack)\n}\n\nfunction dir(object) {\n    console.log(util.inspect(object) + \"\\n\")\n}\n\nfunction assert(expression) {\n    if (!expression) {\n        var arr = slice.call(arguments, 1)\n        assert.ok(false, util.format.apply(null, arr))\n    }\n}\n\n})(window)\n},{\"util\":10,\"assert\":11}],10:[function(require,module,exports){\nvar events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{\"events\":2}],11:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require('util');\nvar Buffer = require(\"buffer\").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return '' + value;\n  }\n  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === 'function' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + ':', this.message].join(' ');\n  } else {\n    return [\n      this.name + ':',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(' ');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail('Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail('Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{\"util\":10,\"buffer\":12}],13:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],12:[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require('assert');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require(\"base64-js\").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || \"utf8\") {\n    case 'hex':\n      return str.length / 2;\n\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(str).length;\n\n    case 'ascii':\n    case 'binary':\n      return str.length;\n\n    case 'base64':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require(\"base64-js\").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = \"\";\n  var tmp = \"\";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = \"\";\n    } else\n      tmp += \"%\" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = \"\";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n  return '<SlowBuffer ' + out.join(' ') + '>';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n  start = +start || 0;\n  if (typeof end == 'undefined') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return '';\n  }\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.asciiSlice(start, end);\n\n    case 'binary':\n      return this.binarySlice(start, end);\n\n    case 'base64':\n      return this.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error('Invalid hex string');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error('Invalid hex string');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexWrite(string, offset, length);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Write(string, offset, length);\n\n    case 'ascii':\n      return this.asciiWrite(string, offset, length);\n\n    case 'binary':\n      return this.binaryWrite(string, offset, length);\n\n    case 'base64':\n      return this.base64Write(string, offset, length);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error('oob');\n  }\n  if (start > end) {\n    throw new Error('oob');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== 'undefined', \"copying undefined buffer bytes!\");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nSlowBuffer.prototype.fill = function(value, start, end) {\n  if (end > this.length) {\n    throw new Error('oob');\n  }\n  if (start > end) {\n    throw new Error('oob');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === 'number') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case 'number':\n        this.length = coerce(subject);\n        break;\n\n      case 'string':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case 'object': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error('First argument needs to be a number, ' +\n                        'array or string.');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this.parent[i + this.offset] = subject.readUInt8(i);\n        }\n        else {\n          this.parent[i + this.offset] = subject[i];\n        }\n      }\n    } else if (type == 'string') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === 'object' &&\n         typeof subject.length === 'number';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error(\"Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.\");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== 'number') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n\n  return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case 'hex':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case 'utf8':\n    case 'utf-8':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case 'ascii':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case 'binary':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case 'base64':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case 'ucs2':\n    case 'ucs-2':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  if (typeof start == 'undefined' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == 'undefined' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case 'hex':\n      return this.parent.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.parent.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.parent.asciiSlice(start, end);\n\n    case 'binary':\n      return this.parent.binarySlice(start, end);\n\n    case 'base64':\n      return this.parent.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === 'number') || isNaN(value)) {\n    throw new Error('value is not a number');\n  }\n\n  if (end < start) throw new Error('end < start');\n\n  // Fill 0 bytes; we're done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error('start out of bounds');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error('end out of bounds');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error('sourceEnd < sourceStart');\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error('sourceStart out of bounds');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error('sourceEnd out of bounds');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error('oob');\n  if (start > end) throw new Error('oob');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString('utf8', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString('binary', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString('ascii', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, 'utf8');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, 'binary');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, 'ascii');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1];\n    }\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value >= 0,\n      'specified a negative value for writing an unsigned value');\n\n  assert.ok(value <= max, 'value is larger than maximum value for type');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer.parent[buffer.offset + offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{\"assert\":11,\"./buffer_ieee754\":13,\"base64-js\":14}],14:[function(require,module,exports){\n(function (exports) {\n  'use strict';\n\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  function b64ToByteArray(b64) {\n    var i, j, l, tmp, placeHolders, arr;\n  \n    if (b64.length % 4 > 0) {\n      throw 'Invalid string. Length must be a multiple of 4';\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64.indexOf('=');\n    placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n      arr.push((tmp & 0xFF0000) >> 16);\n      arr.push((tmp & 0xFF00) >> 8);\n      arr.push(tmp & 0xFF);\n    }\n\n    if (placeHolders === 2) {\n      tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n      arr.push(tmp & 0xFF);\n    } else if (placeHolders === 1) {\n      tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n      arr.push((tmp >> 8) & 0xFF);\n      arr.push(tmp & 0xFF);\n    }\n\n    return arr;\n  }\n\n  function uint8ToBase64(uint8) {\n    var i,\n      extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n      output = \"\",\n      temp, length;\n\n    function tripletToBase64 (num) {\n      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n    };\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n      output += tripletToBase64(temp);\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1];\n        output += lookup[temp >> 2];\n        output += lookup[(temp << 4) & 0x3F];\n        output += '==';\n        break;\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n        output += lookup[temp >> 10];\n        output += lookup[(temp >> 4) & 0x3F];\n        output += lookup[(temp << 2) & 0x3F];\n        output += '=';\n        break;\n    }\n\n    return output;\n  }\n\n  module.exports.toByteArray = b64ToByteArray;\n  module.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}]},{},[\"FD4Lxs\"])\n;\nJSHINT = require('jshint').JSHINT;\n}());",
  "output-tester.js": "window.OutputTester = function() {};\n\nOutputTester.prototype = {\n    initialize: function(options) {\n        var tester = this;\n\n        this.tests = [];\n        this.testContext = {};\n\n        for (var prop in this.testMethods) {\n            if (this.testMethods.hasOwnProperty(prop)) {\n                this.testContext[prop] = this.testMethods[prop];\n            }\n        }\n\n        for (var prop in this.defaultTestContext) {\n            if (!(prop in this.testContext)) {\n                this.testContext[prop] = this.defaultTestContext[prop];\n            }\n        }\n\n        // This won't be defined inside a web worker itself (that's ok)\n        if (typeof PooledWorker === \"undefined\") {\n            return;\n        }\n\n        /*\n         * The worker that runs the tests in the background, if possible.\n         */\n        this.testWorker = new PooledWorker(\n            options.url,\n            function(code, validate, errors, callback) {\n                var self = this;\n\n                // If there are syntax errors in the tests themselves,\n                //  then we ignore the request to test.\n                try {\n                    tester.exec(validate);\n                } catch(e) {\n                    if (window.console) {\n                        console.warn(e.message);\n                    }\n                    return;\n                }\n\n                // If there's no Worker support *or* there\n                //  are syntax errors in user code, we do the testing in\n                //  the browser instead.\n                // We do it in-browser in the latter case as\n                //  the code is often in a syntax-error state,\n                //  and the browser doesn't like creating that many workers,\n                //  and the syntax error tests that we have are fast.\n                if (!window.Worker || errors.length > 0) {\n                    return tester.test(code, validate, errors, callback);\n                }\n\n                var worker = this.getWorkerFromPool();\n\n                worker.onmessage = function(event) {\n                    if (event.data.type === \"test\") {\n                        if (self.isCurrentWorker(worker)) {\n                            var data = event.data.message;\n                            callback(data.errors, data.testResults);\n                        }\n                        self.addWorkerToPool(worker);\n                    }\n                };\n\n                if (worker.initialized) {\n                    worker.postMessage({\n                        code: code,\n                        validate: validate,\n                        errors: errors,\n                    });                    \n                } else {\n                    worker.postMessage({\n                        code: code,\n                        validate: validate,\n                        errors: errors,\n                        deps: options.deps\n                    });\n                    worker.initialized = true;\n                }\n            }\n        );\n    },\n\n    bindTestContext: function(obj) {\n        obj = obj || this.testContext;\n\n        for (var prop in obj) {\n            if (typeof obj[prop] === \"object\") {\n                this.bindTestContext(obj[prop]);\n            } else if (typeof obj[prop] === \"function\") {\n                obj[prop] = obj[prop].bind(this);\n            }\n        }\n    },\n\n    test: function(userCode, validate, errors, callback) {\n        var testResults = [];\n        errors = this.errors = errors || [];\n        this.userCode = userCode;\n        this.tests = [];\n\n        // This will also fill in tests, as it will end up\n        // referencing functions like staticTest and that\n        // function will fill in this.tests\n        this.exec(validate);\n\n        this.curTask = null;\n        this.curTest = null;\n\n        for (var i = 0; i < this.tests.length; i++) {\n            testResults.push(this.runTest(this.tests[i], i));\n        }\n\n        callback(errors, testResults);\n    },\n\n    runTest: function(test, i) {\n        var result = {\n            name: test.name,\n            state: \"pass\",\n            results: []\n        };\n\n        this.curTest = result;\n\n        test.fn.call(this);\n\n        this.curTest = null;\n\n        return result;\n    },\n\n    exec: function(code) {\n        if (!code) {\n            return true;\n        }\n\n        code = \"with(arguments[0]){\\n\" + code + \"\\n}\";\n        (new Function(code)).call({}, this.testContext);\n\n        return true;\n    },\n\n    defaultTestContext: {\n        test: function(name, fn, type) {\n            if (!fn) {\n                fn = name;\n                name = $._(\"Test Case\");\n            }\n\n            this.tests.push({\n                name: name,\n\n                type: type || \"default\",\n\n                fn: function() {\n                    try {\n                        return fn.apply(this, arguments);\n                    } catch (e) {\n                        if (window.console) {\n                            console.warn(e);\n                        }\n                    }\n                }\n            });\n        },\n\n        staticTest: function(name, fn) {\n            this.testContext.test(name, fn, \"static\");\n        },\n\n        log: function(msg, state, expected, type, meta) {\n            type = type || \"info\";\n\n            var item = {\n                type: type,\n                msg: msg,\n                state: state,\n                expected: expected,\n                meta: meta || {}\n            };\n\n            if (this.curTest) {\n                if (state !== \"pass\") {\n                    this.curTest.state = state;\n                }\n\n                this.curTest.results.push(item);\n            }\n\n            return item;\n        },\n\n        task: function(msg, tip) {\n            this.curTask = this.testContext.log(msg,\n                \"pass\", tip, \"task\");\n            this.curTask.results = [];\n        },\n\n        endTask: function() {\n            this.curTask = null;\n        },\n\n        assert: function(pass, msg, expected, meta) {\n            pass = !!pass;\n            this.testContext.log(msg, pass ? \"pass\" : \"fail\",\n                expected, \"assertion\", meta);\n            return pass;\n        },\n\n        isEqual: function(a, b, msg) {\n            return this.testContext.assert(a === b, msg, [a, b]);\n        },\n\n        /*\n         * Returns a pass result with an optional message\n         */\n        pass: function(message) {\n            return {\n                success: true,\n                message: message\n            };\n        },\n\n        /*\n         * Returns a fail result with an optional message\n         */\n        fail: function(message) {\n            return {\n                success: false,\n                message: message\n            };\n        },\n\n        /*\n         * If any of results passes, returns the first pass. Otherwise, returns\n         * the first fail.\n         */\n        anyPass: function() {\n            return _.find(arguments, this.testContext.passes) || arguments[0] ||\n                this.testContext.fail();\n        },\n\n        /*\n         * If any of results fails, returns the first fail. Otherwise, returns\n         * the first pass.\n         */\n        allPass: function() {\n            return _.find(arguments, this.testContext.fails) || arguments[0] ||\n                this.testContext.pass();\n        },\n\n        /*\n         * Returns true if the result represents a pass.\n         */\n        passes: function(result) {\n            return result.success;\n        },\n\n        /*\n         * Returns true if the result represents a fail.\n         */\n        fails: function(result) {\n            return !result.success;\n        }\n    }\n};",
  "pjs-tester.js": "window.PJSTester = function(options) {\n    this.initialize(options);\n    this.bindTestContext();\n};\n\nPJSTester.prototype = new OutputTester();\n\nPJSTester.prototype.testMethods = {\n    /*\n     * See if any of the patterns match the code\n     */\n    firstMatchingPattern: function(patterns) {\n        return _.find(patterns, _.bind(function(pattern) {\n            return this.testContext.matches(pattern);\n        }, this));\n    },\n\n    hasFnCall: function(name, check) {\n        for (var i = 0, l = this.fnCalls.length; i < l; i++) {\n            var retVal = this.testContext.checkFn(\n                this.fnCalls[i], name, check);\n\n            if (retVal === true) {\n                return;\n            }\n        }\n\n        this.testContext.assert(false,\n            $._(\"Expected function call to '%(name)s' was not made.\",\n            {name: name}));\n    },\n\n    orderedFnCalls: function(calls) {\n        var callPos = 0;\n\n        for (var i = 0, l = this.fnCalls.length; i < l; i++) {\n            var retVal = this.testContext.checkFn(\n                this.fnCalls[i],\n                    calls[callPos][0], calls[callPos][1]);\n\n            if (retVal === true) {\n                callPos += 1;\n\n                if (callPos === calls.length) {\n                    return;\n                }\n            }\n        }\n\n        this.testContext.assert(false,\n            $._(\"Expected function call to '%(name)s' was not made.\",\n            {name: calls[callPos][0]}));\n    },\n\n    checkFn: function(fnCall, name, check) {\n        if (fnCall.name !== name) {\n            return;\n        }\n\n        var pass = true;\n\n        if (typeof check === \"object\") {\n            if (check.length !== fnCall.args.length) {\n                pass = false;\n\n            } else {\n                for (var c = 0; c < check.length; c++) {\n                    if (check[c] !== null &&\n                        check[c] !== fnCall.args[c]) {\n                        pass = false;\n                    }\n                }\n            }\n\n        } else if (typeof check === \"function\") {\n            pass = check(fnCall);\n        }\n\n        if (pass) {\n            this.testContext.assert(true,\n                $._(\"Correct function call made to %(name)s.\",\n                {name: name}));\n        }\n\n        return pass;\n    },\n\n    _isVarName: function(str) {\n        return _.isString(str) && str.length > 0 && str[0] === \"$\";\n    },\n\n    _assertVarName: function(str) {\n        if (!this.testContext._isVarName(str)) {\n            throw new Error(\n                $._(\"Expected '%(name)s' to be a valid variable name.\",\n                    {name: str}));\n        }\n    },\n\n    /*\n     * Satisfied when predicate(var) is true.\n     */\n    unaryOp: function(varName, predicate) {\n        this.testContext._assertVarName(varName);\n        return this.testContext.constraint([varName], function(ast) {\n            return !!(ast && !_.isUndefined(ast.value) &&\n                predicate(ast.value));\n        });\n    },\n\n    /*\n     * Satisfied when var is any literal.\n     */\n    isLiteral: function(varName) {\n        function returnsTrue() {\n            return true;\n        }\n\n        return this.testContext.unaryOp(varName, returnsTrue);\n    },\n\n    /*\n     * Satisfied when var is a number.\n     */\n    isNumber: function(varName) {\n        return this.testContext.unaryOp(varName, _.isNumber);\n    },\n\n    /*\n     * Satisfied when var is an identifier\n     */\n    isIdentifier: function(varName) {\n        return this.testContext.constraint([varName], function(ast) {\n            return !!(ast && ast.type && ast.type === \"Identifier\");\n        });\n    },\n\n    /*\n     * Satisfied when var is a boolean.\n     */\n    isBoolean: function(varName) {\n        return this.testContext.unaryOp(varName, _.isBoolean);\n    },\n\n    /*\n     * Satisfied when var is a string.\n     */\n    isString: function(varName) {\n        return this.testContext.unaryOp(varName, _.isString);\n    },\n\n    /*\n     * Satisfied when pred(first, second) is true.\n     */\n    binaryOp: function(first, second, predicate) {\n        var variables = [];\n        var fn;\n        if (this.testContext._isVarName(first)) {\n            variables.push(first);\n            if (this.testContext._isVarName(second)) {\n                variables.push(second);\n                fn = function(a, b) {\n                    return !!(a && b && !_.isUndefined(a.value) &&\n                        !_.isUndefined(b.value) &&\n                        predicate(a.value, b.value));\n                };\n            } else {\n                fn = function(a) {\n                    return !!(a && !_.isUndefined(a.value) &&\n                        predicate(a.value, second));\n                };\n            }\n        } else if (this.testContext._isVarName(second)) {\n            variables.push(second);\n            fn = function(b) {\n                return !!(b && !_.isUndefined(b.value) &&\n                    predicate(first, b.value));\n            };\n        } else {\n            throw new Error($._(\"Expected either '%(first)s' or '%(second)s'\" +\n                \" to be a valid variable name.\",\n                {first: first, second: second}));\n        }\n\n        return this.testContext.constraint(variables, fn);\n    },\n\n    /*\n     * Satisfied when a < b\n     */\n    lessThan: function(a, b) {\n        return this.testContext.binaryOp(a, b, function(a, b) {\n            return a < b;\n        });\n    },\n\n    /*\n     * Satisfied when a <= b\n     */\n    lessThanOrEqual: function(a, b) {\n        return this.testContext.binaryOp(a, b, function(a, b) {\n            return a <= b;\n        });\n    },\n\n    /*\n     * Satisfied when a > b\n     */\n    greaterThan: function(a, b) {\n        return this.testContext.binaryOp(a, b, function(a, b) {\n            return a > b;\n        });\n    },\n\n    /*\n     * Satisfied when a > 0\n     */\n    positive: function(a) {\n        return this.testContext.unaryOp(a, function(a) {\n            return a > 0;\n        });\n    },\n\n    /*\n     * Satisfied when a > 0\n     */\n    negative: function(a) {\n        return this.testContext.unaryOp(a, function(a) {\n            return a < 0;\n        });\n    },\n\n    /*\n     * Satisfied when a >= b\n     */\n    greaterThanOrEqual: function(a, b) {\n        return this.testContext.binaryOp(a, b, function(a, b) {\n            return a >= b;\n        });\n    },\n\n    /*\n     * Satisfied when min <= val <= max\n     */\n    inRange: function(val, min, max) {\n        return this.testContext.and(\n            this.testContext.greaterThanOrEqual(val, min),\n            this.testContext.lessThanOrEqual(val, max)\n        );\n    },\n\n    /*\n     * Satisfied when a === b\n     */\n    equal: function(a, b) {\n        return this.testContext.binaryOp(a, b, function(a, b) {\n            return a === b;\n        });\n    },\n\n    /*\n     * Satisfied when a !== b\n     */\n    notEqual: function(a, b) {\n        return this.testContext.binaryOp(a, b, function(a, b) {\n            return a !== b;\n        });\n    },\n\n    /*\n     * Satisfied when constraint is not satisfied\n     */\n    not: function(constraint) {\n        return this.testContext.constraint(constraint.variables, function() {\n            return !constraint.fn.apply({}, arguments);\n        });\n    },\n\n    _naryShortCircuitingOp: function(allOrAny, args) {\n        var variables = _.union.apply({}, _.pluck(args, \"variables\"));\n\n        var argNameToIndex = _.object(_.map(variables, function(item, i) {\n            return [item, i];\n        }));\n\n        return this.testContext.constraint(variables, function() {\n            var constraintArgs = arguments;\n            return allOrAny(args, function(constraint) {\n                var fnArgs = _.map(constraint.variables, function(varName) {\n                    return constraintArgs[argNameToIndex[varName]];\n                });\n\n                return constraint.fn.apply({}, fnArgs);\n            });\n        });\n    },\n\n    /*\n     * Satisfied when all of the input constraints are satisfied\n     */\n    and: function() {\n        return this.testContext._naryShortCircuitingOp(_.all, arguments);\n    },\n\n    /*\n     * Satisfied when any of the input constraints are satisfied\n     */\n    or: function() {\n        return this.testContext._naryShortCircuitingOp(_.any, arguments);\n    },\n\n    /*\n     * Returns a new structure from the combination of a pattern and a\n     * constraint\n     */\n    structure: function(pattern, constraint) {\n        return {\n            pattern: pattern,\n            constraint: constraint\n        };\n    },\n\n    /*\n     * Creates a new variable constraint\n     */\n    constraint: function(variables, fn) {\n        return {\n            variables: variables,\n            fn: fn\n        };\n    },\n\n    /*\n     * Returns the result of matching a structure against the user's code\n     */\n    match: function(structure) {\n        // If there were syntax errors, don't even try to match it\n        if (this.errors.length) {\n            return {\n                success: false,\n                message: $._(\"Syntax error!\")\n            };\n        }\n\n        // At the top, we take care of some \"alternative\" uses of this\n        // function. For ease of challenge developing, we return a\n        // failure() instead of disallowing these uses altogether\n\n        // If we don't see a pattern property, they probably passed in\n        // a pattern itself, so we'll turn it into a structure\n        if (structure && _.isUndefined(structure.pattern)) {\n            structure = {pattern: structure};\n        }\n\n        // If nothing is passed in or the pattern is non-existent, return\n        // failure\n        if (!structure || ! structure.pattern) {\n            return {\n                success: false,\n                message: \"\"\n            };\n        }\n\n        try {\n            var callbacks = structure.constraint;\n            var success = Structured.match(this.userCode,\n                structure.pattern, {\n                    varCallbacks: callbacks\n                });\n\n            return {\n                success: success,\n                message: callbacks && callbacks.failure\n            };\n        } catch (e) {\n            if (window.console) {\n                console.warn(e);\n            }\n            return {\n                success: true,\n                message: $._(\"Hm, we're having some trouble \" +\n                    \"verifying your answer for this step, so we'll give \" +\n                    \"you the benefit of the doubt as we work to fix it. \" +\n                    \"Please click \\\"Report a problem\\\" to notify us.\")\n            };\n        }\n    },\n\n    /*\n     * Returns true if the structure matches the user's code\n     */\n    matches: function(structure) {\n        if (typeof structure !== \"object\") {\n            structure = this.testContext.structure(structure);\n        }\n        return this.testContext.match(structure).success;\n    },\n\n    /*\n     * Creates a new test result (i.e. new challenge tab)\n     */\n    assertMatch: function(result, description, hint, image, syntaxChecks) {\n        if (syntaxChecks) {\n            // If we found any syntax errors or warnings, we'll send it\n            // through the special syntax checks\n            var foundErrors = _.any(this.errors, function(error) {\n                return error.lint;\n            });\n\n            if (foundErrors) {\n                _.each(syntaxChecks, function(syntaxCheck) {\n                    // Check if we find the regex anywhere in the code\n                    var foundCheck = this.userCode.search(syntaxCheck.re);\n                    var rowNum = -1, colNum = -1, errorMsg;\n                    if (foundCheck > -1) {\n                        errorMsg = syntaxCheck.msg;\n\n                        // Find line number and character\n                        var lines = this.userCode.split(\"\\n\");\n                        var totalChars = 0;\n                        _.each(lines, function(line, num) {\n                            if (rowNum === -1 &&\n                                foundCheck < totalChars + line.length) {\n                                rowNum = num;\n                                colNum = foundCheck - totalChars;\n                            }\n                            totalChars += line.length;\n                        });\n\n                        this.errors.splice(0, 1, {\n                            text: errorMsg,\n                            row: rowNum,\n                            col: colNum,\n                            type: \"error\"\n                        });\n                    }\n                }.bind(this));\n            }\n        }\n\n        var alternateMessage;\n        var alsoMessage;\n\n        if (result.success) {\n            alternateMessage = result.message;\n        } else {\n            alsoMessage = result.message;\n        }\n\n        this.testContext.assert(result.success, description, \"\", {\n            // We can accept string hints here because\n            //  we never match against them anyway\n            structure: _.isString(hint) ? \"function() {\" + hint + \"}\" :\n                hint.toString(),\n            alternateMessage: alternateMessage,\n            alsoMessage: alsoMessage,\n            image: image\n        });\n    }\n};",
  "processing-stubs.js": "function initProcessingStubs() {\n    /*\n     * Processing functions that return values should have implementations\n     * here.\n     */\n\n    var context = {\n        // Global variables that we want to expose, by default\n        Object: this.Object,\n        RegExp: this.RegExp,\n        Math: this.Math,\n        Array: this.Array,\n        String: this.String\n    };\n\n    (function(p, undef) {    \n      var nop = function() {};\n      var\n        curColorMode = 1,\n        colorModeA = 255,\n        colorModeX = 255,\n        colorModeY = 255,\n        colorModeZ = 255;\n      var start = Date.now();\n\n      p.name = \"Processing.js Instance\";\n\n      p.PVector = (function() {\n          function PVector(x, y, z) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.z = z || 0;\n          }\n\n          PVector.fromAngle = function(angle, v) {\n            if (v === undef || v === null) {\n              v = new PVector();\n            }\n            // XXX(jeresig)\n            v.x = p.cos(angle);\n            v.y = p.sin(angle);\n            return v;\n          };\n\n          PVector.random2D = function(v) {\n            return PVector.fromAngle(Math.random() * 360, v);\n          };\n\n          PVector.random3D = function(v) {\n            var angle = Math.random() * 360;\n            var vz = Math.random() * 2 - 1;\n            var mult = Math.sqrt(1 - vz * vz);\n            // XXX(jeresig)\n            var vx = mult * p.cos(angle);\n            var vy = mult * p.sin(angle);\n            if (v === undef || v === null) {\n              v = new PVector(vx, vy, vz);\n            } else {\n              v.set(vx, vy, vz);\n            }\n            return v;\n          };\n\n          PVector.dist = function(v1, v2) {\n            return v1.dist(v2);\n          };\n\n          PVector.dot = function(v1, v2) {\n            return v1.dot(v2);\n          };\n\n          PVector.cross = function(v1, v2) {\n            return v1.cross(v2);\n          };\n\n          PVector.sub = function(v1, v2) {\n            return new PVector(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n          };\n\n          PVector.angleBetween = function(v1, v2) {\n            // XXX(jeresig)\n            return p.acos(v1.dot(v2) / (v1.mag() * v2.mag()));\n          };\n\n          PVector.lerp = function(v1, v2, amt) {\n            // non-static lerp mutates object, but this version returns a new vector\n            var retval = new PVector(v1.x, v1.y, v1.z);\n            retval.lerp(v2, amt);\n            return retval;\n          };\n\n          // Common vector operations for PVector\n          PVector.prototype = {\n            set: function(v, y, z) {\n              if (arguments.length === 1) {\n                this.set(v.x || v[0] || 0,\n                         v.y || v[1] || 0,\n                         v.z || v[2] || 0);\n              } else {\n                this.x = v;\n                this.y = y;\n                this.z = z;\n              }\n            },\n            get: function() {\n              return new PVector(this.x, this.y, this.z);\n            },\n            mag: function() {\n              var x = this.x,\n                  y = this.y,\n                  z = this.z;\n              return Math.sqrt(x * x + y * y + z * z);\n            },\n            magSq: function() {\n              var x = this.x,\n                  y = this.y,\n                  z = this.z;\n              return (x * x + y * y + z * z);\n            },\n            setMag: function(v_or_len, len) {\n              if (len === undef) {\n                len = v_or_len;\n                this.normalize();\n                this.mult(len);\n              } else {\n                var v = v_or_len;\n                v.normalize();\n                v.mult(len);\n                return v;\n              }\n            },\n            add: function(v, y, z) {\n              if (arguments.length === 1) {\n                this.x += v.x;\n                this.y += v.y;\n                this.z += v.z;\n              } else {\n                this.x += v;\n                this.y += y;\n                this.z += z;\n              }\n            },\n            sub: function(v, y, z) {\n              if (arguments.length === 1) {\n                this.x -= v.x;\n                this.y -= v.y;\n                this.z -= v.z;\n              } else {\n                this.x -= v;\n                this.y -= y;\n                this.z -= z;\n              }\n            },\n            mult: function(v) {\n              if (typeof v === 'number') {\n                this.x *= v;\n                this.y *= v;\n                this.z *= v;\n              } else {\n                this.x *= v.x;\n                this.y *= v.y;\n                this.z *= v.z;\n              }\n            },\n            div: function(v) {\n              if (typeof v === 'number') {\n                this.x /= v;\n                this.y /= v;\n                this.z /= v;\n              } else {\n                this.x /= v.x;\n                this.y /= v.y;\n                this.z /= v.z;\n              }\n            },\n            rotate: function(angle) {\n              var prev_x = this.x;\n              var c = p.cos(angle);\n              var s = p.sin(angle);\n              this.x = c * this.x - s * this.y;\n              this.y = s * prev_x + c * this.y;\n            },\n            dist: function(v) {\n              var dx = this.x - v.x,\n                  dy = this.y - v.y,\n                  dz = this.z - v.z;\n              return Math.sqrt(dx * dx + dy * dy + dz * dz);\n            },\n            dot: function(v, y, z) {\n              if (arguments.length === 1) {\n                return (this.x * v.x + this.y * v.y + this.z * v.z);\n              }\n              return (this.x * v + this.y * y + this.z * z);\n            },\n            cross: function(v) {\n              var x = this.x,\n                  y = this.y,\n                  z = this.z;\n              return new PVector(y * v.z - v.y * z,\n                                 z * v.x - v.z * x,\n                                 x * v.y - v.x * y);\n            },\n            lerp: function(v_or_x, amt_or_y, z, amt) {\n              var lerp_val = function(start, stop, amt) {\n                return start + (stop - start) * amt;\n              };\n              var x, y;\n              if (arguments.length === 2) {\n                // given vector and amt\n                amt = amt_or_y;\n                x = v_or_x.x;\n                y = v_or_x.y;\n                z = v_or_x.z;\n              } else {\n                // given x, y, z and amt\n                x = v_or_x;\n                y = amt_or_y;\n              }\n              this.x = lerp_val(this.x, x, amt);\n              this.y = lerp_val(this.y, y, amt);\n              this.z = lerp_val(this.z, z, amt);\n            },\n            normalize: function() {\n              var m = this.mag();\n              if (m > 0) {\n                this.div(m);\n              }\n            },\n            limit: function(high) {\n              if (this.mag() > high) {\n                this.normalize();\n                this.mult(high);\n              }\n            },\n            heading: function() {\n              // XXX(jeresig)\n              return -p.atan2(-this.y, this.x);\n            },\n            heading2D: function() {\n              return this.heading();\n            },\n            toString: function() {\n              return \"[\" + this.x + \", \" + this.y + \", \" + this.z + \"]\";\n            },\n            array: function() {\n              return [this.x, this.y, this.z];\n            }\n          };\n\n          function createPVectorMethod(method) {\n              return function(v1, v2) {\n                  var v = v1.get();\n                  v[method](v2);\n                  return v;\n              };\n          }\n\n          // Create the static methods of PVector automatically\n          // We don't do toString because it causes a TypeError \n          //  when attempting to stringify PVector\n          for (var method in PVector.prototype) {\n              if (PVector.prototype.hasOwnProperty(method) && !PVector.hasOwnProperty(method) &&\n                  method !== \"toString\") {\n                PVector[method] = createPVectorMethod(method);\n              }\n          }\n\n          return PVector;\n      }());\n\n      p.angleMode = \"radians\";\n      p.convertToDegrees = function(angle) {\n          return p.angleMode === \"degrees\" ?\n              p.degrees(angle) :\n              angle;\n      };\n      p.convertToRadians = function(angle) {\n          return p.angleMode === \"degrees\" ?\n              p.radians(angle) :\n              angle;\n      };\n      p.compose = function() {\n          var args = arguments;\n\n          return function() {\n              var ret = arguments;\n\n              for (var i = 0; i < args.length; i++) {\n                  ret = [ args[i].apply(args[i], ret) ];\n              }\n\n              return ret[0];\n          };\n      };\n\n      p.acos = p.compose(Math.acos, p.convertToDegrees);\n      p.asin = p.compose(Math.asin, p.convertToDegrees);\n      p.atan = p.compose(Math.atan, p.convertToDegrees);\n      p.atan2 = p.compose(Math.atan2, p.convertToDegrees);\n      p.cos = p.compose(p.convertToRadians, Math.cos);\n      p.sin = p.compose(p.convertToRadians, Math.sin);\n      p.tan = p.compose(p.convertToRadians, Math.tan);\n\n      p.abs = Math.abs;\n      p.ceil = Math.ceil;\n      p.constrain = function(aNumber, aMin, aMax) {\n        return aNumber > aMax ? aMax : aNumber < aMin ? aMin : aNumber\n      };\n      p.dist = function() {\n        var dx, dy, dz;\n        if (arguments.length === 4) {\n          dx = arguments[0] - arguments[2];\n          dy = arguments[1] - arguments[3];\n          return Math.sqrt(dx * dx + dy * dy)\n        }\n        if (arguments.length === 6) {\n          dx = arguments[0] - arguments[3];\n          dy = arguments[1] - arguments[4];\n          dz = arguments[2] - arguments[5];\n          return Math.sqrt(dx * dx + dy * dy + dz * dz)\n        }\n      };\n      p.exp = Math.exp;\n      p.floor = Math.floor;\n      p.lerp = function(value1, value2, amt) {\n        return (value2 - value1) * amt + value1\n      };\n      p.log = Math.log;\n      p.mag = function(a, b, c) {\n        if (c) return Math.sqrt(a * a + b * b + c * c);\n        return Math.sqrt(a * a + b * b)\n      };\n      p.map = function(value, istart, istop, ostart, ostop) {\n        return ostart + (ostop - ostart) * ((value - istart) / (istop - istart))\n      };\n      p.max = function() {\n        if (arguments.length === 2) return arguments[0] < arguments[1] ? arguments[1] : arguments[0];\n        var numbers = arguments.length === 1 ? arguments[0] : arguments;\n        if (! (\"length\" in numbers && numbers.length > 0)) throw \"Non-empty array is expected\";\n        var max = numbers[0],\n          count = numbers.length;\n        for (var i = 1; i < count; ++i) if (max < numbers[i]) max = numbers[i];\n        return max\n      };\n      p.min = function() {\n        if (arguments.length === 2) return arguments[0] < arguments[1] ? arguments[0] : arguments[1];\n        var numbers = arguments.length === 1 ? arguments[0] : arguments;\n        if (! (\"length\" in numbers && numbers.length > 0)) throw \"Non-empty array is expected\";\n        var min = numbers[0],\n          count = numbers.length;\n        for (var i = 1; i < count; ++i) if (min > numbers[i]) min = numbers[i];\n        return min\n      };\n      p.norm = function(aNumber, low, high) {\n        return (aNumber - low) / (high - low)\n      };\n      p.pow = Math.pow;\n      p.round = Math.round;\n      p.sq = function(aNumber) {\n        return aNumber * aNumber\n      };\n      p.sqrt = Math.sqrt;\n      var currentRandom = Math.random;\n      p.random = function() {\n        if (arguments.length === 0) return currentRandom();\n        if (arguments.length === 1) return currentRandom() * arguments[0];\n        var aMin = arguments[0],\n          aMax = arguments[1];\n        return currentRandom() * (aMax - aMin) + aMin\n      };\n\n      function Marsaglia(i1, i2) {\n        var z = i1 || 362436069,\n          w = i2 || 521288629;\n        var nextInt = function() {\n          z = 36969 * (z & 65535) + (z >>> 16) & 4294967295;\n          w = 18E3 * (w & 65535) + (w >>> 16) & 4294967295;\n          return ((z & 65535) << 16 | w & 65535) & 4294967295\n        };\n        this.nextDouble = function() {\n          var i = nextInt() / 4294967296;\n          return i < 0 ? 1 + i : i\n        };\n        this.nextInt = nextInt\n      }\n      Marsaglia.createRandomized = function() {\n        var now = new Date;\n        return new Marsaglia(now / 6E4 & 4294967295, now & 4294967295)\n      };\n      p.randomSeed = function(seed) {\n        currentRandom = (new Marsaglia(seed)).nextDouble\n      };\n      p.Random = function(seed) {\n        var haveNextNextGaussian = false,\n          nextNextGaussian, random;\n        this.nextGaussian = function() {\n          if (haveNextNextGaussian) {\n            haveNextNextGaussian = false;\n            return nextNextGaussian\n          }\n          var v1, v2, s;\n          do {\n            v1 = 2 * random() - 1;\n            v2 = 2 * random() - 1;\n            s = v1 * v1 + v2 * v2\n          } while (s >= 1 || s === 0);\n          var multiplier = Math.sqrt(-2 * Math.log(s) / s);\n          nextNextGaussian = v2 * multiplier;\n          haveNextNextGaussian = true;\n          return v1 * multiplier\n        };\n        random = seed === undef ? Math.random : (new Marsaglia(seed)).nextDouble\n      };\n\n      function PerlinNoise(seed) {\n        var rnd = seed !== undef ? new Marsaglia(seed) : Marsaglia.createRandomized();\n        var i, j;\n        var perm = new Uint8Array(512);\n        for (i = 0; i < 256; ++i) perm[i] = i;\n        for (i = 0; i < 256; ++i) {\n          var t = perm[j = rnd.nextInt() & 255];\n          perm[j] = perm[i];\n          perm[i] = t\n        }\n        for (i = 0; i < 256; ++i) perm[i + 256] = perm[i];\n\n        function grad3d(i, x, y, z) {\n          var h = i & 15;\n          var u = h < 8 ? x : y,\n          v = h < 4 ? y : h === 12 || h === 14 ? x : z;\n          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)\n        }\n        function grad2d(i, x, y) {\n          var v = (i & 1) === 0 ? x : y;\n          return (i & 2) === 0 ? -v : v\n        }\n        function grad1d(i, x) {\n          return (i & 1) === 0 ? -x : x\n        }\n        function lerp(t, a, b) {\n          return a + t * (b - a)\n        }\n        this.noise3d = function(x, y, z) {\n          var X = Math.floor(x) & 255,\n            Y = Math.floor(y) & 255,\n            Z = Math.floor(z) & 255;\n          x -= Math.floor(x);\n          y -= Math.floor(y);\n          z -= Math.floor(z);\n          var fx = (3 - 2 * x) * x * x,\n            fy = (3 - 2 * y) * y * y,\n            fz = (3 - 2 * z) * z * z;\n          var p0 = perm[X] + Y,\n            p00 = perm[p0] + Z,\n            p01 = perm[p0 + 1] + Z,\n            p1 = perm[X + 1] + Y,\n            p10 = perm[p1] + Z,\n            p11 = perm[p1 + 1] + Z;\n          return lerp(fz, lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x - 1, y, z)), lerp(fx, grad3d(perm[p01], x, y - 1, z), grad3d(perm[p11], x - 1, y - 1, z))), lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z - 1), grad3d(perm[p10 + 1], x - 1, y, z - 1)), lerp(fx, grad3d(perm[p01 + 1], x, y - 1, z - 1), grad3d(perm[p11 + 1], x - 1, y - 1, z - 1))))\n        };\n        this.noise2d = function(x, y) {\n          var X = Math.floor(x) & 255,\n            Y = Math.floor(y) & 255;\n          x -= Math.floor(x);\n          y -= Math.floor(y);\n          var fx = (3 - 2 * x) * x * x,\n            fy = (3 - 2 * y) * y * y;\n          var p0 = perm[X] + Y,\n            p1 = perm[X + 1] + Y;\n          return lerp(fy, lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x - 1, y)), lerp(fx, grad2d(perm[p0 + 1], x, y - 1), grad2d(perm[p1 + 1], x - 1, y - 1)))\n        };\n        this.noise1d = function(x) {\n          var X = Math.floor(x) & 255;\n          x -= Math.floor(x);\n          var fx = (3 - 2 * x) * x * x;\n          return lerp(fx, grad1d(perm[X], x), grad1d(perm[X + 1], x - 1))\n        }\n      }\n      var noiseProfile = {\n        generator: undef,\n        octaves: 4,\n        fallout: 0.5,\n        seed: undef\n      };\n      p.noise = function(x, y, z) {\n        if (noiseProfile.generator === undef) noiseProfile.generator = new PerlinNoise(noiseProfile.seed);\n        var generator = noiseProfile.generator;\n        var effect = 1,\n          k = 1,\n          sum = 0;\n        for (var i = 0; i < noiseProfile.octaves; ++i) {\n          effect *= noiseProfile.fallout;\n          switch (arguments.length) {\n          case 1:\n            sum += effect * (1 + generator.noise1d(k * x)) / 2;\n            break;\n          case 2:\n            sum += effect * (1 + generator.noise2d(k * x, k * y)) / 2;\n            break;\n          case 3:\n            sum += effect * (1 + generator.noise3d(k * x, k * y, k * z)) / 2;\n            break\n          }\n          k *= 2\n        }\n        return sum\n      };\n      p.noiseDetail = function(octaves, fallout) {\n        noiseProfile.octaves = octaves;\n        if (fallout !== undef) noiseProfile.fallout = fallout\n      };\n      p.noiseSeed = function(seed) {\n        noiseProfile.seed = seed;\n        noiseProfile.generator = undef\n      };\n\n      p.split = function(str, delim) {\n        return str.split(delim)\n      };\n      p.splitTokens = function(str, tokens) {\n        if (arguments.length === 1) tokens = \"\\n\\t\\r\\u000c \";\n        tokens = \"[\" + tokens + \"]\";\n        var ary = [];\n        var index = 0;\n        var pos = str.search(tokens);\n        while (pos >= 0) {\n          if (pos === 0) str = str.substring(1);\n          else {\n            ary[index] = str.substring(0, pos);\n            index++;\n            str = str.substring(pos)\n          }\n          pos = str.search(tokens)\n        }\n        if (str.length > 0) ary[index] = str;\n        if (ary.length === 0) ary = undef;\n        return ary\n      };\n      p.append = function(array, element) {\n        array[array.length] = element;\n        return array\n      };\n      p.concat = function(array1, array2) {\n        return array1.concat(array2)\n      };\n      p.sort = function(array, numElem) {\n        var ret = [];\n        if (array.length > 0) {\n          var elemsToCopy = numElem > 0 ? numElem : array.length;\n          for (var i = 0; i < elemsToCopy; i++) ret.push(array[i]);\n          if (typeof array[0] === \"string\") ret.sort();\n          else ret.sort(function(a, b) {\n            return a - b\n          });\n          if (numElem > 0) for (var j = ret.length; j < array.length; j++) ret.push(array[j])\n        }\n        return ret\n      };\n      p.splice = function(array, value, index) {\n        if (value.length === 0) return array;\n        if (value instanceof Array) for (var i = 0, j = index; i < value.length; j++, i++) array.splice(j, 0, value[i]);\n        else array.splice(index, 0, value);\n        return array\n      };\n      p.subset = function(array, offset, length) {\n        var end = length !== undef ? offset + length : array.length;\n        return array.slice(offset, end)\n      };\n      p.join = function(array, seperator) {\n        return array.join(seperator)\n      };\n      p.shorten = function(ary) {\n        var newary = [];\n        var len = ary.length;\n        for (var i = 0; i < len; i++) newary[i] = ary[i];\n        newary.pop();\n        return newary\n      };\n      p.expand = function(ary, targetSize) {\n        var temp = ary.slice(0),\n          newSize = targetSize || ary.length * 2;\n        temp.length = newSize;\n        return temp\n      };\n      p.arrayCopy = function() {\n        var src, srcPos = 0,\n          dest, destPos = 0,\n          length;\n        if (arguments.length === 2) {\n          src = arguments[0];\n          dest = arguments[1];\n          length = src.length\n        } else if (arguments.length === 3) {\n          src = arguments[0];\n          dest = arguments[1];\n          length = arguments[2]\n        } else if (arguments.length === 5) {\n          src = arguments[0];\n          srcPos = arguments[1];\n          dest = arguments[2];\n          destPos = arguments[3];\n          length = arguments[4]\n        }\n        for (var i = srcPos, j = destPos; i < length + srcPos; i++, j++) if (dest[j] !== undef) dest[j] = src[i];\n        else throw \"array index out of bounds exception\";\n      };\n      p.reverse = function(array) {\n        return array.reverse()\n      };\n      p.mix = function(a, b, f) {\n        return a + ((b - a) * f >> 8)\n      };\n      p.peg = function(n) {\n        return n < 0 ? 0 : n > 255 ? 255 : n\n      };\n      p.modes = function() {\n        var ALPHA_MASK = 4278190080,\n          RED_MASK = 16711680,\n          GREEN_MASK = 65280,\n          BLUE_MASK = 255,\n          min = Math.min,\n          max = Math.max;\n\n        function applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb) {\n          var a = min(((c1 & 4278190080) >>> 24) + f, 255) << 24;\n          var r = ar + ((cr - ar) * f >> 8);\n          r = (r < 0 ? 0 : r > 255 ? 255 : r) << 16;\n          var g = ag + ((cg - ag) * f >> 8);\n          g = (g < 0 ? 0 : g > 255 ? 255 : g) << 8;\n          var b = ab + ((cb - ab) * f >> 8);\n          b = b < 0 ? 0 : b > 255 ? 255 : b;\n          return a | r | g | b\n        }\n        return {\n          replace: function(c1, c2) {\n            return c2\n          },\n          blend: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = c1 & RED_MASK,\n              ag = c1 & GREEN_MASK,\n              ab = c1 & BLUE_MASK,\n              br = c2 & RED_MASK,\n              bg = c2 & GREEN_MASK,\n              bb = c2 & BLUE_MASK;\n            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | ar + ((br - ar) * f >> 8) & RED_MASK | ag + ((bg - ag) * f >> 8) & GREEN_MASK | ab + ((bb - ab) * f >> 8) & BLUE_MASK\n          },\n          add: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24;\n            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | min((c1 & RED_MASK) + ((c2 & RED_MASK) >> 8) * f, RED_MASK) & RED_MASK | min((c1 & GREEN_MASK) + ((c2 & GREEN_MASK) >> 8) * f, GREEN_MASK) & GREEN_MASK | min((c1 & BLUE_MASK) + ((c2 & BLUE_MASK) * f >> 8), BLUE_MASK)\n          },\n          subtract: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24;\n            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | max((c1 & RED_MASK) - ((c2 & RED_MASK) >> 8) * f, GREEN_MASK) & RED_MASK | max((c1 & GREEN_MASK) - ((c2 & GREEN_MASK) >> 8) * f, BLUE_MASK) & GREEN_MASK | max((c1 & BLUE_MASK) - ((c2 & BLUE_MASK) * f >> 8), 0)\n          },\n          lightest: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24;\n            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | max(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f) & RED_MASK | max(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f) & GREEN_MASK | max(c1 & BLUE_MASK, (c2 & BLUE_MASK) * f >> 8)\n          },\n          darkest: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = c1 & RED_MASK,\n              ag = c1 & GREEN_MASK,\n              ab = c1 & BLUE_MASK,\n              br = min(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f),\n              bg = min(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f),\n              bb = min(c1 & BLUE_MASK, (c2 & BLUE_MASK) * f >> 8);\n            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | ar + ((br - ar) * f >> 8) & RED_MASK | ag + ((bg - ag) * f >> 8) & GREEN_MASK | ab + ((bb - ab) * f >> 8) & BLUE_MASK\n          },\n          difference: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK,\n              cr = ar > br ? ar - br : br - ar,\n            cg = ag > bg ? ag - bg : bg - ag,\n            cb = ab > bb ? ab - bb : bb - ab;\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          },\n          exclusion: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK,\n              cr = ar + br - (ar * br >> 7),\n              cg = ag + bg - (ag * bg >> 7),\n              cb = ab + bb - (ab * bb >> 7);\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          },\n          multiply: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK,\n              cr = ar * br >> 8,\n              cg = ag * bg >> 8,\n              cb = ab * bb >> 8;\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          },\n          screen: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK,\n              cr = 255 - ((255 - ar) * (255 - br) >> 8),\n              cg = 255 - ((255 - ag) * (255 - bg) >> 8),\n              cb = 255 - ((255 - ab) * (255 - bb) >> 8);\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          },\n          hard_light: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK,\n              cr = br < 128 ? ar * br >> 7 : 255 - ((255 - ar) * (255 - br) >> 7),\n            cg = bg < 128 ? ag * bg >> 7 : 255 - ((255 - ag) * (255 - bg) >> 7),\n            cb = bb < 128 ? ab * bb >> 7 : 255 - ((255 - ab) * (255 - bb) >> 7);\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          },\n          soft_light: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK,\n              cr = (ar * br >> 7) + (ar * ar >> 8) - (ar * ar * br >> 15),\n              cg = (ag * bg >> 7) + (ag * ag >> 8) - (ag * ag * bg >> 15),\n              cb = (ab * bb >> 7) + (ab * ab >> 8) - (ab * ab * bb >> 15);\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          },\n          overlay: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK,\n              cr = ar < 128 ? ar * br >> 7 : 255 - ((255 - ar) * (255 - br) >> 7),\n            cg = ag < 128 ? ag * bg >> 7 : 255 - ((255 - ag) * (255 - bg) >> 7),\n            cb = ab < 128 ? ab * bb >> 7 : 255 - ((255 - ab) * (255 - bb) >> 7);\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          },\n          dodge: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK;\n            var cr = 255;\n            if (br !== 255) {\n              cr = (ar << 8) / (255 - br);\n              cr = cr < 0 ? 0 : cr > 255 ? 255 : cr\n            }\n            var cg = 255;\n            if (bg !== 255) {\n              cg = (ag << 8) / (255 - bg);\n              cg = cg < 0 ? 0 : cg > 255 ? 255 : cg\n            }\n            var cb = 255;\n            if (bb !== 255) {\n              cb = (ab << 8) / (255 - bb);\n              cb = cb < 0 ? 0 : cb > 255 ? 255 : cb\n            }\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          },\n          burn: function(c1, c2) {\n            var f = (c2 & ALPHA_MASK) >>> 24,\n              ar = (c1 & RED_MASK) >> 16,\n              ag = (c1 & GREEN_MASK) >> 8,\n              ab = c1 & BLUE_MASK,\n              br = (c2 & RED_MASK) >> 16,\n              bg = (c2 & GREEN_MASK) >> 8,\n              bb = c2 & BLUE_MASK;\n            var cr = 0;\n            if (br !== 0) {\n              cr = (255 - ar << 8) / br;\n              cr = 255 - (cr < 0 ? 0 : cr > 255 ? 255 : cr)\n            }\n            var cg = 0;\n            if (bg !== 0) {\n              cg = (255 - ag << 8) / bg;\n              cg = 255 - (cg < 0 ? 0 : cg > 255 ? 255 : cg)\n            }\n            var cb = 0;\n            if (bb !== 0) {\n              cb = (255 - ab << 8) / bb;\n              cb = 255 - (cb < 0 ? 0 : cb > 255 ? 255 : cb)\n            }\n            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb)\n          }\n        }\n      }();\n\n      function color$4(aValue1, aValue2, aValue3, aValue4) {\n        var r, g, b, a;\n        if (curColorMode === 3) {\n          var rgb = p.color.toRGB(aValue1, aValue2, aValue3);\n          r = rgb[0];\n          g = rgb[1];\n          b = rgb[2]\n        } else {\n          r = Math.round(255 * (aValue1 / colorModeX));\n          g = Math.round(255 * (aValue2 / colorModeY));\n          b = Math.round(255 * (aValue3 / colorModeZ))\n        }\n        a = Math.round(255 * (aValue4 / colorModeA));\n        r = r < 0 ? 0 : r;\n        g = g < 0 ? 0 : g;\n        b = b < 0 ? 0 : b;\n        a = a < 0 ? 0 : a;\n        r = r > 255 ? 255 : r;\n        g = g > 255 ? 255 : g;\n        b = b > 255 ? 255 : b;\n        a = a > 255 ? 255 : a;\n        return a << 24 & 4278190080 | r << 16 & 16711680 | g << 8 & 65280 | b & 255\n      }\n      function color$2(aValue1, aValue2) {\n        var a;\n        if (aValue1 & 4278190080) {\n          a = Math.round(255 * (aValue2 / colorModeA));\n          a = a > 255 ? 255 : a;\n          a = a < 0 ? 0 : a;\n          return aValue1 - (aValue1 & 4278190080) + (a << 24 & 4278190080)\n        }\n        if (curColorMode === 1) return color$4(aValue1, aValue1, aValue1, aValue2);\n        if (curColorMode === 3) return color$4(0, 0, aValue1 / colorModeX * colorModeZ, aValue2)\n      }\n      function color$1(aValue1) {\n        if (aValue1 <= colorModeX && aValue1 >= 0) {\n          if (curColorMode === 1) return color$4(aValue1, aValue1, aValue1, colorModeA);\n          if (curColorMode === 3) return color$4(0, 0, aValue1 / colorModeX * colorModeZ, colorModeA)\n        }\n        if (aValue1) {\n          if (aValue1 > 2147483647) aValue1 -= 4294967296;\n          return aValue1\n        }\n      }\n      p.color = function(aValue1, aValue2, aValue3, aValue4) {\n        if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef && aValue4 !== undef) return color$4(aValue1, aValue2, aValue3, aValue4);\n        if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef) return color$4(aValue1, aValue2, aValue3, colorModeA);\n        if (aValue1 !== undef && aValue2 !== undef) return color$2(aValue1, aValue2);\n        if (typeof aValue1 === \"number\") return color$1(aValue1);\n        return color$4(colorModeX, colorModeY, colorModeZ, colorModeA)\n      };\n      p.color.toString = function(colorInt) {\n        return \"rgba(\" + ((colorInt >> 16) & 255) + \",\" + ((colorInt >> 8) & 255) + \",\" + (colorInt & 255) + \",\" + ((colorInt >> 24) & 255) / 255 + \")\"\n      };\n      p.color.toInt = function(r, g, b, a) {\n        return a << 24 & 4278190080 | r << 16 & 16711680 | g << 8 & 65280 | b & 255\n      };\n      p.color.toArray = function(colorInt) {\n        return [(colorInt >> 16) & 255, (colorInt >> 8) & 255, colorInt & 255, (colorInt >> 24) & 255]\n      };\n      p.color.toGLArray = function(colorInt) {\n        return [((colorInt >> 16) & 255) / 255, ((colorInt >> 8) & 255) / 255, (colorInt & 255) / 255, ((colorInt & 4278190080) >>> 24) / 255]\n      };\n      p.color.toRGB = function(h, s, b) {\n        h = h > colorModeX ? colorModeX : h;\n        s = s > colorModeY ? colorModeY : s;\n        b = b > colorModeZ ? colorModeZ : b;\n        h = h / colorModeX * 360;\n        s = s / colorModeY * 100;\n        b = b / colorModeZ * 100;\n        var br = Math.round(b / 100 * 255);\n        if (s === 0) return [br, br, br];\n        var hue = h % 360;\n        var f = hue % 60;\n        var p = Math.round(b * (100 - s) / 1E4 * 255);\n        var q = Math.round(b * (6E3 - s * f) / 6E5 * 255);\n        var t = Math.round(b * (6E3 - s * (60 - f)) / 6E5 * 255);\n        switch (Math.floor(hue / 60)) {\n        case 0:\n          return [br, t, p];\n        case 1:\n          return [q, br, p];\n        case 2:\n          return [p, br, t];\n        case 3:\n          return [p, q, br];\n        case 4:\n          return [t, p, br];\n        case 5:\n          return [br, p, q]\n        }\n      };\n\n      function colorToHSB(colorInt) {\n        var red, green, blue;\n        red = ((colorInt >> 16) & 255) / 255;\n        green = ((colorInt >> 8) & 255) / 255;\n        blue = (colorInt & 255) / 255;\n        var max = p.max(p.max(red, green), blue),\n          min = p.min(p.min(red, green), blue),\n          hue, saturation;\n        if (min === max) return [0, 0, max * colorModeZ];\n        saturation = (max - min) / max;\n        if (red === max) hue = (green - blue) / (max - min);\n        else if (green === max) hue = 2 + (blue - red) / (max - min);\n        else hue = 4 + (red - green) / (max - min);\n        hue /= 6;\n        if (hue < 0) hue += 1;\n        else if (hue > 1) hue -= 1;\n        return [hue * colorModeX, saturation * colorModeY, max * colorModeZ]\n      }\n      p.brightness = function(colInt) {\n        return colorToHSB(colInt)[2]\n      };\n      p.saturation = function(colInt) {\n        return colorToHSB(colInt)[1]\n      };\n      p.hue = function(colInt) {\n        return colorToHSB(colInt)[0]\n      };\n      p.red = function(aColor) {\n        return ((aColor >> 16) & 255) / 255 * colorModeX\n      };\n      p.green = function(aColor) {\n        return ((aColor >> 8) & 255) / 255 * colorModeY\n      };\n      p.blue = function(aColor) {\n        return (aColor & 255) / 255 * colorModeZ\n      };\n      p.alpha = function(aColor) {\n        return ((aColor >> 24) & 255) / 255 * colorModeA\n      };\n      p.lerpColor = function(c1, c2, amt) {\n        var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;\n        var hsb1, hsb2, rgb, h, s;\n        var colorBits1 = p.color(c1);\n        var colorBits2 = p.color(c2);\n        if (curColorMode === 3) {\n          hsb1 = colorToHSB(colorBits1);\n          a1 = ((colorBits1 >> 24) & 255) / colorModeA;\n          hsb2 = colorToHSB(colorBits2);\n          a2 = ((colorBits2 >> 24) & 255) / colorModeA;\n          h = p.lerp(hsb1[0], hsb2[0], amt);\n          s = p.lerp(hsb1[1], hsb2[1], amt);\n          b = p.lerp(hsb1[2], hsb2[2], amt);\n          rgb = p.color.toRGB(h, s, b);\n          a = p.lerp(a1, a2, amt) * colorModeA;\n          return a << 24 & 4278190080 | (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255\n        }\n        r1 = (colorBits1 >> 16) & 255;\n        g1 = (colorBits1 >> 8) & 255;\n        b1 = colorBits1 & 255;\n        a1 = ((colorBits1 >> 24) & 255) / colorModeA;\n        r2 = (colorBits2 >> 16) & 255;\n        g2 = (colorBits2 >> 8) & 255;\n        b2 = colorBits2 & 255;\n        a2 = ((colorBits2 & 4278190080) >>> 24) / colorModeA;\n        r = p.lerp(r1, r2, amt) | 0;\n        g = p.lerp(g1, g2, amt) | 0;\n        b = p.lerp(b1, b2, amt) | 0;\n        a = p.lerp(a1, a2, amt) * colorModeA;\n        return a << 24 & 4278190080 | r << 16 & 16711680 | g << 8 & 65280 | b & 255\n      };\n      p.colorMode = function() {\n        curColorMode = arguments[0];\n        if (arguments.length > 1) {\n          colorModeX = arguments[1];\n          colorModeY = arguments[2] || arguments[1];\n          colorModeZ = arguments[3] || arguments[1];\n          colorModeA = arguments[4] || arguments[1]\n        }\n      };\n      p.blendColor = function(c1, c2, mode) {\n        if (mode === 0) return p.modes.replace(c1, c2);\n        else if (mode === 1) return p.modes.blend(c1, c2);\n        else if (mode === 2) return p.modes.add(c1, c2);\n        else if (mode === 4) return p.modes.subtract(c1, c2);\n        else if (mode === 8) return p.modes.lightest(c1, c2);\n        else if (mode === 16) return p.modes.darkest(c1, c2);\n        else if (mode === 32) return p.modes.difference(c1, c2);\n        else if (mode === 64) return p.modes.exclusion(c1, c2);\n        else if (mode === 128) return p.modes.multiply(c1, c2);\n        else if (mode === 256) return p.modes.screen(c1, c2);\n        else if (mode === 1024) return p.modes.hard_light(c1, c2);\n        else if (mode === 2048) return p.modes.soft_light(c1, c2);\n        else if (mode === 512) return p.modes.overlay(c1, c2);\n        else if (mode === 4096) return p.modes.dodge(c1, c2);\n        else if (mode === 8192) return p.modes.burn(c1, c2)\n      };\n\n\n      var charMap = {};\n\n      var Char = p.Character = function(chr) {\n        if (typeof chr === 'string' && chr.length === 1) {\n          this.code = chr.charCodeAt(0);\n        } else if (typeof chr === 'number') {\n          this.code = chr;\n        } else if (chr instanceof Char) {\n          this.code = chr;\n        } else {\n          this.code = NaN;\n        }\n\n        return (charMap[this.code] === undef) ? charMap[this.code] = this : charMap[this.code];\n      };\n\n      Char.prototype.toString = function() {\n        return String.fromCharCode(this.code);\n      };\n\n      Char.prototype.valueOf = function() {\n        return this.code;\n      };\n    \n      p.binary = function(num, numBits) {\n        var bit;\n        if (numBits > 0) bit = numBits;\n        else if (num instanceof Char) {\n          bit = 16;\n          num |= 0\n        } else {\n          bit = 32;\n          while (bit > 1 && !(num >>> bit - 1 & 1)) bit--\n        }\n        var result = \"\";\n        while (bit > 0) result += num >>> --bit & 1 ? \"1\" : \"0\";\n        return result\n      };\n      p.unbinary = function(binaryString) {\n        var i = binaryString.length - 1,\n          mask = 1,\n          result = 0;\n        while (i >= 0) {\n          var ch = binaryString[i--];\n          if (ch !== \"0\" && ch !== \"1\") throw \"the value passed into unbinary was not an 8 bit binary number\";\n          if (ch === \"1\") result += mask;\n          mask <<= 1\n        }\n        return result\n      };\n\n      function nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group) {\n        var sign = value < 0 ? minus : plus;\n        var autoDetectDecimals = rightDigits === 0;\n        var rightDigitsOfDefault = rightDigits === undef || rightDigits < 0 ? 0 : rightDigits;\n        var absValue = Math.abs(value);\n        if (autoDetectDecimals) {\n          rightDigitsOfDefault = 1;\n          absValue *= 10;\n          while (Math.abs(Math.round(absValue) - absValue) > 1.0E-6 && rightDigitsOfDefault < 7) {\n            ++rightDigitsOfDefault;\n            absValue *= 10\n          }\n        } else if (rightDigitsOfDefault !== 0) absValue *= Math.pow(10, rightDigitsOfDefault);\n        var number, doubled = absValue * 2;\n        if (Math.floor(absValue) === absValue) number = absValue;\n        else if (Math.floor(doubled) === doubled) {\n          var floored = Math.floor(absValue);\n          number = floored + floored % 2\n        } else number = Math.round(absValue);\n        var buffer = \"\";\n        var totalDigits = leftDigits + rightDigitsOfDefault;\n        while (totalDigits > 0 || number > 0) {\n          totalDigits--;\n          buffer = \"\" + number % 10 + buffer;\n          number = Math.floor(number / 10)\n        }\n        if (group !== undef) {\n          var i = buffer.length - 3 - rightDigitsOfDefault;\n          while (i > 0) {\n            buffer = buffer.substring(0, i) + group + buffer.substring(i);\n            i -= 3\n          }\n        }\n        if (rightDigitsOfDefault > 0) return sign + buffer.substring(0, buffer.length - rightDigitsOfDefault) + \".\" + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);\n        return sign + buffer\n      }\n      function nfCore(value, plus, minus, leftDigits, rightDigits, group) {\n        if (value instanceof Array) {\n          var arr = [];\n          for (var i = 0, len = value.length; i < len; i++) arr.push(nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));\n          return arr\n        }\n        return nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group)\n      }\n      p.nf = function(value, leftDigits, rightDigits) {\n        return nfCore(value, \"\", \"-\", leftDigits, rightDigits)\n      };\n      p.nfs = function(value, leftDigits, rightDigits) {\n        return nfCore(value, \" \", \"-\", leftDigits, rightDigits)\n      };\n      p.nfp = function(value, leftDigits, rightDigits) {\n        return nfCore(value, \"+\", \"-\", leftDigits, rightDigits)\n      };\n      p.nfc = function(value, leftDigits, rightDigits) {\n        return nfCore(value, \"\", \"-\", leftDigits, rightDigits, \",\")\n      };\n      var decimalToHex = function(d, padding) {\n        padding = padding === undef || padding === null ? padding = 8 : padding;\n        if (d < 0) d = 4294967295 + d + 1;\n        var hex = Number(d).toString(16).toUpperCase();\n        while (hex.length < padding) hex = \"0\" + hex;\n        if (hex.length >= padding) hex = hex.substring(hex.length - padding, hex.length);\n        return hex\n      };\n      p.hex = function(value, len) {\n        if (arguments.length === 1) if (value instanceof Char) len = 4;\n        else len = 8;\n        return decimalToHex(value, len)\n      };\n\n      function unhexScalar(hex) {\n        var value = parseInt(\"0x\" + hex, 16);\n        if (value > 2147483647) value -= 4294967296;\n        return value\n      }\n      p.unhex = function(hex) {\n        if (hex instanceof Array) {\n          var arr = [];\n          for (var i = 0; i < hex.length; i++) arr.push(unhexScalar(hex[i]));\n          return arr\n        }\n        return unhexScalar(hex)\n      };\n      p.matchAll = function(aString, aRegExp) {\n        var results = [],\n          latest;\n        var regexp = new RegExp(aRegExp, \"g\");\n        while ((latest = regexp.exec(aString)) !== null) {\n          results.push(latest);\n          if (latest[0].length === 0)++regexp.lastIndex\n        }\n        return results.length > 0 ? results : null\n      };\n      p.match = function(str, regexp) {\n        return str.match(regexp)\n      };\n      p.str = function(val) {\n        if (val instanceof Array) {\n          var arr = [];\n          for (var i = 0; i < val.length; i++) arr.push(val[i].toString() + \"\");\n          return arr\n        }\n        return val.toString() + \"\"\n      };\n      p.trim = function(str) {\n        if (str instanceof Array) {\n          var arr = [];\n          for (var i = 0; i < str.length; i++) arr.push(str[i].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").replace(/\\r*$/, \"\"));\n          return arr\n        }\n        return str.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").replace(/\\r*$/, \"\")\n      };\n      function booleanScalar(val) {\n        if (typeof val === \"number\") return val !== 0;\n        if (typeof val === \"boolean\") return val;\n        if (typeof val === \"string\") return val.toLowerCase() === \"true\";\n        if (val instanceof Char) return val.code === 49 || val.code === 84 || val.code === 116\n      }\n      p.parseBoolean = function(val) {\n        if (val instanceof Array) {\n          var ret = [];\n          for (var i = 0; i < val.length; i++) ret.push(booleanScalar(val[i]));\n          return ret\n        }\n        return booleanScalar(val)\n      };\n      p.parseByte = function(what) {\n        if (what instanceof\n        Array) {\n          var bytes = [];\n          for (var i = 0; i < what.length; i++) bytes.push(0 - (what[i] & 128) | what[i] & 127);\n          return bytes\n        }\n        return 0 - (what & 128) | what & 127\n      };\n      p.parseChar = function(key) {\n        if (typeof key === \"number\") return new Char(String.fromCharCode(key & 65535));\n        if (key instanceof Array) {\n          var ret = [];\n          for (var i = 0; i < key.length; i++) ret.push(new Char(String.fromCharCode(key[i] & 65535)));\n          return ret\n        }\n        throw \"char() may receive only one argument of type int, byte, int[], or byte[].\";\n      };\n\n      function floatScalar(val) {\n        if (typeof val === \"number\") return val;\n        if (typeof val === \"boolean\") return val ? 1 : 0;\n        if (typeof val === \"string\") return parseFloat(val);\n        if (val instanceof Char) return val.code\n      }\n      p.parseFloat = function(val) {\n        if (val instanceof Array) {\n          var ret = [];\n          for (var i = 0; i < val.length; i++) ret.push(floatScalar(val[i]));\n          return ret\n        }\n        return floatScalar(val)\n      };\n\n      function intScalar(val, radix) {\n        if (typeof val === \"number\") return val & 4294967295;\n        if (typeof val === \"boolean\") return val ? 1 : 0;\n        if (typeof val === \"string\") {\n          var number = parseInt(val, radix || 10);\n          return number & 4294967295\n        }\n        if (val instanceof\n        Char) return val.code\n      }\n      p.parseInt = function(val, radix) {\n        if (val instanceof Array) {\n          var ret = [];\n          for (var i = 0; i < val.length; i++) if (typeof val[i] === \"string\" && !/^\\s*[+\\-]?\\d+\\s*$/.test(val[i])) ret.push(0);\n          else ret.push(intScalar(val[i], radix));\n          return ret\n        }\n        return intScalar(val, radix)\n      };\n      p.bezierPoint = function(a, b, c, d, t) {\n        return (1 - t) * (1 - t) * (1 - t) * a + 3 * (1 - t) * (1 - t) * t * b + 3 * (1 - t) * t * t * c + t * t * t * d\n      };\n      p.bezierTangent = function(a, b, c, d, t) {\n        return 3 * t * t * (-a + 3 * b - 3 * c + d) + 6 * t * (a - 2 * b + c) + 3 * (-a + b)\n      };\n      p.curvePoint = function(a, b, c, d, t) {\n        return 0.5 * (2 * b + (-a + c) * t + (2 * a - 5 * b + 4 * c - d) * t * t + (-a + 3 * b - 3 * c + d) * t * t * t)\n      };\n      p.curveTangent = function(a, b, c, d, t) {\n        return 0.5 * (-a + c + 2 * (2 * a - 5 * b + 4 * c - d) * t + 3 * (-a + 3 * b - 3 * c + d) * t * t)\n      };\n      p.millis = function() {\n        return Date.now() - start;\n      };\n    })(context);\n\n    return context;\n};\n",
  "program-stubs.js": "// PhantomJS seems to fail at passing the Program object\n// inside the context- it turns the functions into null values instead.\n// That may also be the behavior of older browsers.\n// This fixes that by defining them in this stub instead.\nfunction initProgramStubs(context) {\n    /*\n     * Processing functions that return values should have implementations\n     * here.\n     */\n\n    context = context || {};\n\n    context.Program = {\n        settings: function() {return {};},\n        runTests: function() {},\n        runTest: function() {},\n        restart: function() {},\n        assertEqual: function() {}\n    };\n\n    return context;\n}",
  "structured.js": "/*\n * StructuredJS provides an API for static analysis of code based on an abstract\n * syntax tree generated by Esprima (compliant with the Mozilla Parser\n * API at https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API).\n *\n * Dependencies: esprima.js, underscore.js\n */\n(function(global) {\n    /* Detect npm versus browser usage */\n    var exports;\n    var esprima;\n    var _;\n\n    // Cache all the structure tests\n    var structureCache = {};\n\n    // Cache the most recently-parsed code and tree\n    var cachedCode;\n    var cachedCodeTree;\n\n    if (typeof module !== \"undefined\" && module.exports) {\n        exports = module.exports = {};\n        esprima = require(\"esprima\");\n        _ = require(\"underscore\");\n    } else {\n        exports = this.Structured = {};\n        esprima = global.esprima;\n        _ = global._;\n    }\n\n    if (!esprima || !_) {\n        throw \"Error: Both Esprima and UnderscoreJS are required dependencies.\";\n    }\n\n    /*\n     * Introspects a callback to determine it's parameters and then\n     * produces a constraint that contains the appropriate variables and callbacks.\n     *\n     * This allows a much terser definition of callback function where you don't have to\n     * explicitly state the parameters in a separate list\n     */\n    function makeConstraint(callback) {\n        var paramText = /^function [^\\(]*\\(([^\\)]*)\\)/.exec(callback)[1];\n        var params = paramText.match(/[$_a-zA-z0-9]+/g);\n\n        for (var key in params) {\n            if (params[key][0] !== \"$\") {\n                console.warn(\"Invalid parameter in constraint (should begin with a '$'): \", params[key]);\n                return null;\n            }\n        }\n        return {\n            variables: params,\n            fn: callback\n        };\n    }\n\n    /*\n     * Returns true if the code (a string) matches the structure in rawStructure\n     * Throws an exception if code is not parseable.\n     *\n     * Example:\n     *     var code = \"if (y > 30 && x > 13) {x += y;}\";\n     *     var rawStructure = function structure() { if (_) {} };\n     *     match(code, rawStructure);\n     *\n     * options.varCallbacks is an object that maps user variable strings like\n     *  \"$myVar\", \"$a, $b, $c\" etc to callbacks. These callbacks receive the\n     *  potential Esprima structure values assigned to each of the user\n     *  variables specified in the string, and can accept/reject that value\n     *  by returning true/false. The callbacks can also specify a failure\n     *  message instead by returning an object of the form\n     *  {failure: \"Your failure message\"}, in which case the message will be\n     *  returned as the property \"failure\" on the varCallbacks object if\n     *  there is no valid match. A valid matching requires that every\n     *  varCallback return true.\n     *\n     * Advanced Example:\n     *   var varCallbacks = [\n     *     function($foo) {\n     *         return $foo.value > 92;\n     *     },\n     *     function($foo, $bar, $baz) {\n     *         if ($foo.value > $bar.value) {\n     *            return {failure: \"Check the relationship between values.\"};\n     *         }\n     *         return $baz.value !== 48;\n     *     }\n     *   ];\n     *   var code = \"var a = 400; var b = 120; var c = 500; var d = 49;\";\n     *   var rawStructure = function structure() {\n     *       var _ = $foo; var _ = $bar; var _ = $baz;\n     *   };\n     *   match(code, rawStructure, {varCallbacks: varCallbacks});\n     */\n    var originalVarCallbacks;\n    function match(code, rawStructure, options) {\n        options = options || {};\n        // Many possible inputs formats are accepted for varCallbacks\n        // Constraints can be:\n        // 1. a function (from which we will extract the variables)  \n        // 2. an objects (which already has separate .fn and .variables properties)\n        //\n        // It will also accept a list of either of the above (or a mix of the two).\n        // Finally it can accept an object for which the keys are the variables and \n        // the values are the callbacks (This option is mainly for historical reasons)\n        var varCallbacks = options.varCallbacks || [];\n        // We need to keep a hold of the original varCallbacks object because \n        // When structured first came out it returned the failure message by \n        // changing the .failure property on the varCallbacks object and some uses rely on that.\n        // We hope to get rid of this someday.\n        // TODO: Change over the code so to have a better API\n        originalVarCallbacks = varCallbacks;\n        if (varCallbacks instanceof Function || (varCallbacks.fn && varCallbacks.variables)) {\n            varCallbacks = [varCallbacks];\n        }\n        if (varCallbacks instanceof Array) {\n            for (var key in varCallbacks) {\n                if (varCallbacks[key] instanceof Function) {\n                    varCallbacks[key] = makeConstraint(varCallbacks[key]);\n                }\n            }\n        } else {\n            var realCallbacks = [];\n            for (var vars in varCallbacks) {\n                if (varCallbacks.hasOwnProperty(vars) && vars !== \"failure\") {\n                    realCallbacks.push({\n                        variables: vars.match(/[$_a-zA-z0-9]+/g),\n                        fn: varCallbacks[vars]\n                    });\n                }\n            }\n            varCallbacks = realCallbacks;\n        }\n        var wildcardVars = {\n            order: [],\n            skipData: {},\n            values: {}\n        };\n        // Note: After the parse, structure contains object references into\n        // wildcardVars[values] that must be maintained. So, beware of\n        // JSON.parse(JSON.stringify), etc. as the tree is no longer static.\n        var structure = parseStructureWithVars(rawStructure, wildcardVars);\n\n        // Cache the parsed code tree, or pull from cache if it exists\n        var codeTree = (cachedCode === code ?\n            cachedCodeTree :\n            typeof code === \"object\" ?\n            deepClone(code) :\n            esprima.parse(code));\n\n        cachedCode = code;\n        cachedCodeTree = codeTree;\n\n        foldConstants(codeTree);\n        var toFind = structure.body || structure;\n        var peers = [];\n        if (_.isArray(structure.body)) {\n            toFind = structure.body[0];\n            peers = structure.body.slice(1);\n        }\n        var result;\n        var matchResult = {\n            _: [],\n            vars: {}\n        };\n        if (wildcardVars.order.length === 0 || options.single) {\n            // With no vars to match, our normal greedy approach works great.\n            result = checkMatchTree(codeTree, toFind, peers, wildcardVars, matchResult, options);\n        } else {\n            // If there are variables to match, we must do a potentially\n            // exhaustive search across the possible ways to match the vars.\n            result = anyPossible(0, wildcardVars, varCallbacks, matchResult, options);\n        }\n        return result;\n\n        /*\n         * Checks whether any possible valid variable assignment for this i\n         *  results in a valid match.\n         *\n         * We orchestrate this check by building skipData, which specifies\n         *  for each variable how many possible matches it should skip before\n         *  it guesses a match. The iteration over the tree is the same\n         *  every time -- if the first guess fails, the next run will skip the\n         *  first guess and instead take the second appearance, and so on.\n         *\n         * When there are multiple variables, changing an earlier (smaller i)\n         *  variable guess means that we must redo the guessing for the later\n         *  variables (larger i).\n         *\n         * Returning false involves exhausting all possibilities. In the worst\n         *  case, this will mean exponentially many possibilities -- variables\n         *  are expensive for all but small tests.\n         *\n         * wildcardVars = wVars:\n         *     .values[varName] contains the guessed node value of each\n         *     variable, or the empty object if none.\n         *     .skipData[varName] contains the number of potential matches of\n         *          this var to skip before choosing a guess to assign to values\n         *     .leftToSkip[varName] stores the number of skips left to do\n         *         (used during the match algorithm)\n         *     .order[i] is the name of the ith occurring variable.\n         */\n        function anyPossible(i, wVars, varCallbacks, matchResults, options) {\n            var order = wVars.order; // Just for ease-of-notation.\n            wVars.skipData[order[i]] = 0;\n            do {\n                // Reset the skip # for all later variables.\n                for (var rest = i + 1; rest < order.length; rest += 1) {\n                    wVars.skipData[order[rest]] = 0;\n                }\n                // Check for a match only if we have reached the last var in\n                // order (and so set skipData for all vars). Otherwise,\n                // recurse to check all possible values of the next var.\n                if (i === order.length - 1) {\n                    // Reset the wildcard vars' guesses. Delete the properties\n                    // rather than setting to {} in order to maintain shared\n                    // object references in the structure tree (toFind, peers)\n                    _.each(wVars.values, function(value, key) {\n                        _.each(wVars.values[key], function(v, k) {\n                            delete wVars.values[key][k];\n                        });\n                    });\n                    wVars.leftToSkip = _.extend({}, wVars.skipData);\n                    // Use a copy of peers because peers is destructively\n                    // modified in checkMatchTree (via checkNodeArray).\n                    if (checkMatchTree(codeTree, toFind, peers.slice(), wVars, matchResults, options) &&\n                        checkUserVarCallbacks(wVars, varCallbacks)) {\n                        return matchResults;\n                    }\n                } else if (anyPossible(i + 1, wVars, varCallbacks, matchResults, options)) {\n                    return matchResults;\n                }\n                // This guess didn't work out -- skip it and try the next.\n                wVars.skipData[order[i]] += 1;\n                // The termination condition is when we have run out of values\n                // to skip and values is no longer defined for this var after\n                // the match algorithm. That means that there is no valid\n                // assignment for this and later vars given the assignments to\n                // previous vars (set by skipData).\n            } while (!_.isEmpty(wVars.values[order[i]]));\n            return false;\n        }\n    }\n\n    /*\n     * Checks the user-defined variable callbacks and returns a boolean for\n     *   whether or not the wVars assignment of the wildcard variables results\n     *   in every varCallback returning true as required.\n     *\n     * If any varCallback returns false, this function also returns false.\n     *\n     * Format of varCallbacks: An object containing:\n     *     keys of the form: \"$someVar\" or \"$foo, $bar, $baz\" to mimic an\n     *        array (as JS keys must be strings).\n     *     values containing function callbacks. These callbacks must return\n     *        true/false. They may alternately return an object of the form\n     *        {failure: \"The failure message.\"}. If the callback returns the\n     *        failure object, then the relevant failure message will be returned\n     *        via varCallbacks.failure.\n     *        These callbacks are passed a parameter list corresponding to\n     *         the Esprima parse structures assigned to the variables in\n     *         the key (see example).\n     *\n     * Example varCallbacks object:\n     *    {\n     *     \"$foo\": function(fooObj) {\n     *         return fooObj.value > 92;\n     *     },\n     *     \"$foo, $bar, $baz\": function(fooObj, barObj, bazObj) {\n     *         if (fooObj.value > barObj.value) {\n     *            return {failure: \"Check the relationship between values.\"}\n     *         }\n     *         return bazObj !== 48;\n     *     }\n     *   }\n     */\n    function checkUserVarCallbacks(wVars, varCallbacks) {\n        // Clear old failure message if needed\n        delete originalVarCallbacks.failure;\n        for (var key in varCallbacks) {\n            // Property strings may be \"$foo, $bar, $baz\" to mimic arrays.\n            var varNames = varCallbacks[key].variables;\n            var varValues = _.map(varNames, function(varName) {\n                varName = stringLeftTrim(varName); // Trim whitespace\n                // If the var name is in the structure, then it will always\n                // exist in wVars.values after we find a match prior to\n                // checking the var callbacks. So, if a variable name is not\n                // defined here, it is because that var name does not exist in\n                // the user-defined structure.\n                if (!_.has(wVars.values, varName)) {\n                    console.error(\"Callback var \" + varName + \" doesn't exist\");\n                    return undefined;\n                }\n                // Convert each var name to the Esprima structure it has\n                // been assigned in the parse. Make a deep copy.\n                return deepClone(wVars.values[varName]);\n            });\n            // Call the user-defined callback, passing in the var values as\n            // parameters in the order that the vars were defined in the\n            // property string.\n            var result = varCallbacks[key].fn.apply(null, varValues);\n            if (!result || _.has(result, \"failure\")) {\n                // Set the failure message if the user callback provides one.\n                if (_.has(result, \"failure\")) {\n                    originalVarCallbacks.failure = result.failure;\n                }\n                return false;\n            }\n        }\n        return true;\n\n        /* Trim is only a string method in IE9+, so use a regex if needed. */\n        function stringLeftTrim(str) {\n            if (String.prototype.trim) {\n                return str.trim();\n            }\n            return str.replace(/^\\s+|\\s+$/g, \"\");\n        }\n    }\n\n    function parseStructure(structure) {\n        if (typeof structure === \"object\") {\n            return deepClone(structure);\n        }\n\n        if (structureCache[structure]) {\n            return JSON.parse(structureCache[structure]);\n        }\n\n        // Wrapped in parentheses so function() {} becomes valid Javascript.\n        var fullTree = esprima.parse(\"(\" + structure + \")\");\n\n        if (fullTree.body[0].expression.type !== \"FunctionExpression\" ||\n            !fullTree.body[0].expression.body) {\n            throw \"Poorly formatted structure code\";\n        }\n\n        var tree = fullTree.body[0].expression.body;\n        structureCache[structure] = JSON.stringify(tree);\n        return tree;\n    }\n\n    /*\n     * Returns a tree parsed out of the structure. The returned tree is an\n     *    abstract syntax tree with wildcard properties set to undefined.\n     *\n     * structure is a specification looking something like:\n     *        function structure() {if (_) { var _ = 3; }}\n     *    where _ denotes a blank (anything can go there),\n     *    and code can go before or after any statement (only the nesting and\n     *        relative ordering matter).\n     */\n    function parseStructureWithVars(structure, wVars) {\n        var tree = parseStructure(structure);\n        foldConstants(tree);\n        simplifyTree(tree, wVars);\n        return tree;\n    }\n\n    /*\n     * Constant folds the syntax tree\n     */\n    function foldConstants(tree) {\n        for (var key in tree) {\n            if (!tree.hasOwnProperty(key)) {\n                continue; // Inherited property\n            }\n\n            var ast = tree[key];\n            if (_.isObject(ast)) {\n                foldConstants(ast);\n\n                /*\n                 * Currently, we only fold + and - applied to a number literal.\n                 * This is easy to extend, but it means we lose the ability to match\n                 * potentially useful expressions like 5 + 5 with a pattern like _ + _.\n                 */\n                if (ast.type == esprima.Syntax.UnaryExpression) {\n                    var argument = ast.argument;\n                    if (argument.type === esprima.Syntax.Literal &&\n                        _.isNumber(argument.value)) {\n                        if (ast.operator === \"-\") {\n                            argument.value = -argument.value;\n                            tree[key] = argument;\n                        } else if (ast.operator === \"+\") {\n                            argument.value = +argument.value;\n                            tree[key] = argument;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Recursively traverses the tree and sets _ properties to undefined\n     * and empty bodies to null.\n     *\n     *  Wildcards are explicitly set to undefined -- these undefined properties\n     *  must exist and be non-null in order for code to match the structure.\n     *\n     *  Wildcard variables are set up such that the first occurrence of the\n     *   variable in the structure tree is set to {wildcardVar: varName},\n     *   and all later occurrences just refer to wVars.values[varName],\n     *   which is an object assigned during the matching algorithm to have\n     *   properties identical to our guess for the node matching the variable.\n     *   (maintaining the reference). In effect, these later accesses\n     *   to tree[key] mimic tree[key] simply being set to the variable value.\n     *\n     *  Empty statements are deleted from the tree -- they need not be matched.\n     *\n     *  If the subtree is an array, we just iterate over the array using\n     *    for (var key in tree)\n     *\n     */\n    function simplifyTree(tree, wVars) {\n        for (var key in tree) {\n            if (!tree.hasOwnProperty(key)) {\n                continue; // Inherited property\n            }\n            if (_.isObject(tree[key])) {\n                if (isWildcard(tree[key])) {\n                    tree[key] = undefined;\n                } else if (isWildcardVar(tree[key])) {\n                    var varName = tree[key].name;\n                    if (!wVars.values[varName]) {\n                        // Perform setup for the first occurrence.\n                        wVars.values[varName] = {}; // Filled in later.\n                        tree[key] = {\n                            wildcardVar: varName\n                        };\n                        wVars.order.push(varName);\n                        wVars.skipData[varName] = 0;\n                    } else {\n                        tree[key] = wVars.values[varName]; // Reference.\n                    }\n                } else if (tree[key].type === esprima.Syntax.EmptyStatement) {\n                    // Arrays are objects, but delete tree[key] does not\n                    //  update the array length property -- so, use splice.\n                    _.isArray(tree) ? tree.splice(key, 1) : delete tree[key];\n                } else {\n                    simplifyTree(tree[key], wVars);\n                }\n            }\n        }\n    }\n\n    /*\n     * Returns whether the structure node is intended as a wildcard node, which\n     * can be filled in by anything in others' code.\n     */\n    function isWildcard(node) {\n        return node.name && node.name === \"_\";\n    }\n\n    /* Returns whether the structure node is intended as a wildcard variable. */\n    function isWildcardVar(node) {\n        return (node.name && _.isString(node.name) && node.name.length >= 2 &&\n            node.name[0] === \"$\");\n    }\n\n    /*\n     *\n     */\n    function isGlob(node) {\n        return node && node.name &&\n            ((node.name === \"glob_\" && \"_\") ||\n                (node.name.indexOf(\"glob$\") === 0 && node.name.slice(5))) ||\n            node && node.expression && isGlob(node.expression);\n    }\n\n    /*\n     * Returns true if currTree matches the wildcard structure toFind.\n     *\n     * currTree: The syntax node tracking our current place in the user's code.\n     * toFind: The syntax node from the structure that we wish to find.\n     * peersToFind: The remaining ordered syntax nodes that we must find after\n     *     toFind (and on the same level as toFind).\n     */\n    function checkMatchTree(currTree, toFind, peersToFind, wVars, matchResults, options) {\n        if (_.isArray(toFind)) {\n            console.error(\"toFind should never be an array.\");\n            console.error(toFind);\n        }\n        if (exactMatchNode(currTree, toFind, peersToFind, wVars, matchResults, options)) {\n            return matchResults;\n        }\n        // Don't recurse if we're just checking a single node.\n        if (options.single) {\n            return false;\n        }\n        // Check children.\n        for (var key in currTree) {\n            if (!currTree.hasOwnProperty(key) || !_.isObject(currTree[key])) {\n                continue; // Skip inherited properties\n            }\n            // Recursively check for matches\n            if ((_.isArray(currTree[key]) &&\n                    checkNodeArray(currTree[key], toFind, peersToFind, wVars, matchResults, options)) ||\n                (!_.isArray(currTree[key]) &&\n                    checkMatchTree(currTree[key], toFind, peersToFind, wVars, matchResults, options))) {\n                return matchResults;\n            }\n        }\n        return false;\n    }\n\n    /*\n     * Returns true if this level of nodeArr matches the node in\n     * toFind, and also matches all the nodes in peersToFind in order.\n     */\n    function checkNodeArray(nodeArr, toFind, peersToFind, wVars, matchResults, options) {\n        var curGlob;\n\n        for (var i = 0; i < nodeArr.length; i += 1) {\n            if (isGlob(toFind)) {\n                if (!curGlob) {\n                    curGlob = [];\n                    var globName = isGlob(toFind);\n                    if (globName === \"_\") {\n                        matchResults._.push(curGlob);\n                    } else {\n                        matchResults.vars[globName] = curGlob;\n                    }\n                }\n                curGlob.push(nodeArr[i]);\n            } else if (checkMatchTree(nodeArr[i], toFind, peersToFind, wVars, matchResults, options)) {\n                if (!peersToFind || peersToFind.length === 0) {\n                    return matchResults;\n                    // Found everything needed on this level.\n                } else {\n                    // We matched this node, but we still have more nodes on\n                    // this level we need to match on subsequent iterations\n                    toFind = peersToFind.shift(); // Destructive.\n                }\n            }\n        }\n\n        if (curGlob) {\n            return matchResults;\n        } else if (isGlob(toFind)) {\n            var globName = isGlob(toFind);\n            if (globName === \"_\") {\n                matchResults._.push([]);\n            } else {\n                matchResults.vars[globName] = [];\n            }\n            return matchResults;\n        }\n\n        return false;\n    }\n\n\n    /*\n     * This discards all wildcard vars that were part of a failed match\n     * this provides an important speedup by stopping anyPossible from having to increment\n     * every match on a doomed set of arguments.\n     * If the any argument set fails no amount of incrementing can save it.\n     */\n    function discardWVarsOnFailureDecorator(callback) {\n        return function(currTree, toFind, peersToFind, wVars, matchResults, options) {\n            var lastWVar;\n            for (lastWVar=0; lastWVar<wVars.order.length; lastWVar++) {\n                var candidate = wVars.values[wVars.order[lastWVar]];\n                if (_.isEmpty(candidate)) {\n                    break;\n                }\n            }\n            var result = callback(currTree, toFind, peersToFind, wVars, matchResults, options);\n            if (!result) {\n                for (; lastWVar<wVars.order.length; lastWVar++) {\n                    var candidate = wVars.values[wVars.order[lastWVar]];\n                    if (!_.isEmpty(candidate)) {\n                        // Reset the wildcard vars' guesses. Delete the properties\n                        // rather than setting to {} in order to maintain shared\n                        // object references in the structure tree (toFind, peers)\n                        _.each(candidate, function(v, k) {\n                            delete candidate[k];\n                        });\n                    } else {\n                        break;\n                    }\n                }\n                wVars._last = lastWVar;\n            }\n            return result;\n        };\n    }\n\n    /*\n     * Returns true if and only if all arguments from the pattern match the corresponding\n     * argument in the test code\n     */\n    var checkArgumentsArray = discardWVarsOnFailureDecorator(function(nodeArr, toFind, peersToFind, wVars, matchResults, options) {\n        var curGlob;\n\n        for (var i = 0; i < nodeArr.length; i += 1) {\n            if (isGlob(toFind)) {\n                if (!curGlob) {\n                    curGlob = [];\n                    var globName = isGlob(toFind);\n                    if (globName === \"_\") {\n                        matchResults._.push(curGlob);\n                    } else {\n                        matchResults.vars[globName] = curGlob;\n                    }\n                }\n                curGlob.push(nodeArr[i]);\n            } else {\n                if (checkMatchTree(nodeArr[i], toFind, peersToFind, wVars, matchResults, options)) {\n                    if (!peersToFind || peersToFind.length === 0) {\n                        return matchResults;\n                    } else {\n                        toFind = peersToFind.shift();\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        if (curGlob) {\n            return matchResults;\n        } else if (isGlob(toFind)) {\n            var globName = isGlob(toFind);\n            if (globName === \"_\") {\n                matchResults._.push([]);\n            } else {\n                matchResults.vars[globName] = [];\n            }\n            return matchResults;\n        }\n\n        return false;\n    });\n\n    /*\n     * Checks whether the currNode exactly matches the node toFind.\n     *\n     * A match is exact if for every non-null property on toFind, that\n     * property exists on currNode and:\n     *     0. If the property is undefined on toFind, it must exist on currNode.\n     *     1. Otherwise, the values have the same type (ie, they match).\n     *     2. If the values are numbers or strings, they match.\n     *     3. If the values are arrays, checkNodeArray on the arrays returns true.\n     *     4. If the values are objects, checkMatchTree on those objects\n     *         returns true (the objects recursively match to the extent we\n     *         care about, though they may not match exactly).\n     */\n    function exactMatchNode(currNode, toFind, peersToFind, wVars, matchResults, options) {\n        var rootToSet;\n\n        if (!matchResults.root && currNode.type !== \"Program\") {\n            rootToSet = currNode;\n        }\n\n        for (var key in toFind) {\n            // Ignore inherited properties; also, null properties can be\n            // anything and do not have to exist.\n            if (!toFind.hasOwnProperty(key) || toFind[key] === null) {\n                continue;\n            }\n            var subFind = toFind[key];\n            var subCurr = currNode[key];\n            // Undefined properties can be anything, but they must exist.\n            if (subFind === undefined) {\n                if (subCurr === null || subCurr === undefined) {\n                    return false;\n                } else {\n                    matchResults._.push(subCurr);\n                    continue;\n                }\n            }\n            // currNode does not have the key, but toFind does\n            if (subCurr === undefined || subCurr === null) {\n                if (key === \"wildcardVar\") {\n                    if (wVars.leftToSkip && wVars.leftToSkip[subFind] > 0) {\n                        wVars.leftToSkip[subFind] -= 1;\n                        return false; // Skip, this does not match our wildcard\n                    }\n                    // We have skipped the required number, so take this guess.\n                    // Copy over all of currNode's properties into\n                    //  wVars.values[subFind] so the var references set up in\n                    //  simplifyTree behave like currNode. Shallow copy.\n                    _.extend(wVars.values[subFind], currNode);\n                    matchResults.vars[subFind.slice(1)] = currNode;\n                    if (rootToSet) {\n                        matchResults.root = rootToSet;\n                    }\n                    return matchResults; // This node is now our variable.\n                }\n                return false;\n            }\n            // Now handle arrays/objects/values\n            if (_.isObject(subCurr) !== _.isObject(subFind) ||\n                _.isArray(subCurr) !== _.isArray(subFind) ||\n                (typeof(subCurr) !== typeof(subFind))) {\n                console.error(\"Object/array/other type mismatch.\");\n                return false;\n            } else if (_.isArray(subCurr)) {\n                // Both are arrays, do a recursive compare.\n                // (Arrays are objects so do this check before the object check)\n                if (subFind.length === 0) {\n                    continue; // Empty arrays can match any array.\n                }\n                var newToFind = subFind[0];\n                var peers = subFind.slice(1);\n                if (key === \"params\" || key === \"arguments\") {\n                    if (!checkArgumentsArray(subCurr, newToFind, peers, wVars, matchResults, options)) {\n                        return false;\n                    }\n                } else if (!checkNodeArray(subCurr, newToFind, peers, wVars, matchResults, options)) {\n                    return false;\n                }\n            } else if (_.isObject(subCurr)) {\n                // Both are objects, so do a recursive compare.\n                if (!checkMatchTree(subCurr, subFind, peersToFind, wVars, matchResults, options)) {\n                    return false;\n                }\n            } else if (!_.isObject(subCurr)) {\n                // Check that the non-object (number/string) values match\n                if (subCurr !== subFind) {\n                    return false;\n                }\n            } else { // Logically impossible, but as a robustness catch.\n                console.error(\"Some weird never-before-seen situation!\");\n                console.error(currNode);\n                console.error(subCurr);\n                throw \"Error: logic inside of structure analysis code broke.\";\n            }\n        }\n        if (toFind === undefined) {\n            matchResults._.push(currNode);\n        }\n        if (rootToSet) {\n            matchResults.root = rootToSet;\n        }\n        return matchResults;\n    }\n\n    function deepClone(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n\n    /*\n     * Takes in a string for a structure and returns HTML for nice styling.\n     * The blanks (_) are enclosed in span.structuredjs_blank, and the\n     * structured.js variables ($someVar) are enclosed in span.structuredjs_var\n     * for special styling.\n     *\n     * See pretty-display/index.html for a demo and sample stylesheet.\n     *\n     * Only works when RainbowJS (http://craig.is/making/rainbows) is\n     * included on the page; if RainbowJS is not available, simply\n     * returns the code string. RainbowJS is not available as an npm\n     * module.\n     */\n    function prettyHtml(code, callback) {\n        if (!Rainbow) {\n            return code;\n        }\n        Rainbow.color(code, \"javascript\", function(formattedCode) {\n            var output = (\"<pre class='rainbowjs'>\" +\n                addStyling(formattedCode) + \"</pre>\");\n            callback(output);\n        });\n    }\n\n    /*\n     * Helper function for prettyHtml that takes in a string (the formatted\n     * output of RainbowJS) and inserts special StructuredJS spans for\n     * blanks (_) and variables ($something).\n     *\n     * The optional parameter maintainStyles should be set to true if the\n     * caller wishes to keep the class assignments from the previous call\n     * to addStyling and continue where we left off. This parameter is\n     * valuable for visual consistency across different structures that share\n     * variables.\n     */\n    function addStyling(code, maintainStyles) {\n        if (!maintainStyles) {\n            addStyling.styleMap = {};\n            addStyling.counter = 0;\n        }\n        // First replace underscores with empty structuredjs_blank spans\n        // Regex: Match any underscore _ that is not preceded or followed by an\n        // alphanumeric character.\n        code = code.replace(/(^|[^A-Za-z0-9])_(?![A-Za-z0-9])/g,\n            \"$1<span class='structuredjs_blank'></span>\");\n        // Next replace variables with empty structuredjs_var spans numbered\n        // with classes.\n        // This regex is in two parts:\n        //  Part 1, delimited by the non-capturing parentheses `(?: ...)`:\n        //    (^|[^\\w])\\$(\\w+)\n        //    Match any $ that is preceded by either a 'start of line', or a\n        //    non-alphanumeric character, and is followed by at least one\n        //    alphanumeric character (the variable name).\n        //  Part 2, also delimited by the non-capturing parentheses:\n        //      ()\\$<span class=\"function call\">(\\w+)<\\/span>\n        //      Match any function call immediately preceded by a dollar sign,\n        //      where the Rainbow syntax highlighting separated a $foo()\n        //      function call by placing the dollar sign outside.\n        //      the function call span to create\n        //      $<span class=\"function call\">foo</span>.\n        // We combine the two parts with an | (an OR) so that either matches.\n        // The reason we do this all in one go rather than in two separate\n        // calls to replace is so that we color the string in order,\n        // rather than coloring all non-function calls and then going back\n        // to do all function calls (a minor point, but otherwise the\n        // interactive pretty display becomes jarring as previous\n        // function call colors change when new variables are introduced.)\n        // Finally, add the /g flag for global replacement.\n        var regexVariables = /(?:(^|[^\\w])\\$(\\w+))|(?:\\$<span class=\"function call\">(\\w+)<\\/span>)/g;\n        return code.replace(regexVariables,\n            function(m, prev, varName, fnVarName) {\n                // Necessary to handle the fact we are essentially performing\n                // two regexes at once as outlined above.\n                prev = prev || \"\";\n                varName = varName || fnVarName;\n                var fn = addStyling;\n                // Assign the next available class to this variable if it does\n                // not yet exist in our style mapping.\n                if (!(varName in fn.styleMap)) {\n                    fn.styleMap[varName] = (fn.counter < fn.styles.length ?\n                        fn.styles[fn.counter] : \"extra\");\n                    fn.counter += 1;\n                }\n                return (prev + \"<span class='structuredjs_var \" +\n                    fn.styleMap[varName] + \"'>\" + \"</span>\");\n            }\n        );\n    }\n    // Store some properties on the addStyling function to maintain the\n    // styleMap between runs if desired.\n    // Right now just support 7 different variables. Just add more if needed.\n    addStyling.styles = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\",\n        \"seven\"\n    ];\n    addStyling.styleMap = {};\n    addStyling.counter = 0;\n\n    function getSingleData(node, data) {\n        if (!node || node.type !== \"Identifier\") {\n            return;\n        }\n\n        if (node.name === \"_\") {\n            if (!data._ || data._.length === 0) {\n                throw \"No _ data available.\";\n            }\n\n            return data._.shift();\n        } else if (node.name && node.name.indexOf(\"$\") === 0) {\n            var name = node.name.slice(1);\n\n            if (!data.vars || !(name in data.vars)) {\n                throw \"No vars available.\";\n            }\n\n            return data.vars[name];\n        }\n    }\n\n    function getGlobData(node, data) {\n        var check = node && node.expression || node;\n\n        if (!check || check.type !== \"Identifier\") {\n            return;\n        }\n\n        if (check.name === \"glob_\") {\n            if (!data._ || data._.length === 0) {\n                throw \"No _ data available.\";\n            }\n\n            return data._.shift();\n        } else if (check.name && check.name.indexOf(\"glob$\") === 0) {\n            var name = check.name.slice(5);\n\n            if (!data.vars || !(name in data.vars)) {\n                throw \"No vars available.\";\n            }\n\n            return data.vars[name];\n        }\n    }\n\n    function injectData(node, data) {\n        if (!node) {\n            return node;\n        }\n\n        for (var prop in node) {\n            if (!node.hasOwnProperty(prop)) {\n                continue;\n            }\n\n            if (node[prop] && typeof node[prop] === \"object\" && \"length\" in node[prop]) {\n                for (var i = 0; i < node[prop].length; i++) {\n                    var globData = getGlobData(node[prop][i], data);\n\n                    if (globData) {\n                        node[prop].splice.apply(node[prop],\n                            [i, 1].concat(globData));\n                        break;\n                    } else if (typeof node[prop][i] === \"object\") {\n                        var singleData = getSingleData(node[prop][i], data);\n\n                        if (singleData) {\n                            node[prop][i] = singleData;\n                        } else if (typeof node[prop][i] === \"object\") {\n                            injectData(node[prop][i], data);\n                        }\n                    }\n                }\n            } else {\n                var singleData = getSingleData(node[prop], data);\n\n                if (singleData) {\n                    node[prop] = singleData;\n                } else if (typeof node[prop] === \"object\") {\n                    injectData(node[prop], data);\n                }\n            }\n        }\n\n        return node;\n    }\n\n    exports.match = match;\n    exports.matchNode = function(code, rawStructure, options) {\n        options = options || {};\n        options.single = true;\n        return match(code, rawStructure, options);\n    };\n    exports.injectData = function(node, data) {\n        node = parseStructure(node);\n        data = deepClone(data);\n        return injectData(node, data);\n    };\n    exports.prettify = prettyHtml;\n})(typeof window !== \"undefined\" ? window : global);",
  "test-worker.js": "// Mock out $._, since we don't use any of the sprintf functionality\nvar $ = {};\n$._ = function(str) { return str;};\n\n// We set window to self so that StructuredJS can find Esprima and\n// Underscore\nif (typeof window === \"undefined\") { \n    /*global window:true */\n    window = self;  \n}\n\nvar init = false;\nvar date = (new Date()).toDateString();\n\nvar tester;\n\nself.onmessage = function(event) {\n    if (!init) {\n        init = true;\n\n        if (event.data.deps) {\n            var deps = JSON.parse(event.data.deps);\n\n            eval(deps[\"es5-shim.js\"]);\n            eval(deps[\"esprima.js\"]);\n            eval(deps[\"underscore.js\"]);\n            eval(deps[\"structured.js\"]);\n            eval(deps[\"output-tester.js\"]);\n            eval(deps[\"pjs-tester.js\"]);\n        } else {\n            importScripts(event.data.externalsDir +\n            \"es5-shim/es5-shim.js?cachebust=\" + date);\n            importScripts(event.data.externalsDir +\n            \"structuredjs/external/esprima.js?cachebust=\" + date);\n            importScripts(event.data.externalsDir +\n            \"underscore/underscore.js?cachebust=\" + date);\n            importScripts(event.data.externalsDir +\n            \"structuredjs/structured.js?cachebust=\" + date);\n\n            // Bring in the testing logic\n            importScripts(\"../shared/output-tester.js?cachebust=\" + date);\n            importScripts(\"./pjs-tester.js?cachebust=\" + date);\n        }\n\n        tester = new PJSTester();\n    }\n\n    tester.test(event.data.code, event.data.validate, event.data.errors,\n        function(errors, testResults) {\n            // Return the test results to the main code\n            self.postMessage({\n                 type: \"test\",\n                 message: {\n                    testResults: testResults,\n                    errors: errors\n                }\n            });\n        });\n};",
  "underscore.js": "//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n",
  "worker.js": "/* global initProcessingStubs */\n\nvar init = false;\n\nself.onmessage = function(event) {\n    var data = JSON.parse(event.data);\n    \n    if (!init) {\n        init = true;\n        var deps = data.deps;\n\n        eval(deps[\"processing-stubs.js\"]);\n        eval(deps[\"program-stubs.js\"]);\n        \n        self.initProcessingStubs = initProcessingStubs;\n        self.initProgramStubs = initProgramStubs;\n    }\n    \n    var context = data.context,\n        code = \"with(arguments[0]){\\n\" +\n            data.code +\n            \"\\nif (typeof draw !== 'undefined' && draw){draw();}}\",\n        runtimeCost = 0,\n        drawMethods = [\"background\", \"bezier\", \"curve\", \"ellipse\", \"line\",\n            \"quad\", \"rect\", \"triangle\", \"vertex\", \"text\", \"image\"],\n        willDraw = {};\n\n    // Generates a function for counting the rough complexity of a specific\n    // function call. (It assumes that Processing function calls that draw\n    // to the screen are inherently more complex.)\n    var drawCounter = function(name) {\n        return function() {\n            runtimeCost += willDraw[name] ? 1 : 0.1;\n            return 0;\n        };\n    };\n\n    for (var i = 0; i < drawMethods.length; i++) {\n        willDraw[drawMethods[i]] = true;\n    }\n\n    // Populates the environment with most of the processing\n    // functions that return values\n    var stubbedContext = initProcessingStubs();\n    stubbedContext = initProgramStubs(stubbedContext);\n\n    // Go through all the properties exposed by the program\n    // (previously extracted via JSHint, et. al.)\n    var unstubFunctionsInObject = function(object) {\n        for (var prop in object) {\n            if (object.hasOwnProperty(prop)) {\n                // We're unable to pass functions to a web worker so we must\n                // pass in a stubbed function placeholder, instead. If possible\n                // we try to replace it with the corresponding function in\n                // Processing.js. If not then we make a dummy function that we\n                // use to track the complexity of the program.\n                if (object[prop] === \"__STUBBED_FUNCTION__\") {\n                    object[prop] = prop in stubbedContext ?\n                        stubbedContext[prop] :\n                        drawCounter(prop);\n                } else if (typeof object[prop] === \"object\") {\n                    if (prop === \"Program\" && prop in stubbedContext) {\n                        object[prop] = stubbedContext[prop];\n                    } else {\n                        unstubFunctionsInObject(object[prop]);\n                    }\n                }\n            }\n        }\n    };\n\n    unstubFunctionsInObject(context);\n\n    // Let the parent know that execution is about to begin\n    self.postMessage({ execStarted: true });\n\n    setTimeout(function(){\n        // Execute the code and the drawing function, at least once\n        // TODO: Run other functions that execute on event (mousePressed, etc.)\n        (new Function(code)).call({}, context);\n\n        // Cap the maximum number of function calls\n        // Score 1 for the popular function calls that draw to the screen\n        // Score 0.1 for every other function calls\n        // Max determined rather arbitrarily, higher than this seems too\n        // complex for most simple programs\n        if (runtimeCost > 16000) {\n            // A dummy $._() i18n placeholder to avoid including the i18n.js file\n            var $ = {\n                _: function(str){\n                    return str;\n                }\n            };\n\n            self.postMessage({\n                type: \"error\",\n                message: $._(\"The program is taking too long to run. \" +\n                             \"Perhaps you could try and make it a bit simpler?\")\n            });\n        } else {\n            self.postMessage({ type: \"end\" });\n        }\n    }, 1);\n};\n"
}